<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="记在本子上忘记是哪些公司的笔试了誒..将就吧有些没找到答案   1、使用DOM解析XML使用DOM方式进行xml文档的写入和解析的方法 DOM解析XML文档时会遍历整个XML文档，在内存中建立一个树的数据结构。 与JavaScript中DOM方法类似，可以通过getElementsByTagName方法获取到特定的标签对象 当同样的标签很多的话使用List来存储返回的多个标签对象  通过DOM写">
<meta property="og:type" content="article">
<meta property="og:title" content="笔试汇总帖-4">
<meta property="og:url" content="http://yoursite.com/2018/10/04/笔试总结帖-4/index.html">
<meta property="og:site_name" content="Welcome">
<meta property="og:description" content="记在本子上忘记是哪些公司的笔试了誒..将就吧有些没找到答案   1、使用DOM解析XML使用DOM方式进行xml文档的写入和解析的方法 DOM解析XML文档时会遍历整个XML文档，在内存中建立一个树的数据结构。 与JavaScript中DOM方法类似，可以通过getElementsByTagName方法获取到特定的标签对象 当同样的标签很多的话使用List来存储返回的多个标签对象  通过DOM写">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-10-04T12:46:24.867Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔试汇总帖-4">
<meta name="twitter:description" content="记在本子上忘记是哪些公司的笔试了誒..将就吧有些没找到答案   1、使用DOM解析XML使用DOM方式进行xml文档的写入和解析的方法 DOM解析XML文档时会遍历整个XML文档，在内存中建立一个树的数据结构。 与JavaScript中DOM方法类似，可以通过getElementsByTagName方法获取到特定的标签对象 当同样的标签很多的话使用List来存储返回的多个标签对象  通过DOM写">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/10/04/笔试总结帖-4/"/>





  <title>笔试汇总帖-4 | Welcome</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Welcome</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  
  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/04/笔试总结帖-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="十点一刻">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/qifang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">笔试汇总帖-4</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-04T18:55:48+08:00">
                2018-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>记在本子上忘记是哪些公司的笔试了誒..将就吧有些没找到答案</p>
</blockquote>
<hr>
<h4 id="1、使用DOM解析XML"><a href="#1、使用DOM解析XML" class="headerlink" title="1、使用DOM解析XML"></a>1、使用DOM解析XML</h4><h5 id="使用DOM方式进行xml文档的写入和解析的方法"><a href="#使用DOM方式进行xml文档的写入和解析的方法" class="headerlink" title="使用DOM方式进行xml文档的写入和解析的方法"></a>使用DOM方式进行xml文档的写入和解析的方法</h5><ol>
<li>DOM解析XML文档时会遍历整个XML文档，在内存中建立一个树的数据结构。</li>
<li>与JavaScript中DOM方法类似，可以通过getElementsByTagName方法获取到特定的标签对象</li>
<li>当同样的标签很多的话使用List来存储返回的多个标签对象</li>
</ol>
<h5 id="通过DOM写XML文档"><a href="#通过DOM写XML文档" class="headerlink" title="通过DOM写XML文档"></a>通过DOM写XML文档</h5><ol>
<li>创建了节点之后依次连接到父节点上</li>
<li>后通过Transformer把驻留在内存中建立好的DOM树通过io流写入到特定文本</li>
</ol>
<h4 id="2、数据仓库粒度的具体划分将直接影响数据仓库中的数据量以及查询质量-true"><a href="#2、数据仓库粒度的具体划分将直接影响数据仓库中的数据量以及查询质量-true" class="headerlink" title="2、数据仓库粒度的具体划分将直接影响数据仓库中的数据量以及查询质量(true)"></a>2、数据仓库粒度的具体划分将直接影响数据仓库中的数据量以及查询质量(true)</h4><h4 id="3、哪种方法创建对象时不会调用类的构造函数"><a href="#3、哪种方法创建对象时不会调用类的构造函数" class="headerlink" title="3、哪种方法创建对象时不会调用类的构造函数"></a>3、哪种方法创建对象时不会调用类的构造函数</h4><h5 id="Java创建对象的方式"><a href="#Java创建对象的方式" class="headerlink" title="Java创建对象的方式"></a>Java创建对象的方式</h5><ol>
<li>用new语句创建对象，这是最常见的创建对象的方法</li>
<li>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法</li>
<li>调用对象的clone()方法</li>
<li>运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法</li>
</ol>
<h4 id="4、stringbuffer-stringbuilder"><a href="#4、stringbuffer-stringbuilder" class="headerlink" title="4、stringbuffer/stringbuilder"></a>4、stringbuffer/stringbuilder</h4><p>区别主要是在运行速度和线程安全</p>
<ol>
<li>StringBuffer 与 StringBuilder 中的方法和功能完全是等价的</li>
<li>StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。</li>
<li>在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低。</li>
</ol>
<h4 id="5、B类地址"><a href="#5、B类地址" class="headerlink" title="5、B类地址"></a>5、B类地址</h4><ol>
<li>B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址。另外第1个字节的前两位固定为10。</li>
<li>一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，即第一段数字范围为128～191。</li>
<li>每个B类地址可连接65534(256*256-2, 因为主机号的各位不能同时为0,1)台主机，Internet有16383(2^14)个B类地址</li>
</ol>
<h4 id="6、开销最大的缓存替换算法（FIFO）"><a href="#6、开销最大的缓存替换算法（FIFO）" class="headerlink" title="6、开销最大的缓存替换算法（FIFO）"></a>6、开销最大的缓存替换算法（FIFO）</h4><p>缓存算法是指令的一个明细表，用于决定缓存系统中哪些数据应该被删去。</p>
<ol>
<li>最不经常使用算法（LFU）：使用一个计数器来记录条目被访问的频率。通过使用LFU缓存算法，最低访问数的条目首先被移除。这个方法并不经常使用，因为它无法对一个拥有最初高访问率之后长时间没有被访问的条目缓存负责。</li>
<li>最近最少使用算法（LRU）：将最近使用的条目存放到靠近缓存顶部的位置。当一个新条目被访问时，LRU将它放置到缓存的顶部。当缓存达到极限时，较早之前访问的条目将从缓存底部开始被移除。这里会使用到昂贵的算法，而且它需要记录“年龄位”来精确显示条目是何时被访问的。此外，当一个LRU缓存算法删除某个条目后，“年龄位”将随其他条目发生改变。</li>
<li>自适应缓存替换算法(ARC)：在IBM Almaden研究中心开发，这个缓存算法同时跟踪记录LFU和LRU，以及驱逐缓存条目，来获得可用缓存的最佳使用。</li>
<li>先进先出算法（FIFO）：FIFO是英文First In First Out 的缩写，是一种先进先出的数据缓存器，他与普通存储器的区别是没有外部读写地址线，这样使用起来非常简单，但缺点就是只能顺序写入数据，顺序的读出数据，其数据地址由内部读写指针自动加1完成，不能像普通存储器那样可以由地址线决定读取或写入某个指定的地址。</li>
<li>最近最常使用算法（MRU）：这个缓存算法最先移除最近最常使用的条目。一个MRU算法擅长处理一个条目越久，越容易被访问的情况。</li>
</ol>
<h4 id="7、指令流水线"><a href="#7、指令流水线" class="headerlink" title="7、指令流水线"></a>7、指令流水线</h4><p>为提高处理器执行指令的效率，把一条指令的操作分成多个细小的步骤，每个步骤由专门的电路完成的方式。</p>
<h4 id="8、在地址栏输入“…jsp”，直到浏览器渲染网页完毕为止，期间发生的所有事件"><a href="#8、在地址栏输入“…jsp”，直到浏览器渲染网页完毕为止，期间发生的所有事件" class="headerlink" title="8、在地址栏输入“…jsp”，直到浏览器渲染网页完毕为止，期间发生的所有事件"></a>8、在地址栏输入“…jsp”，直到浏览器渲染网页完毕为止，期间发生的所有事件</h4><ol>
<li>浏览器（客户端）进行地址解析。</li>
<li>将解析出的域名进行dns解析。</li>
<li>通过ip寻址和arp，找到目标（服务器）地址。</li>
<li>进行tcp三次握手，建立tcp连接。</li>
<li>浏览器发送数据，等待服务器响应。</li>
<li>服务器处理请求，并对请求做出响应。</li>
<li>浏览器收到服务器响应，得到html代码。</li>
<li>渲染页面。<br>9、如何判断单向链表是否存在环（找出环入口）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123; </span><br><span class="line">    ListNode EntryNodeOfLoop(ListNode h)&#123;</span><br><span class="line">        if(h == null || h.next == null) </span><br><span class="line">            return null; </span><br><span class="line">            ListNode slow = h;</span><br><span class="line">            ListNode fast = h;</span><br><span class="line">            while(fast != null &amp;&amp; fast.next != null )&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            if(slow == fast)&#123;</span><br><span class="line">            ListNode p=h;</span><br><span class="line">            ListNode q=slow;//相当于让q指向了m1 while(p != q)&#123; </span><br><span class="line">            p = p.next; q = q.next;</span><br><span class="line">            &#125; </span><br><span class="line">        if(p == q) return q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、关键字"><a href="#10、关键字" class="headerlink" title="10、关键字"></a>10、关键字</h4><blockquote>
<p>finial修饰局部变量，transient方法？private顶层类？volatile构造类？</p>
</blockquote>
<ol>
<li>static  静态修饰关键字，可以修饰 变量，程序块，类的方法；</li>
<li>final 只能赋值一次；修饰变量、方法及类</li>
<li>transient 类型修饰符，只能用来修饰字段</li>
<li>volatile变量修饰符，只能用来修饰变量。</li>
</ol>
<h4 id="11、代理类"><a href="#11、代理类" class="headerlink" title="11、代理类"></a>11、代理类</h4><blockquote>
<p>（动态代理类与静态代理类必须由开发人员编写源代码并编译成.class文件）<br>（Proxy类提供了创建动态代理类方法）<br>（代理类与被代理类有相同的接口）</p>
</blockquote>
<ol>
<li>代理类，是类的代理，将类给代理，不直接调用类的方法，而通过代理来调用。</li>
<li>Proxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。</li>
<li>构造方法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Proxy() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Proxy(InvocationHandler h) &#123;</span><br><span class="line">    this.h = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、IO"><a href="#12、IO" class="headerlink" title="12、IO"></a>12、IO</h4><blockquote>
<p>reader字符？inputstream字节？objectinputstream不支持序列化对象/reader支持序列</p>
</blockquote>
<ol>
<li>ObjectInputStream 类和 ObjectInputStream 类不支持序列化的对象</li>
<li>用Reader 和Writer可以把对象用字符的形式序列化</li>
</ol>
<h4 id="13、多态"><a href="#13、多态" class="headerlink" title="13、多态"></a>13、多态</h4><blockquote>
<p>体现面向对象多态基本特征：方法重载/方法重写/匿名类/内部类</p>
</blockquote>
<ol>
<li>子类重写父类的方法</li>
<li>父类引用指向子类对象</li>
<li>接口匿名对象实现多态</li>
</ol>
<h4 id="14、ArrayList和vector"><a href="#14、ArrayList和vector" class="headerlink" title="14、ArrayList和vector"></a>14、ArrayList和vector</h4><ol>
<li>Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。 </li>
<li>当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。</li>
</ol>
<h4 id="15、数组比线性表速度更快：返回中间节点-选择随机节点-原地逆序"><a href="#15、数组比线性表速度更快：返回中间节点-选择随机节点-原地逆序" class="headerlink" title="15、数组比线性表速度更快：返回中间节点/选择随机节点/原地逆序"></a>15、数组比线性表速度更快：返回中间节点/选择随机节点/原地逆序</h4><ol>
<li>访问中间节点，数组可以通过array[length/2]访问，链表需要依次查找到中间节点。</li>
<li>数组是顺序存储的线性表，相对于链表而言主要的优点就是可以通过下标随机访问数组中的任意元素</li>
<li>数组可以头尾交换，相当于处理n/2个数据，而链表至少得完整遍历一遍</li>
</ol>
<h4 id="16、堆排序在最坏情况下的时间复杂度（O-nlogn-）"><a href="#16、堆排序在最坏情况下的时间复杂度（O-nlogn-）" class="headerlink" title="16、堆排序在最坏情况下的时间复杂度（O(nlogn)）"></a>16、堆排序在最坏情况下的时间复杂度（O(nlogn)）</h4><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
<h4 id="17、哈希冲突"><a href="#17、哈希冲突" class="headerlink" title="17、哈希冲突"></a>17、哈希冲突</h4><blockquote>
<p>线性表{15,38,31,20,28,14,37,50,22,25}，散列h(k)=k%11，采用平方探测再散列处理冲突</p>
</blockquote>
<h4 id="18、分支限界法"><a href="#18、分支限界法" class="headerlink" title="18、分支限界法"></a>18、分支限界法</h4><blockquote>
<p>0-1背包问题，容量为10，重量为{4,7,5,3}，价值为{40,42,25,12}，得到上下界为</p>
</blockquote>
<h4 id="19、递归"><a href="#19、递归" class="headerlink" title="19、递归"></a>19、递归</h4><blockquote>
<p>递归算法包括终止条件和迭代（递归）、递归过程转换为非递归过程用队列（栈）模拟</p>
</blockquote>
<h4 id="20、快速排序算法"><a href="#20、快速排序算法" class="headerlink" title="20、快速排序算法"></a>20、快速排序算法</h4><blockquote>
<p>哪种轴值选择效率最高（取第一个记录，中间记录和最后一个记录三者中值居中的作为轴值）</p>
</blockquote>
<h4 id="21、SCAN寻道"><a href="#21、SCAN寻道" class="headerlink" title="21、SCAN寻道"></a>21、SCAN寻道</h4><p>SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。</p>
<h4 id="22、平衡二叉树寻找"><a href="#22、平衡二叉树寻找" class="headerlink" title="22、平衡二叉树寻找"></a>22、平衡二叉树寻找</h4><h4 id="23、赫尔曼编码"><a href="#23、赫尔曼编码" class="headerlink" title="23、赫尔曼编码"></a>23、赫尔曼编码</h4><blockquote>
<p>根据使用频率为4个字符设计的赫尔曼编码可能是（00,01,10,11）</p>
</blockquote>
<p>步骤： </p>
<ol>
<li>将各种节点并排排列，最好按照权重从小到大； </li>
<li>找权重最小的两个节点，构成一个新二叉树；树根权重= 左子数权重+右子树权重； </li>
<li>重复上述步骤，知道只剩下最后一颗数为止； </li>
</ol>
<h4 id="24、平衡二叉树深度"><a href="#24、平衡二叉树深度" class="headerlink" title="24、平衡二叉树深度"></a>24、平衡二叉树深度</h4><p>对于一棵平衡树，如果以Nh表示深度为h时含有的最少结点数。有如下的规律： </p>
<ol>
<li>N0=0,N1=1,N2=2;</li>
<li>Nh=Nh−1+Nh−2+1</li>
</ol>
<h4 id="25、若串s-“facetime”，其子串个数为（37）"><a href="#25、若串s-“facetime”，其子串个数为（37）" class="headerlink" title="25、若串s=“facetime”，其子串个数为（37）"></a>25、若串s=“facetime”，其子串个数为（37）</h4><ol>
<li>字串： n（n+1）/2 + 1</li>
<li>非空子串：n（n+1）/2</li>
<li>非空真子串：n（n+1）/2 - 1</li>
</ol>
<h4 id="26、String方法"><a href="#26、String方法" class="headerlink" title="26、String方法"></a>26、String方法</h4><blockquote>
<p>设s=“abcaabcaaabc”，s1=“opq”，concat(substring(5,4,5),51)为（abcaopq）</p>
</blockquote>
<ol>
<li>concat（）方法首先获取拼接字符串的长度，判断这个字符串长度是否为0（判断这个用来拼接的字符串是不是空串），如果是就返回原来的字符串（等于没有拼接）；否则就获取源字符串的长度</li>
<li>substring()是根据索引截取字符串</li>
</ol>
<h4 id="27、MySQL存储过程优点"><a href="#27、MySQL存储过程优点" class="headerlink" title="27、MySQL存储过程优点"></a>27、MySQL存储过程优点</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol>
<li>存储过程允许标准组件式编程，提高了SQL语句的重用性、共享性和可移植性。</li>
<li>存储过程可以被作为一种安全机制来利用。</li>
<li>存储过程能够实现较快的执行速度，能够减少网络流量。</li>
</ol>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>存储过程的编写比单句SQL语句复杂。</li>
<li>在编写存储过程时，需要创建这些数据库对象的权限。</li>
</ol>
<h4 id="28、第一个体现结构化思想编程语言"><a href="#28、第一个体现结构化思想编程语言" class="headerlink" title="28、第一个体现结构化思想编程语言"></a>28、第一个体现结构化思想编程语言</h4><p>Pascal</p>
<h4 id="29、运行Test-class-java-Test-class"><a href="#29、运行Test-class-java-Test-class" class="headerlink" title="29、运行Test.class: java Test.class"></a>29、运行Test.class: java Test.class</h4><ol>
<li>编译程序：javac Hello.java 形成Hello.class</li>
<li>对生成的Hello.class在JVM上执行，输入java Hello</li>
</ol>
<h4 id="30、HTML5标签-略"><a href="#30、HTML5标签-略" class="headerlink" title="30、HTML5标签(略)"></a>30、HTML5标签(略)</h4><h4 id="31、IP协议属于（网络层协议）"><a href="#31、IP协议属于（网络层协议）" class="headerlink" title="31、IP协议属于（网络层协议）"></a>31、IP协议属于（网络层协议）</h4><h4 id="32、CSMA-CD协议特点：可抢占性-全双工"><a href="#32、CSMA-CD协议特点：可抢占性-全双工" class="headerlink" title="32、CSMA/CD协议特点：可抢占性/全双工"></a>32、CSMA/CD协议特点：可抢占性/全双工</h4><ol>
<li>CSMA/CD的基本原理是：每个节点都共享网络传输信道，在每个站要发送数据之前，都会检测信道是否空闲，如果空闲则发送，否则就等待；在发送出信息后，则对冲突进行检测，当发现冲突时，则取消发送。</li>
<li>全双工模式接收和发送数据分开，不会产生冲撞域</li>
</ol>
<h4 id="33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）"><a href="#33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）" class="headerlink" title="33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）"></a>33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）</h4><h4 id="34、sql用于将事务处理写到数据库"><a href="#34、sql用于将事务处理写到数据库" class="headerlink" title="34、sql用于将事务处理写到数据库"></a>34、sql用于将事务处理写到数据库</h4><h4 id="35、运算符优先顺序：赋值-lt-与-lt-关系-lt-算术"><a href="#35、运算符优先顺序：赋值-lt-与-lt-关系-lt-算术" class="headerlink" title="35、运算符优先顺序：赋值&lt;与&lt;关系&lt;算术"></a>35、运算符优先顺序：赋值&lt;与&lt;关系&lt;算术</h4><h4 id="36、二分查找"><a href="#36、二分查找" class="headerlink" title="36、二分查找"></a>36、二分查找</h4><blockquote>
<p>18有序元素、A[19]，第一个放A[1]，查找A[3]下标依次为（9,5,2,3）</p>
</blockquote>
<h4 id="37、正则表达式"><a href="#37、正则表达式" class="headerlink" title="37、正则表达式"></a>37、正则表达式</h4><blockquote>
<p>实现一个验证密码强度的正则表达式，要求最少6位，一大一小一数一符</p>
</blockquote>
<h4 id="38、指针"><a href="#38、指针" class="headerlink" title="38、指针"></a>38、指针</h4><p>Java语言不允许使用（指针）访问内存，更不允许（指针数组）访问内存</p>
<h4 id="39、XSS攻击-SQL注入攻击-CSRF攻击"><a href="#39、XSS攻击-SQL注入攻击-CSRF攻击" class="headerlink" title="39、XSS攻击/SQL注入攻击/CSRF攻击"></a>39、XSS攻击/SQL注入攻击/CSRF攻击</h4><ol>
<li>XSS全称cross-site scripting（跨站点脚本），是当前 web 应用中最危险和最普遍的漏洞之一。攻击者向网页中注入恶意脚本，当用户浏览网页时，脚本就会执行，进而影响用户，比如关不完的网站、盗取用户的 cookie 信息从而伪装成用户去操作，携带木马等等。<ol>
<li>反射型XSS（非持久性跨站攻击）</li>
<li>存储型XSS（持久性跨站攻击）</li>
<li>DOM Based XSS（基于 dom 的跨站点脚本攻击）</li>
</ol>
</li>
<li>SQL注入，顾名思义就是通过注入SQL命令来进行攻击，更确切地说攻击者把SQL命令插入到web表单或请求参数的查询字符串里面提交给服务器，从而让服务器执行执行的该SQL。</li>
<li>CSRF攻击，全程Cross Site Request Forgery（跨站请求伪造），攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，从而进行操作。</li>
</ol>
<h4 id="40、for和while的区别"><a href="#40、for和while的区别" class="headerlink" title="40、for和while的区别"></a>40、for和while的区别</h4><ol>
<li>如果一个需求明确循环的次数,那么使用for循环(开发中使用for循环的几率大于while循环)</li>
<li>如果一个需求,不知道循环了多少次,使用while循环</li>
</ol>
<h4 id="41、暗黑"><a href="#41、暗黑" class="headerlink" title="41、暗黑"></a>41、暗黑</h4><blockquote>
<p>把ABC归为一组，总有六种情况，遍历子串，count++，(n-z)-count，查找含ABC…若ABC/BAC..六种情况为纯洁。给出n个，求暗黑个数</p>
</blockquote>
<h4 id="42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）"><a href="#42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）" class="headerlink" title="42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）"></a>42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）</h4><p>通过调用门，在不同特权级别的代码段之间进行转移</p>
<h4 id="43、使用队列做辅助存储空间：广度优先搜索图"><a href="#43、使用队列做辅助存储空间：广度优先搜索图" class="headerlink" title="43、使用队列做辅助存储空间：广度优先搜索图"></a>43、使用队列做辅助存储空间：广度优先搜索图</h4><ol>
<li>深度优先搜索要借助栈</li>
<li>广度优先搜索要借助队列</li>
</ol>
<h4 id="44、属于mysql流程控制（case-when）"><a href="#44、属于mysql流程控制（case-when）" class="headerlink" title="44、属于mysql流程控制（case when）"></a>44、属于mysql流程控制（case when）</h4><ol>
<li>CASE 语句</li>
<li>IF 语句</li>
<li>IFNULL</li>
<li>NULLIF</li>
</ol>
<h4 id="45、Java-Set中对象特点"><a href="#45、Java-Set中对象特点" class="headerlink" title="45、Java Set中对象特点"></a>45、Java Set中对象特点</h4><p>特点：无序，不可重复</p>
<h4 id="46、原型模式的本质"><a href="#46、原型模式的本质" class="headerlink" title="46、原型模式的本质"></a>46、原型模式的本质</h4><p>本质:对象的拷贝</p>
<h4 id="47、折半查找条件"><a href="#47、折半查找条件" class="headerlink" title="47、折半查找条件"></a>47、折半查找条件</h4><ol>
<li>存储在数组中（例如一维数组）</li>
<li>数组元素为有序（例如升序）</li>
</ol>
<h4 id="48、DAG-DFS"><a href="#48、DAG-DFS" class="headerlink" title="48、DAG/DFS"></a>48、DAG/DFS</h4><ol>
<li>有向无环图DAG，指任意一条边有方向，且不存在环路的图。如果有一个非有向无环图，且A点出发向B经C可回到A，形成一个环。将从C到A的边方向改为从A到C，则变成有向无环图。有向无环图的生成树个数等于入度非零的节点的入度积。</li>
<li>深度优先遍历（DFS）；<ol>
<li>访问指定的起始顶点；</li>
<li>若当前访问的顶点的邻接顶点有未被访问的，则任选一个访问之；反之，退回到最近访问过的顶点；直到与起始顶点相通的全部顶点都访问完毕；</li>
<li>若此时图中尚有顶点未被访问，则再选其中一个顶点作为起始顶点并访问之，转 2； 反之，遍历结束。</li>
</ol>
</li>
</ol>
<h4 id="49、简述java-web-中getAttribute-和getParameter"><a href="#49、简述java-web-中getAttribute-和getParameter" class="headerlink" title="49、简述java web 中getAttribute()和getParameter()"></a>49、简述java web 中getAttribute()和getParameter()</h4><ol>
<li>根本上的差异，getAttribute得到的是对象，而getParameter得到的是字符串。</li>
<li>Parameter一般用于常规的http通信，如表单提交，url参数等，此时如果使用getAttribute则得不到任何结果</li>
<li>Attribute专门适用于java web容器内部各组件之间的交流，因为可以放下一整个对象，则可以传递更为丰富的信息，且getAttribute() 得到的数据对应的是得用setAttribute()来取出来。 </li>
</ol>
<h4 id="50、返回第一次匹配字符串位置"><a href="#50、返回第一次匹配字符串位置" class="headerlink" title="50、返回第一次匹配字符串位置"></a>50、返回第一次匹配字符串位置</h4><p>indexOf()方法可返某个指定的子字符串值在字符串中首次出现的位置</p>
<h4 id="51、100，随机10组，每组10个，数字1和数字2分到同一组概率"><a href="#51、100，随机10组，每组10个，数字1和数字2分到同一组概率" class="headerlink" title="51、100，随机10组，每组10个，数字1和数字2分到同一组概率"></a>51、100，随机10组，每组10个，数字1和数字2分到同一组概率</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#define R (abs(rand())%100)</span><br><span class="line">int group[100],i,j,k,p;</span><br><span class="line">int member[10][10],members[10];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    for(i=0;i&lt;100;i++)group[i]=i;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    for(j = R + 100;j--;)</span><br><span class="line">    &#123;</span><br><span class="line">        i=R;k=R;</span><br><span class="line">        p=group[i];</span><br><span class="line">        group[i] = group[k];</span><br><span class="line">        group[k] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;100;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        member[group[i]/10][members[group[i]/10]] = i;</span><br><span class="line">        members[group[i]/10]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;10;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;第 %02d 组 : &quot;,i+1);</span><br><span class="line">        for(j=0;j&lt;10;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%03d%c&quot;,member[i][j]+1,j==9?10:32);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="52、链表法解决冲突"><a href="#52、链表法解决冲突" class="headerlink" title="52、链表法解决冲突"></a>52、链表法解决冲突</h4><p>将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。</p>
<h4 id="53、TTL字段"><a href="#53、TTL字段" class="headerlink" title="53、TTL字段"></a>53、TTL字段</h4><p>TTL（生存时间值）：Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4包头的一个8 bit字段。</p>
<h5 id="54、输入正整数n，d，n为字符串，n的子串被d整除的个数"><a href="#54、输入正整数n，d，n为字符串，n的子串被d整除的个数" class="headerlink" title="54、输入正整数n，d，n为字符串，n的子串被d整除的个数"></a>54、输入正整数n，d，n为字符串，n的子串被d整除的个数</h5><h4 id="55、可被多个线程共享（data-section-file-fd）"><a href="#55、可被多个线程共享（data-section-file-fd）" class="headerlink" title="55、可被多个线程共享（data section/file fd）"></a>55、可被多个线程共享（data section/file fd）</h4><h5 id="线程共享的内容"><a href="#线程共享的内容" class="headerlink" title="线程共享的内容"></a>线程共享的内容</h5><ol>
<li>进程代码段</li>
<li>进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、</li>
<li>进程打开的文件描述符、</li>
<li>信号的处理器、</li>
<li>进程的当前目录和</li>
<li>进程用户ID与进程组ID   </li>
</ol>
<h5 id="线程独有的内容包括"><a href="#线程独有的内容包括" class="headerlink" title="线程独有的内容包括"></a>线程独有的内容包括</h5><ol>
<li>线程ID</li>
<li>寄存器组的值</li>
<li>线程的堆栈</li>
<li>错误返回码</li>
<li>线程的信号屏蔽码</li>
</ol>
<h4 id="56、小顶堆的中序遍历"><a href="#56、小顶堆的中序遍历" class="headerlink" title="56、小顶堆的中序遍历"></a>56、小顶堆的中序遍历</h4><h4 id="57、稳定的排序算法"><a href="#57、稳定的排序算法" class="headerlink" title="57、稳定的排序算法"></a>57、稳定的排序算法</h4><ol>
<li>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法</li>
<li>冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法</li>
</ol>
<h4 id="58、结构型设计模式"><a href="#58、结构型设计模式" class="headerlink" title="58、结构型设计模式"></a>58、结构型设计模式</h4><h5 id="结构型模式共七种："><a href="#结构型模式共七种：" class="headerlink" title="结构型模式共七种："></a>结构型模式共七种：</h5><ol>
<li>适配器模式（Adapter）　　　　　　　　</li>
<li>外观模式（Facade）</li>
<li>桥接模式（Bridge）</li>
<li>装饰器模式（Decorator）</li>
<li>代理模式（Proxy）</li>
<li>享元模式（Flyweight）</li>
<li>组合模式（Composite）</li>
</ol>
<h5 id="其中又分为"><a href="#其中又分为" class="headerlink" title="其中又分为"></a>其中又分为</h5><ol>
<li>接口适配：适配器、外观、桥接模式</li>
<li>行为扩展：装饰</li>
<li>性能与对象访问：代理、享元模式</li>
<li>抽象集合：组合模式</li>
</ol>
<h4 id="59、ICMP协议功能"><a href="#59、ICMP协议功能" class="headerlink" title="59、ICMP协议功能"></a>59、ICMP协议功能</h4><p>Internet Control Message Protocol </p>
<ol>
<li>侦测远端主机是否存在</li>
<li>建立及维护路由资料</li>
<li>重导数据传送路径</li>
<li>数据流量控制</li>
</ol>
<h4 id="60、不引起进程阻塞"><a href="#60、不引起进程阻塞" class="headerlink" title="60、不引起进程阻塞"></a>60、不引起进程阻塞</h4><p>进程阻塞的原因</p>
<ol>
<li>等待I/O</li>
<li>进程sleep</li>
<li>等待解锁</li>
</ol>
<h4 id="61、稳定且平均时间复杂度最优算法-归并排序"><a href="#61、稳定且平均时间复杂度最优算法-归并排序" class="headerlink" title="61、稳定且平均时间复杂度最优算法(归并排序)"></a>61、稳定且平均时间复杂度最优算法(归并排序)</h4><h4 id="62、二分查找（顺序）"><a href="#62、二分查找（顺序）" class="headerlink" title="62、二分查找（顺序）"></a>62、二分查找（顺序）</h4><h4 id="63、地址传递"><a href="#63、地址传递" class="headerlink" title="63、地址传递"></a>63、地址传递</h4><ol>
<li>值传递：传递的只是一份副本。<ol>
<li>特点：调用者可以保护自己空间值不被修改。【保护】</li>
<li>缺点：因为每次调用都会传递一份副本，因此内存消耗很大，工程中不建议使用。</li>
</ol>
</li>
<li>地址传递：传递的门牌号<ol>
<li>特点：调用者让被调者修改自己的空间值。【修改】</li>
<li>用处：<ol>
<li>调用者让被调者修改自己的空间值</li>
<li>连续空间的传递</li>
</ol>
</li>
<li>优点：不用拷贝副本，可以节约空间。</li>
</ol>
</li>
</ol>
<h4 id="64、Linux改变文件所有者命令：chown"><a href="#64、Linux改变文件所有者命令：chown" class="headerlink" title="64、Linux改变文件所有者命令：chown"></a>64、Linux改变文件所有者命令：chown</h4><h4 id="65、byte-b-0x175"><a href="#65、byte-b-0x175" class="headerlink" title="65、byte b=0x175"></a>65、byte b=0x175</h4><p>十六进制数不能赋给byte类型的数据，数据有误</p>
<h4 id="66、逻辑短路运算符"><a href="#66、逻辑短路运算符" class="headerlink" title="66、逻辑短路运算符"></a>66、逻辑短路运算符</h4><p>在Java中短路运算符指的是”&amp;&amp;”(与) 和”||”(或) ,非短路运算符指的是”&amp;” 和”|”.</p>
<ol>
<li>如果 “&amp;&amp;” 运算符的第一个表达式为false,则第二个表达式就不会执行</li>
<li>如果 “||” 运算符的第一个表达式为true,则第二个表达式就不会执行</li>
</ol>
<h4 id="67、Map的value可以是list或Map（true）"><a href="#67、Map的value可以是list或Map（true）" class="headerlink" title="67、Map的value可以是list或Map（true）"></a>67、Map的value可以是list或Map（true）</h4><h4 id="68、js变量默认值：undefined"><a href="#68、js变量默认值：undefined" class="headerlink" title="68、js变量默认值：undefined"></a>68、js变量默认值：undefined</h4><ol>
<li>undefined：是所有没有赋值变量的默认值，自动赋值</li>
<li>null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址</li>
</ol>
<h4 id="69、jdk核心源码：src目录（true）"><a href="#69、jdk核心源码：src目录（true）" class="headerlink" title="69、jdk核心源码：src目录（true）"></a>69、jdk核心源码：src目录（true）</h4><h4 id="70、分支覆盖测试用例"><a href="#70、分支覆盖测试用例" class="headerlink" title="70、分支覆盖测试用例"></a>70、分支覆盖测试用例</h4><p>判定覆盖也被成为分支覆盖(Branch Coverage)，也就是说设计的测试用例要保证让被测试程序中的每一个分支都至少执行一次</p>
<h4 id="71、冒烟测试"><a href="#71、冒烟测试" class="headerlink" title="71、冒烟测试"></a>71、冒烟测试</h4><p>冒烟测试的对象是每一个新编译的需要正式测试的软件版本，目的是确认软件基本功能正常，可以进行后续的正式测试工作</p>
<h4 id="72、HTTP服务器端错误"><a href="#72、HTTP服务器端错误" class="headerlink" title="72、HTTP服务器端错误"></a>72、HTTP服务器端错误</h4><ol>
<li>400 非法请求(Bad Request)：如果请求的语法不对，服务器将无法理解。客户端在对该请求做出更改之前，不应再次向服务器重复发送该请求。</li>
<li>401 未授权(Unauthorized)：请求需要用户授权。客户端应使用合适的授权标题域来重复该请求。如果请求中已经包括了授权信任信息，那回应的401表示此授权被拒绝。如果用户代理在多次尝试之后，回应一样还是返回401状态代码，用户应当察看一下回应的实体，因为在实体中会包括一些相关的动态信息。</li>
<li>403 禁止(Forbidden)：服务器理解请求，但是拒绝实现该请求。授权对此没有帮助，客户端应当停止重复发送此请求。如果不是用HEAD请求方法，而且服务器端愿意公布请求未被实现原因的前提下，服务器会将拒绝原因写在回应实体中。该状态码一般用于服务器端不想公布请求被拒绝的细节或没有其它的回应可用。</li>
<li>404 没有找到(Not Found)：服务器没有找到与请求URI相符的资源。404状态码并不指明状况是临时性的还是永久性的。如果服务器不希望为客户端提供这方面的信息，还回应403(禁止)状态码。</li>
<li>服务器错误(Server Error )5xx：回应代码以‘5’开头的状态码表示服务器端发现自己出现错误，不能继续执行请求。如果客户端在收到5xx状态码时，请求尚未完成，它应当立即停止向服务器发送数据。除了回应HEAD请求外，服务器应当在其回应实体中包括对错误情况的解释、并指明是临时性的还是永久性的。</li>
</ol>
<h4 id="73、Linux强制删除非空目录"><a href="#73、Linux强制删除非空目录" class="headerlink" title="73、Linux强制删除非空目录"></a>73、Linux强制删除非空目录</h4><p>rm -rf 目录名字</p>
<ol>
<li>-r 向下递归，不管有多少级目录，一并删除</li>
<li>-f 直接强行删除，不作任何提示的意思</li>
</ol>
<p>1、删除/var/log/httpd/access目录以及其下所有文件、文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/log/httpd/access</span><br></pre></td></tr></table></figure>
<p>2、强制删除/var/log/httpd/access.log这个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /var/log/httpd/access.log</span><br></pre></td></tr></table></figure>
<h4 id="74、TCP拥塞控制方法"><a href="#74、TCP拥塞控制方法" class="headerlink" title="74、TCP拥塞控制方法"></a>74、TCP拥塞控制方法</h4><ol>
<li>慢开始( slow-start )</li>
<li>拥塞避免( congestion avoidance )</li>
<li>快重传( fast retransmit )</li>
<li>快恢复( fast recovery )</li>
</ol>
<h4 id="75、二分查找and二叉排序树（对于有序序列，非递归时度-lt-递归）"><a href="#75、二分查找and二叉排序树（对于有序序列，非递归时度-lt-递归）" class="headerlink" title="75、二分查找and二叉排序树（对于有序序列，非递归时度&lt;递归）"></a>75、二分查找and二叉排序树（对于有序序列，非递归时度&lt;递归）</h4><h4 id="76、sleep-wait"><a href="#76、sleep-wait" class="headerlink" title="76、sleep()/wait()"></a>76、sleep()/wait()</h4><ol>
<li>由于sleep()方法是Thread类的方法，因此它不能改变对象的机锁。所以当在一个Synchronized方法中调用sleep（）时，线程虽然休眠了，但是对象的机锁没有被释放，其他线程仍然无法访问这个对象。而wait()方法则会在线程休眠的同时释放掉机锁，其他线程可以访问该对象。 </li>
<li>Thread.sleep(long)可以不在synchronized的块下调用，而且使用Thread.sleep()不会丢失当前线程对任何对象的同步锁(monitor);</li>
<li>object.wait(long)必须在synchronized的块下来使用，调用了之后失去对object的monitor, 这样做的好处是它不影响其它的线程对object进行操作。utm_source=copy</li>
</ol>
<h4 id="77、防止死锁发生"><a href="#77、防止死锁发生" class="headerlink" title="77、防止死锁发生"></a>77、防止死锁发生</h4><ol>
<li>破坏互斥条件</li>
<li>破坏请求并保持条件</li>
<li>破坏不可剥夺条件</li>
<li>破坏循环等待条件</li>
</ol>
<h4 id="78、Python类、操作、属性（-add）"><a href="#78、Python类、操作、属性（-add）" class="headerlink" title="78、Python类、操作、属性（_add）"></a>78、Python类、操作、属性（_add）</h4><p>如果用dir(list)查看list的属性，能看到一个属性是<strong>add</strong>()</p>
<h4 id="79、shell脚本输出"><a href="#79、shell脚本输出" class="headerlink" title="79、shell脚本输出"></a>79、shell脚本输出</h4><ol>
<li>$echo hello world</li>
<li>$echo ‘hello world’</li>
<li>$echo “hello world”</li>
</ol>
<h4 id="80、不能用来修饰interface"><a href="#80、不能用来修饰interface" class="headerlink" title="80、不能用来修饰interface"></a>80、不能用来修饰interface</h4><p>接口可以使用public和默认的进行修饰</p>
<h4 id="81、分时操作系统，进程调度采用“时间片轮转”-true"><a href="#81、分时操作系统，进程调度采用“时间片轮转”-true" class="headerlink" title="81、分时操作系统，进程调度采用“时间片轮转”(true)"></a>81、分时操作系统，进程调度采用“时间片轮转”(true)</h4><h4 id="82、ROM中存放的信息在计算机断电后内容（不会丢失）"><a href="#82、ROM中存放的信息在计算机断电后内容（不会丢失）" class="headerlink" title="82、ROM中存放的信息在计算机断电后内容（不会丢失）"></a>82、ROM中存放的信息在计算机断电后内容（不会丢失）</h4><ol>
<li>rom是只读储存器，不可以写入，也不会丢失</li>
<li>ram是电记忆的读写储存器，掉电后数据丢失</li>
</ol>
<h4 id="83、in-interval-0-11"><a href="#83、in-interval-0-11" class="headerlink" title="83、in interval(0,11)"></a>83、in interval(0,11)</h4><h4 id="84、处理外部中断时，应该由操作系统保存（程序计数器PC）"><a href="#84、处理外部中断时，应该由操作系统保存（程序计数器PC）" class="headerlink" title="84、处理外部中断时，应该由操作系统保存（程序计数器PC）"></a>84、处理外部中断时，应该由操作系统保存（程序计数器PC）</h4><p><strong>外部中断处理过程首先要保护现场，使得中断处理完之后能够恢复程序的执行状态继续执行。</strong><br>保护现场有两个含义</p>
<ol>
<li>由中断隐指令保存程序的断点（程序计数器）</li>
<li>由中断服务程序保存通用寄存器和状态寄存器的内容，中断服务程序是操作系统的一部分。</li>
</ol>
<h4 id="85、在jsp可以操作cookie-jsp在浏览器的执行是单线程的"><a href="#85、在jsp可以操作cookie-jsp在浏览器的执行是单线程的" class="headerlink" title="85、在jsp可以操作cookie/jsp在浏览器的执行是单线程的"></a>85、在jsp可以操作cookie/jsp在浏览器的执行是单线程的</h4><h4 id="86、微型计算机的cache是（高速缓冲存储器）"><a href="#86、微型计算机的cache是（高速缓冲存储器）" class="headerlink" title="86、微型计算机的cache是（高速缓冲存储器）"></a>86、微型计算机的cache是（高速缓冲存储器）</h4><h4 id="87、最速下降法"><a href="#87、最速下降法" class="headerlink" title="87、最速下降法"></a>87、最速下降法</h4><blockquote>
<p>给定初始点x0=(1,1),用最速下降法求函数f(x)=4x1+6x2-2x1^2-2x1x2-2x2^2的极大值，则迭代一次后x1的值（-1、1/2、-1/2、2，1）？</p>
</blockquote>
<h4 id="88、发货功能测试用例"><a href="#88、发货功能测试用例" class="headerlink" title="88、发货功能测试用例"></a>88、发货功能测试用例</h4><h4 id="89、双向链表定义"><a href="#89、双向链表定义" class="headerlink" title="89、双向链表定义"></a>89、双向链表定义</h4><p>双向链表，每个数据结点中都有两个结点，分别指向其直接前驱和直接后继。所以我们从双向链表的任意一个结点开始都可以很方便的访问其前驱元素和后继元素。</p>
<h4 id="90、词法分析阶段错误"><a href="#90、词法分析阶段错误" class="headerlink" title="90、词法分析阶段错误"></a>90、词法分析阶段错误</h4><p>词法分析，将字符序列转换为单词（Token）序列的过程</p>
<h4 id="91、序列安全（银行家算法）"><a href="#91、序列安全（银行家算法）" class="headerlink" title="91、序列安全（银行家算法）"></a>91、序列安全（银行家算法）</h4><h4 id="92、？？"><a href="#92、？？" class="headerlink" title="92、？？"></a>92、？？</h4><blockquote>
<p>p=q=r=(char<em>)malloc(sizeof(char)</em>20);<br>strcpy(p,”attaboy,welcome!”,p[11],q[3],r[4])<br>cta/lta/lab/cab</p>
</blockquote>
<h4 id="93、变量在内存中的存储位置"><a href="#93、变量在内存中的存储位置" class="headerlink" title="93、变量在内存中的存储位置"></a>93、变量在内存中的存储位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int a=0;</span><br><span class="line">class someClass&#123;</span><br><span class="line">    int b;</span><br><span class="line">    static int c;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int d=0;</span><br><span class="line">    someClass *p=new someClass();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java中变量的存储位置</p>
<ol>
<li>寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制. </li>
<li>栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。） </li>
<li>堆：存放所有new出来的对象。 </li>
<li>静态域：存放静态成员（static定义的） </li>
<li>常量池：存放字符串常量和基本类型常量（public static final）。 </li>
<li>非RAM存储：硬盘等永久存储空间 </li>
</ol>
<h4 id="94、进程通信-进程同步"><a href="#94、进程通信-进程同步" class="headerlink" title="94、进程通信/进程同步"></a>94、进程通信/进程同步</h4><h5 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h5><ol>
<li>信号</li>
<li>管道</li>
<li>消息队列</li>
<li>共享内存</li>
</ol>
<h5 id="进程同步的四种方法"><a href="#进程同步的四种方法" class="headerlink" title="进程同步的四种方法"></a>进程同步的四种方法</h5><ol>
<li>临界区（Critical Section）:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 </li>
<li>互斥量（Mutex）:为协调共同对一个共享资源的单独访问而设计的。</li>
<li>信号量（Semaphore）:为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</li>
<li>事件（Event）: 用来通知线程有一些事件已发生，从而启动后继任务的开始。</li>
</ol>
<h4 id="95、网络服务接口，Linux"><a href="#95、网络服务接口，Linux" class="headerlink" title="95、网络服务接口，Linux"></a>95、网络服务接口，Linux</h4><ol>
<li>$/sbin/ifconfig 查看所有活动网络接口信息，其中包括一个lo环回端口。</li>
<li>$/sbin/ifconfig &lt;网络接口名称&gt; 查看指定接口信息。</li>
<li>$/sbin/ifconfig –a 查看所有接口信息，包括非活动状态接口。</li>
<li>#/route：显示当前linux主机中的路由表信息。</li>
<li>$ping 目的主机地址：使用ping命令测试与其它主机的网络链接。ctrl+C终止。</li>
<li>$traceroute &lt;目的主机地址&gt;：traceroute命令显示当前主机与目的主机之间经过的所，有网络节点的地址，以及当前主机到每个中间结点的连接状态。</li>
<li>$Hostname 查看当前的主机名。</li>
<li>$Nslookup：使用dns服务器查询域名</li>
<li>$Dhclient 使用dhclient命令可以从DHCP服务器中申请新的网络配置应用到当前主机。</li>
<li>Ip地址配置命令：Ifconfig &lt;网络接口名称&gt; network &lt;子网掩码&gt;</li>
<li>$Route del default gw &lt;默认网关地址&gt;删除默认网关路由</li>
<li>$Route add default gw &lt;默认网关地址&gt;：添加默认网关路由</li>
<li>#hostname 123：主机名称配置命令</li>
<li>#/etc/rc.d/init.d/network start 启动network</li>
<li>#/etc/rc.d/init.d/network stop 停止network</li>
<li>#/etc/rc.d/init.d/network restart 重启network</li>
<li>/etc/sysconfig/network-scripts/ifconfg-*：网络接口配置文件</li>
<li>#ifconfig eth0 down 停止eth0接口</li>
<li>#ifconfig eth0 up 开启eth0接口</li>
</ol>
<h4 id="96、匹配输出log文件中第5行的数字并由小到大排序"><a href="#96、匹配输出log文件中第5行的数字并由小到大排序" class="headerlink" title="96、匹配输出log文件中第5行的数字并由小到大排序"></a>96、匹配输出log文件中第5行的数字并由小到大排序</h4><p>linux 如何显示一个文件的某几行(中间几行)</p>
<ol>
<li>从第3000行开始，显示1000行。即显示3000~3999行<br>cat filename | tail -n +3000 | head -n 1000</li>
<li>显示1000行到3000行<br>cat filename| head -n 3000 | tail -n +1000<ol>
<li>tail -n 1000：显示最后1000行</li>
<li>tail -n +1000：从1000行开始显示，显示1000行以后的</li>
<li>head -n 1000：显示前面1000行</li>
</ol>
</li>
<li>用sed命令<br>sed -n ‘5,10p’ filename ，查看文件的第5行到第10行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123; </span><br><span class="line">    ListNode EntryNodeOfLoop(ListNode h)&#123;</span><br><span class="line">        if(h == null || h.next == null) </span><br><span class="line">            return null; </span><br><span class="line">            ListNode slow = h;</span><br><span class="line">            ListNode fast = h;</span><br><span class="line">            while(fast != null &amp;&amp; fast.next != null )&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            if(slow == fast)&#123;</span><br><span class="line">            ListNode p=h;</span><br><span class="line">            ListNode q=slow;//相当于让q指向了m1 while(p != q)&#123; </span><br><span class="line">            p = p.next; q = q.next;</span><br><span class="line">            &#125; </span><br><span class="line">        if(p == q) return q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="10、关键字-1"><a href="#10、关键字-1" class="headerlink" title="10、关键字"></a>10、关键字</h4><blockquote>
<p>finial修饰局部变量，transient方法？private顶层类？volatile构造类？</p>
</blockquote>
<ol>
<li>static  静态修饰关键字，可以修饰 变量，程序块，类的方法；</li>
<li>final 只能赋值一次；修饰变量、方法及类</li>
<li>transient 类型修饰符，只能用来修饰字段</li>
<li>volatile变量修饰符，只能用来修饰变量。</li>
</ol>
<h4 id="11、代理类-1"><a href="#11、代理类-1" class="headerlink" title="11、代理类"></a>11、代理类</h4><blockquote>
<p>（动态代理类与静态代理类必须由开发人员编写源代码并编译成.class文件）<br>（Proxy类提供了创建动态代理类方法）<br>（代理类与被代理类有相同的接口）</p>
</blockquote>
<ol>
<li>代理类，是类的代理，将类给代理，不直接调用类的方法，而通过代理来调用。</li>
<li>Proxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。</li>
<li>构造方法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Proxy() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Proxy(InvocationHandler h) &#123;</span><br><span class="line">    this.h = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、IO-1"><a href="#12、IO-1" class="headerlink" title="12、IO"></a>12、IO</h4><blockquote>
<p>reader字符？inputstream字节？objectinputstream不支持序列化对象/reader支持序列</p>
</blockquote>
<ol>
<li>ObjectInputStream 类和 ObjectInputStream 类不支持序列化的对象</li>
<li>用Reader 和Writer可以把对象用字符的形式序列化</li>
</ol>
<h4 id="13、多态-1"><a href="#13、多态-1" class="headerlink" title="13、多态"></a>13、多态</h4><blockquote>
<p>体现面向对象多态基本特征：方法重载/方法重写/匿名类/内部类</p>
</blockquote>
<ol>
<li>子类重写父类的方法</li>
<li>父类引用指向子类对象</li>
<li>接口匿名对象实现多态</li>
</ol>
<h4 id="14、ArrayList和vector-1"><a href="#14、ArrayList和vector-1" class="headerlink" title="14、ArrayList和vector"></a>14、ArrayList和vector</h4><ol>
<li>Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。 </li>
<li>当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。</li>
</ol>
<h4 id="15、数组比线性表速度更快：返回中间节点-选择随机节点-原地逆序-1"><a href="#15、数组比线性表速度更快：返回中间节点-选择随机节点-原地逆序-1" class="headerlink" title="15、数组比线性表速度更快：返回中间节点/选择随机节点/原地逆序"></a>15、数组比线性表速度更快：返回中间节点/选择随机节点/原地逆序</h4><ol>
<li>访问中间节点，数组可以通过array[length/2]访问，链表需要依次查找到中间节点。</li>
<li>数组是顺序存储的线性表，相对于链表而言主要的优点就是可以通过下标随机访问数组中的任意元素</li>
<li>数组可以头尾交换，相当于处理n/2个数据，而链表至少得完整遍历一遍</li>
</ol>
<h4 id="16、堆排序在最坏情况下的时间复杂度（O-nlogn-）-1"><a href="#16、堆排序在最坏情况下的时间复杂度（O-nlogn-）-1" class="headerlink" title="16、堆排序在最坏情况下的时间复杂度（O(nlogn)）"></a>16、堆排序在最坏情况下的时间复杂度（O(nlogn)）</h4><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
<h4 id="17、哈希冲突-1"><a href="#17、哈希冲突-1" class="headerlink" title="17、哈希冲突"></a>17、哈希冲突</h4><blockquote>
<p>线性表{15,38,31,20,28,14,37,50,22,25}，散列h(k)=k%11，采用平方探测再散列处理冲突</p>
</blockquote>
<h4 id="18、分支限界法-1"><a href="#18、分支限界法-1" class="headerlink" title="18、分支限界法"></a>18、分支限界法</h4><blockquote>
<p>0-1背包问题，容量为10，重量为{4,7,5,3}，价值为{40,42,25,12}，得到上下界为</p>
</blockquote>
<h4 id="19、递归-1"><a href="#19、递归-1" class="headerlink" title="19、递归"></a>19、递归</h4><blockquote>
<p>递归算法包括终止条件和迭代（递归）、递归过程转换为非递归过程用队列（栈）模拟</p>
</blockquote>
<h4 id="20、快速排序算法-1"><a href="#20、快速排序算法-1" class="headerlink" title="20、快速排序算法"></a>20、快速排序算法</h4><blockquote>
<p>哪种轴值选择效率最高（取第一个记录，中间记录和最后一个记录三者中值居中的作为轴值）</p>
</blockquote>
<h4 id="21、SCAN寻道-1"><a href="#21、SCAN寻道-1" class="headerlink" title="21、SCAN寻道"></a>21、SCAN寻道</h4><p>SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。</p>
<h4 id="22、平衡二叉树寻找-1"><a href="#22、平衡二叉树寻找-1" class="headerlink" title="22、平衡二叉树寻找"></a>22、平衡二叉树寻找</h4><h4 id="23、赫尔曼编码-1"><a href="#23、赫尔曼编码-1" class="headerlink" title="23、赫尔曼编码"></a>23、赫尔曼编码</h4><blockquote>
<p>根据使用频率为4个字符设计的赫尔曼编码可能是（00,01,10,11）</p>
</blockquote>
<p>步骤： </p>
<ol>
<li>将各种节点并排排列，最好按照权重从小到大； </li>
<li>找权重最小的两个节点，构成一个新二叉树；树根权重= 左子数权重+右子树权重； </li>
<li>重复上述步骤，知道只剩下最后一颗数为止； </li>
</ol>
<h4 id="24、平衡二叉树深度-1"><a href="#24、平衡二叉树深度-1" class="headerlink" title="24、平衡二叉树深度"></a>24、平衡二叉树深度</h4><p>对于一棵平衡树，如果以Nh表示深度为h时含有的最少结点数。有如下的规律： </p>
<ol>
<li>N0=0,N1=1,N2=2;</li>
<li>Nh=Nh−1+Nh−2+1</li>
</ol>
<h4 id="25、若串s-“facetime”，其子串个数为（37）-1"><a href="#25、若串s-“facetime”，其子串个数为（37）-1" class="headerlink" title="25、若串s=“facetime”，其子串个数为（37）"></a>25、若串s=“facetime”，其子串个数为（37）</h4><ol>
<li>字串： n（n+1）/2 + 1</li>
<li>非空子串：n（n+1）/2</li>
<li>非空真子串：n（n+1）/2 - 1</li>
</ol>
<h4 id="26、String方法-1"><a href="#26、String方法-1" class="headerlink" title="26、String方法"></a>26、String方法</h4><blockquote>
<p>设s=“abcaabcaaabc”，s1=“opq”，concat(substring(5,4,5),51)为（abcaopq）</p>
</blockquote>
<ol>
<li>concat（）方法首先获取拼接字符串的长度，判断这个字符串长度是否为0（判断这个用来拼接的字符串是不是空串），如果是就返回原来的字符串（等于没有拼接）；否则就获取源字符串的长度</li>
<li>substring()是根据索引截取字符串</li>
</ol>
<h4 id="27、MySQL存储过程优点-1"><a href="#27、MySQL存储过程优点-1" class="headerlink" title="27、MySQL存储过程优点"></a>27、MySQL存储过程优点</h4><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ol>
<li>存储过程允许标准组件式编程，提高了SQL语句的重用性、共享性和可移植性。</li>
<li>存储过程可以被作为一种安全机制来利用。</li>
<li>存储过程能够实现较快的执行速度，能够减少网络流量。</li>
</ol>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>存储过程的编写比单句SQL语句复杂。</li>
<li>在编写存储过程时，需要创建这些数据库对象的权限。</li>
</ol>
<h4 id="28、第一个体现结构化思想编程语言-1"><a href="#28、第一个体现结构化思想编程语言-1" class="headerlink" title="28、第一个体现结构化思想编程语言"></a>28、第一个体现结构化思想编程语言</h4><p>Pascal</p>
<h4 id="29、运行Test-class-java-Test-class-1"><a href="#29、运行Test-class-java-Test-class-1" class="headerlink" title="29、运行Test.class: java Test.class"></a>29、运行Test.class: java Test.class</h4><ol>
<li>编译程序：javac Hello.java 形成Hello.class</li>
<li>对生成的Hello.class在JVM上执行，输入java Hello</li>
</ol>
<h4 id="30、HTML5标签-略-1"><a href="#30、HTML5标签-略-1" class="headerlink" title="30、HTML5标签(略)"></a>30、HTML5标签(略)</h4><h4 id="31、IP协议属于（网络层协议）-1"><a href="#31、IP协议属于（网络层协议）-1" class="headerlink" title="31、IP协议属于（网络层协议）"></a>31、IP协议属于（网络层协议）</h4><h4 id="32、CSMA-CD协议特点：可抢占性-全双工-1"><a href="#32、CSMA-CD协议特点：可抢占性-全双工-1" class="headerlink" title="32、CSMA/CD协议特点：可抢占性/全双工"></a>32、CSMA/CD协议特点：可抢占性/全双工</h4><ol>
<li>CSMA/CD的基本原理是：每个节点都共享网络传输信道，在每个站要发送数据之前，都会检测信道是否空闲，如果空闲则发送，否则就等待；在发送出信息后，则对冲突进行检测，当发现冲突时，则取消发送。</li>
<li>全双工模式接收和发送数据分开，不会产生冲撞域</li>
</ol>
<h4 id="33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）-1"><a href="#33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）-1" class="headerlink" title="33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）"></a>33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）</h4><h4 id="34、sql用于将事务处理写到数据库-1"><a href="#34、sql用于将事务处理写到数据库-1" class="headerlink" title="34、sql用于将事务处理写到数据库"></a>34、sql用于将事务处理写到数据库</h4><h4 id="35、运算符优先顺序：赋值-lt-与-lt-关系-lt-算术-1"><a href="#35、运算符优先顺序：赋值-lt-与-lt-关系-lt-算术-1" class="headerlink" title="35、运算符优先顺序：赋值&lt;与&lt;关系&lt;算术"></a>35、运算符优先顺序：赋值&lt;与&lt;关系&lt;算术</h4><h4 id="36、二分查找-1"><a href="#36、二分查找-1" class="headerlink" title="36、二分查找"></a>36、二分查找</h4><blockquote>
<p>18有序元素、A[19]，第一个放A[1]，查找A[3]下标依次为（9,5,2,3）</p>
</blockquote>
<h4 id="37、正则表达式-1"><a href="#37、正则表达式-1" class="headerlink" title="37、正则表达式"></a>37、正则表达式</h4><blockquote>
<p>实现一个验证密码强度的正则表达式，要求最少6位，一大一小一数一符</p>
</blockquote>
<h4 id="38、指针-1"><a href="#38、指针-1" class="headerlink" title="38、指针"></a>38、指针</h4><p>Java语言不允许使用（指针）访问内存，更不允许（指针数组）访问内存</p>
<h4 id="39、XSS攻击-SQL注入攻击-CSRF攻击-1"><a href="#39、XSS攻击-SQL注入攻击-CSRF攻击-1" class="headerlink" title="39、XSS攻击/SQL注入攻击/CSRF攻击"></a>39、XSS攻击/SQL注入攻击/CSRF攻击</h4><ol>
<li>XSS全称cross-site scripting（跨站点脚本），是当前 web 应用中最危险和最普遍的漏洞之一。攻击者向网页中注入恶意脚本，当用户浏览网页时，脚本就会执行，进而影响用户，比如关不完的网站、盗取用户的 cookie 信息从而伪装成用户去操作，携带木马等等。<ol>
<li>反射型XSS（非持久性跨站攻击）</li>
<li>存储型XSS（持久性跨站攻击）</li>
<li>DOM Based XSS（基于 dom 的跨站点脚本攻击）</li>
</ol>
</li>
<li>SQL注入，顾名思义就是通过注入SQL命令来进行攻击，更确切地说攻击者把SQL命令插入到web表单或请求参数的查询字符串里面提交给服务器，从而让服务器执行执行的该SQL。</li>
<li>CSRF攻击，全程Cross Site Request Forgery（跨站请求伪造），攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，从而进行操作。</li>
</ol>
<h4 id="40、for和while的区别-1"><a href="#40、for和while的区别-1" class="headerlink" title="40、for和while的区别"></a>40、for和while的区别</h4><ol>
<li>如果一个需求明确循环的次数,那么使用for循环(开发中使用for循环的几率大于while循环)</li>
<li>如果一个需求,不知道循环了多少次,使用while循环</li>
</ol>
<h4 id="41、暗黑-1"><a href="#41、暗黑-1" class="headerlink" title="41、暗黑"></a>41、暗黑</h4><blockquote>
<p>把ABC归为一组，总有六种情况，遍历子串，count++，(n-z)-count，查找含ABC…若ABC/BAC..六种情况为纯洁。给出n个，求暗黑个数</p>
</blockquote>
<h4 id="42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）-1"><a href="#42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）-1" class="headerlink" title="42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）"></a>42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）</h4><p>通过调用门，在不同特权级别的代码段之间进行转移</p>
<h4 id="43、使用队列做辅助存储空间：广度优先搜索图-1"><a href="#43、使用队列做辅助存储空间：广度优先搜索图-1" class="headerlink" title="43、使用队列做辅助存储空间：广度优先搜索图"></a>43、使用队列做辅助存储空间：广度优先搜索图</h4><ol>
<li>深度优先搜索要借助栈</li>
<li>广度优先搜索要借助队列</li>
</ol>
<h4 id="44、属于mysql流程控制（case-when）-1"><a href="#44、属于mysql流程控制（case-when）-1" class="headerlink" title="44、属于mysql流程控制（case when）"></a>44、属于mysql流程控制（case when）</h4><ol>
<li>CASE 语句</li>
<li>IF 语句</li>
<li>IFNULL</li>
<li>NULLIF</li>
</ol>
<h4 id="45、Java-Set中对象特点-1"><a href="#45、Java-Set中对象特点-1" class="headerlink" title="45、Java Set中对象特点"></a>45、Java Set中对象特点</h4><p>特点：无序，不可重复</p>
<h4 id="46、原型模式的本质-1"><a href="#46、原型模式的本质-1" class="headerlink" title="46、原型模式的本质"></a>46、原型模式的本质</h4><p>本质:对象的拷贝</p>
<h4 id="47、折半查找条件-1"><a href="#47、折半查找条件-1" class="headerlink" title="47、折半查找条件"></a>47、折半查找条件</h4><ol>
<li>存储在数组中（例如一维数组）</li>
<li>数组元素为有序（例如升序）</li>
</ol>
<h4 id="48、DAG-DFS-1"><a href="#48、DAG-DFS-1" class="headerlink" title="48、DAG/DFS"></a>48、DAG/DFS</h4><ol>
<li>有向无环图DAG，指任意一条边有方向，且不存在环路的图。如果有一个非有向无环图，且A点出发向B经C可回到A，形成一个环。将从C到A的边方向改为从A到C，则变成有向无环图。有向无环图的生成树个数等于入度非零的节点的入度积。</li>
<li>深度优先遍历（DFS）；<ol>
<li>访问指定的起始顶点；</li>
<li>若当前访问的顶点的邻接顶点有未被访问的，则任选一个访问之；反之，退回到最近访问过的顶点；直到与起始顶点相通的全部顶点都访问完毕；</li>
<li>若此时图中尚有顶点未被访问，则再选其中一个顶点作为起始顶点并访问之，转 2； 反之，遍历结束。</li>
</ol>
</li>
</ol>
<h4 id="49、简述java-web-中getAttribute-和getParameter-1"><a href="#49、简述java-web-中getAttribute-和getParameter-1" class="headerlink" title="49、简述java web 中getAttribute()和getParameter()"></a>49、简述java web 中getAttribute()和getParameter()</h4><ol>
<li>根本上的差异，getAttribute得到的是对象，而getParameter得到的是字符串。</li>
<li>Parameter一般用于常规的http通信，如表单提交，url参数等，此时如果使用getAttribute则得不到任何结果</li>
<li>Attribute专门适用于java web容器内部各组件之间的交流，因为可以放下一整个对象，则可以传递更为丰富的信息，且getAttribute() 得到的数据对应的是得用setAttribute()来取出来。 </li>
</ol>
<h4 id="50、返回第一次匹配字符串位置-1"><a href="#50、返回第一次匹配字符串位置-1" class="headerlink" title="50、返回第一次匹配字符串位置"></a>50、返回第一次匹配字符串位置</h4><p>indexOf()方法可返某个指定的子字符串值在字符串中首次出现的位置</p>
<h4 id="51、100，随机10组，每组10个，数字1和数字2分到同一组概率-1"><a href="#51、100，随机10组，每组10个，数字1和数字2分到同一组概率-1" class="headerlink" title="51、100，随机10组，每组10个，数字1和数字2分到同一组概率"></a>51、100，随机10组，每组10个，数字1和数字2分到同一组概率</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#define R (abs(rand())%100)</span><br><span class="line">int group[100],i,j,k,p;</span><br><span class="line">int member[10][10],members[10];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    for(i=0;i&lt;100;i++)group[i]=i;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    for(j = R + 100;j--;)</span><br><span class="line">    &#123;</span><br><span class="line">        i=R;k=R;</span><br><span class="line">        p=group[i];</span><br><span class="line">        group[i] = group[k];</span><br><span class="line">        group[k] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;100;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        member[group[i]/10][members[group[i]/10]] = i;</span><br><span class="line">        members[group[i]/10]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;10;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;第 %02d 组 : &quot;,i+1);</span><br><span class="line">        for(j=0;j&lt;10;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%03d%c&quot;,member[i][j]+1,j==9?10:32);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="52、链表法解决冲突-1"><a href="#52、链表法解决冲突-1" class="headerlink" title="52、链表法解决冲突"></a>52、链表法解决冲突</h4><p>将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。</p>
<h4 id="53、TTL字段-1"><a href="#53、TTL字段-1" class="headerlink" title="53、TTL字段"></a>53、TTL字段</h4><p>TTL（生存时间值）：Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4包头的一个8 bit字段。</p>
<h5 id="54、输入正整数n，d，n为字符串，n的子串被d整除的个数-1"><a href="#54、输入正整数n，d，n为字符串，n的子串被d整除的个数-1" class="headerlink" title="54、输入正整数n，d，n为字符串，n的子串被d整除的个数"></a>54、输入正整数n，d，n为字符串，n的子串被d整除的个数</h5><h4 id="55、可被多个线程共享（data-section-file-fd）-1"><a href="#55、可被多个线程共享（data-section-file-fd）-1" class="headerlink" title="55、可被多个线程共享（data section/file fd）"></a>55、可被多个线程共享（data section/file fd）</h4><h5 id="线程共享的内容-1"><a href="#线程共享的内容-1" class="headerlink" title="线程共享的内容"></a>线程共享的内容</h5><ol>
<li>进程代码段</li>
<li>进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、</li>
<li>进程打开的文件描述符、</li>
<li>信号的处理器、</li>
<li>进程的当前目录和</li>
<li>进程用户ID与进程组ID   </li>
</ol>
<h5 id="线程独有的内容包括-1"><a href="#线程独有的内容包括-1" class="headerlink" title="线程独有的内容包括"></a>线程独有的内容包括</h5><ol>
<li>线程ID</li>
<li>寄存器组的值</li>
<li>线程的堆栈</li>
<li>错误返回码</li>
<li>线程的信号屏蔽码</li>
</ol>
<h4 id="56、小顶堆的中序遍历-1"><a href="#56、小顶堆的中序遍历-1" class="headerlink" title="56、小顶堆的中序遍历"></a>56、小顶堆的中序遍历</h4><h4 id="57、稳定的排序算法-1"><a href="#57、稳定的排序算法-1" class="headerlink" title="57、稳定的排序算法"></a>57、稳定的排序算法</h4><ol>
<li>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法</li>
<li>冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法</li>
</ol>
<h4 id="58、结构型设计模式-1"><a href="#58、结构型设计模式-1" class="headerlink" title="58、结构型设计模式"></a>58、结构型设计模式</h4><h5 id="结构型模式共七种：-1"><a href="#结构型模式共七种：-1" class="headerlink" title="结构型模式共七种："></a>结构型模式共七种：</h5><ol>
<li>适配器模式（Adapter）　　　　　　　　</li>
<li>外观模式（Facade）</li>
<li>桥接模式（Bridge）</li>
<li>装饰器模式（Decorator）</li>
<li>代理模式（Proxy）</li>
<li>享元模式（Flyweight）</li>
<li>组合模式（Composite）</li>
</ol>
<h5 id="其中又分为-1"><a href="#其中又分为-1" class="headerlink" title="其中又分为"></a>其中又分为</h5><ol>
<li>接口适配：适配器、外观、桥接模式</li>
<li>行为扩展：装饰</li>
<li>性能与对象访问：代理、享元模式</li>
<li>抽象集合：组合模式</li>
</ol>
<h4 id="59、ICMP协议功能-1"><a href="#59、ICMP协议功能-1" class="headerlink" title="59、ICMP协议功能"></a>59、ICMP协议功能</h4><p>Internet Control Message Protocol </p>
<ol>
<li>侦测远端主机是否存在</li>
<li>建立及维护路由资料</li>
<li>重导数据传送路径</li>
<li>数据流量控制</li>
</ol>
<h4 id="60、不引起进程阻塞-1"><a href="#60、不引起进程阻塞-1" class="headerlink" title="60、不引起进程阻塞"></a>60、不引起进程阻塞</h4><p>进程阻塞的原因</p>
<ol>
<li>等待I/O</li>
<li>进程sleep</li>
<li>等待解锁</li>
</ol>
<h4 id="61、稳定且平均时间复杂度最优算法-归并排序-1"><a href="#61、稳定且平均时间复杂度最优算法-归并排序-1" class="headerlink" title="61、稳定且平均时间复杂度最优算法(归并排序)"></a>61、稳定且平均时间复杂度最优算法(归并排序)</h4><h4 id="62、二分查找（顺序）-1"><a href="#62、二分查找（顺序）-1" class="headerlink" title="62、二分查找（顺序）"></a>62、二分查找（顺序）</h4><h4 id="63、地址传递-1"><a href="#63、地址传递-1" class="headerlink" title="63、地址传递"></a>63、地址传递</h4><ol>
<li>值传递：传递的只是一份副本。<ol>
<li>特点：调用者可以保护自己空间值不被修改。【保护】</li>
<li>缺点：因为每次调用都会传递一份副本，因此内存消耗很大，工程中不建议使用。</li>
</ol>
</li>
<li>地址传递：传递的门牌号<ol>
<li>特点：调用者让被调者修改自己的空间值。【修改】</li>
<li>用处：<ol>
<li>调用者让被调者修改自己的空间值</li>
<li>连续空间的传递</li>
</ol>
</li>
<li>优点：不用拷贝副本，可以节约空间。</li>
</ol>
</li>
</ol>
<h4 id="64、Linux改变文件所有者命令：chown-1"><a href="#64、Linux改变文件所有者命令：chown-1" class="headerlink" title="64、Linux改变文件所有者命令：chown"></a>64、Linux改变文件所有者命令：chown</h4><h4 id="65、byte-b-0x175-1"><a href="#65、byte-b-0x175-1" class="headerlink" title="65、byte b=0x175"></a>65、byte b=0x175</h4><p>十六进制数不能赋给byte类型的数据，数据有误</p>
<h4 id="66、逻辑短路运算符-1"><a href="#66、逻辑短路运算符-1" class="headerlink" title="66、逻辑短路运算符"></a>66、逻辑短路运算符</h4><p>在Java中短路运算符指的是”&amp;&amp;”(与) 和”||”(或) ,非短路运算符指的是”&amp;” 和”|”.</p>
<ol>
<li>如果 “&amp;&amp;” 运算符的第一个表达式为false,则第二个表达式就不会执行</li>
<li>如果 “||” 运算符的第一个表达式为true,则第二个表达式就不会执行</li>
</ol>
<h4 id="67、Map的value可以是list或Map（true）-1"><a href="#67、Map的value可以是list或Map（true）-1" class="headerlink" title="67、Map的value可以是list或Map（true）"></a>67、Map的value可以是list或Map（true）</h4><h4 id="68、js变量默认值：undefined-1"><a href="#68、js变量默认值：undefined-1" class="headerlink" title="68、js变量默认值：undefined"></a>68、js变量默认值：undefined</h4><ol>
<li>undefined：是所有没有赋值变量的默认值，自动赋值</li>
<li>null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址</li>
</ol>
<h4 id="69、jdk核心源码：src目录（true）-1"><a href="#69、jdk核心源码：src目录（true）-1" class="headerlink" title="69、jdk核心源码：src目录（true）"></a>69、jdk核心源码：src目录（true）</h4><h4 id="70、分支覆盖测试用例-1"><a href="#70、分支覆盖测试用例-1" class="headerlink" title="70、分支覆盖测试用例"></a>70、分支覆盖测试用例</h4><p>判定覆盖也被成为分支覆盖(Branch Coverage)，也就是说设计的测试用例要保证让被测试程序中的每一个分支都至少执行一次</p>
<h4 id="71、冒烟测试-1"><a href="#71、冒烟测试-1" class="headerlink" title="71、冒烟测试"></a>71、冒烟测试</h4><p>冒烟测试的对象是每一个新编译的需要正式测试的软件版本，目的是确认软件基本功能正常，可以进行后续的正式测试工作</p>
<h4 id="72、HTTP服务器端错误-1"><a href="#72、HTTP服务器端错误-1" class="headerlink" title="72、HTTP服务器端错误"></a>72、HTTP服务器端错误</h4><ol>
<li>400 非法请求(Bad Request)：如果请求的语法不对，服务器将无法理解。客户端在对该请求做出更改之前，不应再次向服务器重复发送该请求。</li>
<li>401 未授权(Unauthorized)：请求需要用户授权。客户端应使用合适的授权标题域来重复该请求。如果请求中已经包括了授权信任信息，那回应的401表示此授权被拒绝。如果用户代理在多次尝试之后，回应一样还是返回401状态代码，用户应当察看一下回应的实体，因为在实体中会包括一些相关的动态信息。</li>
<li>403 禁止(Forbidden)：服务器理解请求，但是拒绝实现该请求。授权对此没有帮助，客户端应当停止重复发送此请求。如果不是用HEAD请求方法，而且服务器端愿意公布请求未被实现原因的前提下，服务器会将拒绝原因写在回应实体中。该状态码一般用于服务器端不想公布请求被拒绝的细节或没有其它的回应可用。</li>
<li>404 没有找到(Not Found)：服务器没有找到与请求URI相符的资源。404状态码并不指明状况是临时性的还是永久性的。如果服务器不希望为客户端提供这方面的信息，还回应403(禁止)状态码。</li>
<li>服务器错误(Server Error )5xx：回应代码以‘5’开头的状态码表示服务器端发现自己出现错误，不能继续执行请求。如果客户端在收到5xx状态码时，请求尚未完成，它应当立即停止向服务器发送数据。除了回应HEAD请求外，服务器应当在其回应实体中包括对错误情况的解释、并指明是临时性的还是永久性的。</li>
</ol>
<h4 id="73、Linux强制删除非空目录-1"><a href="#73、Linux强制删除非空目录-1" class="headerlink" title="73、Linux强制删除非空目录"></a>73、Linux强制删除非空目录</h4><p>rm -rf 目录名字</p>
<ol>
<li>-r 向下递归，不管有多少级目录，一并删除</li>
<li>-f 直接强行删除，不作任何提示的意思</li>
</ol>
<p>1、删除/var/log/httpd/access目录以及其下所有文件、文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/log/httpd/access</span><br></pre></td></tr></table></figure>
<p>2、强制删除/var/log/httpd/access.log这个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /var/log/httpd/access.log</span><br></pre></td></tr></table></figure>
<h4 id="74、TCP拥塞控制方法-1"><a href="#74、TCP拥塞控制方法-1" class="headerlink" title="74、TCP拥塞控制方法"></a>74、TCP拥塞控制方法</h4><ol>
<li>慢开始( slow-start )</li>
<li>拥塞避免( congestion avoidance )</li>
<li>快重传( fast retransmit )</li>
<li>快恢复( fast recovery )</li>
</ol>
<h4 id="75、二分查找and二叉排序树（对于有序序列，非递归时度-lt-递归）-1"><a href="#75、二分查找and二叉排序树（对于有序序列，非递归时度-lt-递归）-1" class="headerlink" title="75、二分查找and二叉排序树（对于有序序列，非递归时度&lt;递归）"></a>75、二分查找and二叉排序树（对于有序序列，非递归时度&lt;递归）</h4><h4 id="76、sleep-wait-1"><a href="#76、sleep-wait-1" class="headerlink" title="76、sleep()/wait()"></a>76、sleep()/wait()</h4><ol>
<li>由于sleep()方法是Thread类的方法，因此它不能改变对象的机锁。所以当在一个Synchronized方法中调用sleep（）时，线程虽然休眠了，但是对象的机锁没有被释放，其他线程仍然无法访问这个对象。而wait()方法则会在线程休眠的同时释放掉机锁，其他线程可以访问该对象。 </li>
<li>Thread.sleep(long)可以不在synchronized的块下调用，而且使用Thread.sleep()不会丢失当前线程对任何对象的同步锁(monitor);</li>
<li>object.wait(long)必须在synchronized的块下来使用，调用了之后失去对object的monitor, 这样做的好处是它不影响其它的线程对object进行操作。utm_source=copy</li>
</ol>
<h4 id="77、防止死锁发生-1"><a href="#77、防止死锁发生-1" class="headerlink" title="77、防止死锁发生"></a>77、防止死锁发生</h4><ol>
<li>破坏互斥条件</li>
<li>破坏请求并保持条件</li>
<li>破坏不可剥夺条件</li>
<li>破坏循环等待条件</li>
</ol>
<h4 id="78、Python类、操作、属性（-add）-1"><a href="#78、Python类、操作、属性（-add）-1" class="headerlink" title="78、Python类、操作、属性（_add）"></a>78、Python类、操作、属性（_add）</h4><p>如果用dir(list)查看list的属性，能看到一个属性是<strong>add</strong>()</p>
<h4 id="79、shell脚本输出-1"><a href="#79、shell脚本输出-1" class="headerlink" title="79、shell脚本输出"></a>79、shell脚本输出</h4><ol>
<li>$echo hello world</li>
<li>$echo ‘hello world’</li>
<li>$echo “hello world”</li>
</ol>
<h4 id="80、不能用来修饰interface-1"><a href="#80、不能用来修饰interface-1" class="headerlink" title="80、不能用来修饰interface"></a>80、不能用来修饰interface</h4><p>接口可以使用public和默认的进行修饰</p>
<h4 id="81、分时操作系统，进程调度采用“时间片轮转”-true-1"><a href="#81、分时操作系统，进程调度采用“时间片轮转”-true-1" class="headerlink" title="81、分时操作系统，进程调度采用“时间片轮转”(true)"></a>81、分时操作系统，进程调度采用“时间片轮转”(true)</h4><h4 id="82、ROM中存放的信息在计算机断电后内容（不会丢失）-1"><a href="#82、ROM中存放的信息在计算机断电后内容（不会丢失）-1" class="headerlink" title="82、ROM中存放的信息在计算机断电后内容（不会丢失）"></a>82、ROM中存放的信息在计算机断电后内容（不会丢失）</h4><ol>
<li>rom是只读储存器，不可以写入，也不会丢失</li>
<li>ram是电记忆的读写储存器，掉电后数据丢失</li>
</ol>
<h4 id="83、in-interval-0-11-1"><a href="#83、in-interval-0-11-1" class="headerlink" title="83、in interval(0,11)"></a>83、in interval(0,11)</h4><h4 id="84、处理外部中断时，应该由操作系统保存（程序计数器PC）-1"><a href="#84、处理外部中断时，应该由操作系统保存（程序计数器PC）-1" class="headerlink" title="84、处理外部中断时，应该由操作系统保存（程序计数器PC）"></a>84、处理外部中断时，应该由操作系统保存（程序计数器PC）</h4><p><strong>外部中断处理过程首先要保护现场，使得中断处理完之后能够恢复程序的执行状态继续执行。</strong><br>保护现场有两个含义</p>
<ol>
<li>由中断隐指令保存程序的断点（程序计数器）</li>
<li>由中断服务程序保存通用寄存器和状态寄存器的内容，中断服务程序是操作系统的一部分。</li>
</ol>
<h4 id="85、在jsp可以操作cookie-jsp在浏览器的执行是单线程的-1"><a href="#85、在jsp可以操作cookie-jsp在浏览器的执行是单线程的-1" class="headerlink" title="85、在jsp可以操作cookie/jsp在浏览器的执行是单线程的"></a>85、在jsp可以操作cookie/jsp在浏览器的执行是单线程的</h4><h4 id="86、微型计算机的cache是（高速缓冲存储器）-1"><a href="#86、微型计算机的cache是（高速缓冲存储器）-1" class="headerlink" title="86、微型计算机的cache是（高速缓冲存储器）"></a>86、微型计算机的cache是（高速缓冲存储器）</h4><h4 id="87、最速下降法-1"><a href="#87、最速下降法-1" class="headerlink" title="87、最速下降法"></a>87、最速下降法</h4><blockquote>
<p>给定初始点x0=(1,1),用最速下降法求函数f(x)=4x1+6x2-2x1^2-2x1x2-2x2^2的极大值，则迭代一次后x1的值（-1、1/2、-1/2、2，1）？</p>
</blockquote>
<h4 id="88、发货功能测试用例-1"><a href="#88、发货功能测试用例-1" class="headerlink" title="88、发货功能测试用例"></a>88、发货功能测试用例</h4><h4 id="89、双向链表定义-1"><a href="#89、双向链表定义-1" class="headerlink" title="89、双向链表定义"></a>89、双向链表定义</h4><p>双向链表，每个数据结点中都有两个结点，分别指向其直接前驱和直接后继。所以我们从双向链表的任意一个结点开始都可以很方便的访问其前驱元素和后继元素。</p>
<h4 id="90、词法分析阶段错误-1"><a href="#90、词法分析阶段错误-1" class="headerlink" title="90、词法分析阶段错误"></a>90、词法分析阶段错误</h4><p>词法分析，将字符序列转换为单词（Token）序列的过程</p>
<h4 id="91、序列安全（银行家算法）-1"><a href="#91、序列安全（银行家算法）-1" class="headerlink" title="91、序列安全（银行家算法）"></a>91、序列安全（银行家算法）</h4><h4 id="92、？？-1"><a href="#92、？？-1" class="headerlink" title="92、？？"></a>92、？？</h4><blockquote>
<p>p=q=r=(char<em>)malloc(sizeof(char)</em>20);<br>strcpy(p,”attaboy,welcome!”,p[11],q[3],r[4])<br>cta/lta/lab/cab</p>
</blockquote>
<h4 id="93、变量在内存中的存储位置-1"><a href="#93、变量在内存中的存储位置-1" class="headerlink" title="93、变量在内存中的存储位置"></a>93、变量在内存中的存储位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int a=0;</span><br><span class="line">class someClass&#123;</span><br><span class="line">    int b;</span><br><span class="line">    static int c;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int d=0;</span><br><span class="line">    someClass *p=new someClass();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java中变量的存储位置</p>
<ol>
<li>寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制. </li>
<li>栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。） </li>
<li>堆：存放所有new出来的对象。 </li>
<li>静态域：存放静态成员（static定义的） </li>
<li>常量池：存放字符串常量和基本类型常量（public static final）。 </li>
<li>非RAM存储：硬盘等永久存储空间 </li>
</ol>
<h4 id="94、进程通信-进程同步-1"><a href="#94、进程通信-进程同步-1" class="headerlink" title="94、进程通信/进程同步"></a>94、进程通信/进程同步</h4><h5 id="进程通信方式-1"><a href="#进程通信方式-1" class="headerlink" title="进程通信方式"></a>进程通信方式</h5><ol>
<li>信号</li>
<li>管道</li>
<li>消息队列</li>
<li>共享内存</li>
</ol>
<h5 id="进程同步的四种方法-1"><a href="#进程同步的四种方法-1" class="headerlink" title="进程同步的四种方法"></a>进程同步的四种方法</h5><ol>
<li>临界区（Critical Section）:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 </li>
<li>互斥量（Mutex）:为协调共同对一个共享资源的单独访问而设计的。</li>
<li>信号量（Semaphore）:为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</li>
<li>事件（Event）: 用来通知线程有一些事件已发生，从而启动后继任务的开始。</li>
</ol>
<h4 id="95、网络服务接口，Linux-1"><a href="#95、网络服务接口，Linux-1" class="headerlink" title="95、网络服务接口，Linux"></a>95、网络服务接口，Linux</h4><ol>
<li>$/sbin/ifconfig 查看所有活动网络接口信息，其中包括一个lo环回端口。</li>
<li>$/sbin/ifconfig &lt;网络接口名称&gt; 查看指定接口信息。</li>
<li>$/sbin/ifconfig –a 查看所有接口信息，包括非活动状态接口。</li>
<li>#/route：显示当前linux主机中的路由表信息。</li>
<li>$ping 目的主机地址：使用ping命令测试与其它主机的网络链接。ctrl+C终止。</li>
<li>$traceroute &lt;目的主机地址&gt;：traceroute命令显示当前主机与目的主机之间经过的所，有网络节点的地址，以及当前主机到每个中间结点的连接状态。</li>
<li>$Hostname 查看当前的主机名。</li>
<li>$Nslookup：使用dns服务器查询域名</li>
<li>$Dhclient 使用dhclient命令可以从DHCP服务器中申请新的网络配置应用到当前主机。</li>
<li>Ip地址配置命令：Ifconfig &lt;网络接口名称&gt; network &lt;子网掩码&gt;</li>
<li>$Route del default gw &lt;默认网关地址&gt;删除默认网关路由</li>
<li>$Route add default gw &lt;默认网关地址&gt;：添加默认网关路由</li>
<li>#hostname 123：主机名称配置命令</li>
<li>#/etc/rc.d/init.d/network start 启动network</li>
<li>#/etc/rc.d/init.d/network stop 停止network</li>
<li>#/etc/rc.d/init.d/network restart 重启network</li>
<li>/etc/sysconfig/network-scripts/ifconfg-*：网络接口配置文件</li>
<li>#ifconfig eth0 down 停止eth0接口</li>
<li>#ifconfig eth0 up 开启eth0接口</li>
</ol>
<h4 id="96、匹配输出log文件中第5行的数字并由小到大排序-1"><a href="#96、匹配输出log文件中第5行的数字并由小到大排序-1" class="headerlink" title="96、匹配输出log文件中第5行的数字并由小到大排序"></a>96、匹配输出log文件中第5行的数字并由小到大排序</h4><p>linux 如何显示一个文件的某几行(中间几行)</p>
<ol>
<li>从第3000行开始，显示1000行。即显示3000~3999行<br>cat filename | tail -n +3000 | head -n 1000</li>
<li>显示1000行到3000行<br>cat filename| head -n 3000 | tail -n +1000<ol>
<li>tail -n 1000：显示最后1000行</li>
<li>tail -n +1000：从1000行开始显示，显示1000行以后的</li>
<li>head -n 1000：显示前面1000行</li>
</ol>
</li>
<li>用sed命令<br>sed -n ‘5,10p’ filename ，查看文件的第5行到第10行。</li>
</ol>

      
    </div>
    
    
    

<div>
  
    
  
</div>
    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/04/面试汇总帖-1/" rel="next" title="面试汇总帖-1">
                <i class="fa fa-chevron-left"></i> 面试汇总帖-1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/qifang.jpg"
                alt="十点一刻" />
            
              <p class="site-author-name" itemprop="name">十点一刻</p>
              <p class="site-description motion-element" itemprop="description">在没有路的丛林走出迷雾</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/tenneling" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:tenneling@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、使用DOM解析XML"><span class="nav-number">1.</span> <span class="nav-text">1、使用DOM解析XML</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用DOM方式进行xml文档的写入和解析的方法"><span class="nav-number">1.1.</span> <span class="nav-text">使用DOM方式进行xml文档的写入和解析的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通过DOM写XML文档"><span class="nav-number">1.2.</span> <span class="nav-text">通过DOM写XML文档</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、数据仓库粒度的具体划分将直接影响数据仓库中的数据量以及查询质量-true"><span class="nav-number">2.</span> <span class="nav-text">2、数据仓库粒度的具体划分将直接影响数据仓库中的数据量以及查询质量(true)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、哪种方法创建对象时不会调用类的构造函数"><span class="nav-number">3.</span> <span class="nav-text">3、哪种方法创建对象时不会调用类的构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Java创建对象的方式"><span class="nav-number">3.1.</span> <span class="nav-text">Java创建对象的方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、stringbuffer-stringbuilder"><span class="nav-number">4.</span> <span class="nav-text">4、stringbuffer/stringbuilder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、B类地址"><span class="nav-number">5.</span> <span class="nav-text">5、B类地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、开销最大的缓存替换算法（FIFO）"><span class="nav-number">6.</span> <span class="nav-text">6、开销最大的缓存替换算法（FIFO）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7、指令流水线"><span class="nav-number">7.</span> <span class="nav-text">7、指令流水线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8、在地址栏输入“…jsp”，直到浏览器渲染网页完毕为止，期间发生的所有事件"><span class="nav-number">8.</span> <span class="nav-text">8、在地址栏输入“…jsp”，直到浏览器渲染网页完毕为止，期间发生的所有事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10、关键字"><span class="nav-number">9.</span> <span class="nav-text">10、关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11、代理类"><span class="nav-number">10.</span> <span class="nav-text">11、代理类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12、IO"><span class="nav-number">11.</span> <span class="nav-text">12、IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13、多态"><span class="nav-number">12.</span> <span class="nav-text">13、多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14、ArrayList和vector"><span class="nav-number">13.</span> <span class="nav-text">14、ArrayList和vector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15、数组比线性表速度更快：返回中间节点-选择随机节点-原地逆序"><span class="nav-number">14.</span> <span class="nav-text">15、数组比线性表速度更快：返回中间节点/选择随机节点/原地逆序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16、堆排序在最坏情况下的时间复杂度（O-nlogn-）"><span class="nav-number">15.</span> <span class="nav-text">16、堆排序在最坏情况下的时间复杂度（O(nlogn)）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17、哈希冲突"><span class="nav-number">16.</span> <span class="nav-text">17、哈希冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18、分支限界法"><span class="nav-number">17.</span> <span class="nav-text">18、分支限界法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19、递归"><span class="nav-number">18.</span> <span class="nav-text">19、递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20、快速排序算法"><span class="nav-number">19.</span> <span class="nav-text">20、快速排序算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21、SCAN寻道"><span class="nav-number">20.</span> <span class="nav-text">21、SCAN寻道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22、平衡二叉树寻找"><span class="nav-number">21.</span> <span class="nav-text">22、平衡二叉树寻找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23、赫尔曼编码"><span class="nav-number">22.</span> <span class="nav-text">23、赫尔曼编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24、平衡二叉树深度"><span class="nav-number">23.</span> <span class="nav-text">24、平衡二叉树深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25、若串s-“facetime”，其子串个数为（37）"><span class="nav-number">24.</span> <span class="nav-text">25、若串s=“facetime”，其子串个数为（37）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26、String方法"><span class="nav-number">25.</span> <span class="nav-text">26、String方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27、MySQL存储过程优点"><span class="nav-number">26.</span> <span class="nav-text">27、MySQL存储过程优点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点："><span class="nav-number">26.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点："><span class="nav-number">26.2.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28、第一个体现结构化思想编程语言"><span class="nav-number">27.</span> <span class="nav-text">28、第一个体现结构化思想编程语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29、运行Test-class-java-Test-class"><span class="nav-number">28.</span> <span class="nav-text">29、运行Test.class: java Test.class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30、HTML5标签-略"><span class="nav-number">29.</span> <span class="nav-text">30、HTML5标签(略)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31、IP协议属于（网络层协议）"><span class="nav-number">30.</span> <span class="nav-text">31、IP协议属于（网络层协议）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32、CSMA-CD协议特点：可抢占性-全双工"><span class="nav-number">31.</span> <span class="nav-text">32、CSMA/CD协议特点：可抢占性/全双工</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）"><span class="nav-number">32.</span> <span class="nav-text">33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34、sql用于将事务处理写到数据库"><span class="nav-number">33.</span> <span class="nav-text">34、sql用于将事务处理写到数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35、运算符优先顺序：赋值-lt-与-lt-关系-lt-算术"><span class="nav-number">34.</span> <span class="nav-text">35、运算符优先顺序：赋值&lt;与&lt;关系&lt;算术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36、二分查找"><span class="nav-number">35.</span> <span class="nav-text">36、二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#37、正则表达式"><span class="nav-number">36.</span> <span class="nav-text">37、正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#38、指针"><span class="nav-number">37.</span> <span class="nav-text">38、指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39、XSS攻击-SQL注入攻击-CSRF攻击"><span class="nav-number">38.</span> <span class="nav-text">39、XSS攻击/SQL注入攻击/CSRF攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#40、for和while的区别"><span class="nav-number">39.</span> <span class="nav-text">40、for和while的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#41、暗黑"><span class="nav-number">40.</span> <span class="nav-text">41、暗黑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）"><span class="nav-number">41.</span> <span class="nav-text">42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#43、使用队列做辅助存储空间：广度优先搜索图"><span class="nav-number">42.</span> <span class="nav-text">43、使用队列做辅助存储空间：广度优先搜索图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#44、属于mysql流程控制（case-when）"><span class="nav-number">43.</span> <span class="nav-text">44、属于mysql流程控制（case when）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#45、Java-Set中对象特点"><span class="nav-number">44.</span> <span class="nav-text">45、Java Set中对象特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46、原型模式的本质"><span class="nav-number">45.</span> <span class="nav-text">46、原型模式的本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#47、折半查找条件"><span class="nav-number">46.</span> <span class="nav-text">47、折半查找条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#48、DAG-DFS"><span class="nav-number">47.</span> <span class="nav-text">48、DAG/DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#49、简述java-web-中getAttribute-和getParameter"><span class="nav-number">48.</span> <span class="nav-text">49、简述java web 中getAttribute()和getParameter()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#50、返回第一次匹配字符串位置"><span class="nav-number">49.</span> <span class="nav-text">50、返回第一次匹配字符串位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#51、100，随机10组，每组10个，数字1和数字2分到同一组概率"><span class="nav-number">50.</span> <span class="nav-text">51、100，随机10组，每组10个，数字1和数字2分到同一组概率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#52、链表法解决冲突"><span class="nav-number">51.</span> <span class="nav-text">52、链表法解决冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53、TTL字段"><span class="nav-number">52.</span> <span class="nav-text">53、TTL字段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#54、输入正整数n，d，n为字符串，n的子串被d整除的个数"><span class="nav-number">52.1.</span> <span class="nav-text">54、输入正整数n，d，n为字符串，n的子串被d整除的个数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#55、可被多个线程共享（data-section-file-fd）"><span class="nav-number">53.</span> <span class="nav-text">55、可被多个线程共享（data section/file fd）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#线程共享的内容"><span class="nav-number">53.1.</span> <span class="nav-text">线程共享的内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程独有的内容包括"><span class="nav-number">53.2.</span> <span class="nav-text">线程独有的内容包括</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#56、小顶堆的中序遍历"><span class="nav-number">54.</span> <span class="nav-text">56、小顶堆的中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#57、稳定的排序算法"><span class="nav-number">55.</span> <span class="nav-text">57、稳定的排序算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#58、结构型设计模式"><span class="nav-number">56.</span> <span class="nav-text">58、结构型设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#结构型模式共七种："><span class="nav-number">56.1.</span> <span class="nav-text">结构型模式共七种：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其中又分为"><span class="nav-number">56.2.</span> <span class="nav-text">其中又分为</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#59、ICMP协议功能"><span class="nav-number">57.</span> <span class="nav-text">59、ICMP协议功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#60、不引起进程阻塞"><span class="nav-number">58.</span> <span class="nav-text">60、不引起进程阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#61、稳定且平均时间复杂度最优算法-归并排序"><span class="nav-number">59.</span> <span class="nav-text">61、稳定且平均时间复杂度最优算法(归并排序)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#62、二分查找（顺序）"><span class="nav-number">60.</span> <span class="nav-text">62、二分查找（顺序）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#63、地址传递"><span class="nav-number">61.</span> <span class="nav-text">63、地址传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64、Linux改变文件所有者命令：chown"><span class="nav-number">62.</span> <span class="nav-text">64、Linux改变文件所有者命令：chown</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#65、byte-b-0x175"><span class="nav-number">63.</span> <span class="nav-text">65、byte b=0x175</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#66、逻辑短路运算符"><span class="nav-number">64.</span> <span class="nav-text">66、逻辑短路运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#67、Map的value可以是list或Map（true）"><span class="nav-number">65.</span> <span class="nav-text">67、Map的value可以是list或Map（true）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#68、js变量默认值：undefined"><span class="nav-number">66.</span> <span class="nav-text">68、js变量默认值：undefined</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#69、jdk核心源码：src目录（true）"><span class="nav-number">67.</span> <span class="nav-text">69、jdk核心源码：src目录（true）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#70、分支覆盖测试用例"><span class="nav-number">68.</span> <span class="nav-text">70、分支覆盖测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#71、冒烟测试"><span class="nav-number">69.</span> <span class="nav-text">71、冒烟测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#72、HTTP服务器端错误"><span class="nav-number">70.</span> <span class="nav-text">72、HTTP服务器端错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#73、Linux强制删除非空目录"><span class="nav-number">71.</span> <span class="nav-text">73、Linux强制删除非空目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#74、TCP拥塞控制方法"><span class="nav-number">72.</span> <span class="nav-text">74、TCP拥塞控制方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#75、二分查找and二叉排序树（对于有序序列，非递归时度-lt-递归）"><span class="nav-number">73.</span> <span class="nav-text">75、二分查找and二叉排序树（对于有序序列，非递归时度&lt;递归）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#76、sleep-wait"><span class="nav-number">74.</span> <span class="nav-text">76、sleep()/wait()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#77、防止死锁发生"><span class="nav-number">75.</span> <span class="nav-text">77、防止死锁发生</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#78、Python类、操作、属性（-add）"><span class="nav-number">76.</span> <span class="nav-text">78、Python类、操作、属性（_add）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#79、shell脚本输出"><span class="nav-number">77.</span> <span class="nav-text">79、shell脚本输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#80、不能用来修饰interface"><span class="nav-number">78.</span> <span class="nav-text">80、不能用来修饰interface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#81、分时操作系统，进程调度采用“时间片轮转”-true"><span class="nav-number">79.</span> <span class="nav-text">81、分时操作系统，进程调度采用“时间片轮转”(true)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#82、ROM中存放的信息在计算机断电后内容（不会丢失）"><span class="nav-number">80.</span> <span class="nav-text">82、ROM中存放的信息在计算机断电后内容（不会丢失）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#83、in-interval-0-11"><span class="nav-number">81.</span> <span class="nav-text">83、in interval(0,11)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#84、处理外部中断时，应该由操作系统保存（程序计数器PC）"><span class="nav-number">82.</span> <span class="nav-text">84、处理外部中断时，应该由操作系统保存（程序计数器PC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#85、在jsp可以操作cookie-jsp在浏览器的执行是单线程的"><span class="nav-number">83.</span> <span class="nav-text">85、在jsp可以操作cookie/jsp在浏览器的执行是单线程的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#86、微型计算机的cache是（高速缓冲存储器）"><span class="nav-number">84.</span> <span class="nav-text">86、微型计算机的cache是（高速缓冲存储器）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#87、最速下降法"><span class="nav-number">85.</span> <span class="nav-text">87、最速下降法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#88、发货功能测试用例"><span class="nav-number">86.</span> <span class="nav-text">88、发货功能测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#89、双向链表定义"><span class="nav-number">87.</span> <span class="nav-text">89、双向链表定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#90、词法分析阶段错误"><span class="nav-number">88.</span> <span class="nav-text">90、词法分析阶段错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#91、序列安全（银行家算法）"><span class="nav-number">89.</span> <span class="nav-text">91、序列安全（银行家算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#92、？？"><span class="nav-number">90.</span> <span class="nav-text">92、？？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#93、变量在内存中的存储位置"><span class="nav-number">91.</span> <span class="nav-text">93、变量在内存中的存储位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#94、进程通信-进程同步"><span class="nav-number">92.</span> <span class="nav-text">94、进程通信/进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程通信方式"><span class="nav-number">92.1.</span> <span class="nav-text">进程通信方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程同步的四种方法"><span class="nav-number">92.2.</span> <span class="nav-text">进程同步的四种方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#95、网络服务接口，Linux"><span class="nav-number">93.</span> <span class="nav-text">95、网络服务接口，Linux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#96、匹配输出log文件中第5行的数字并由小到大排序"><span class="nav-number">94.</span> <span class="nav-text">96、匹配输出log文件中第5行的数字并由小到大排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10、关键字-1"><span class="nav-number">95.</span> <span class="nav-text">10、关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11、代理类-1"><span class="nav-number">96.</span> <span class="nav-text">11、代理类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12、IO-1"><span class="nav-number">97.</span> <span class="nav-text">12、IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13、多态-1"><span class="nav-number">98.</span> <span class="nav-text">13、多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14、ArrayList和vector-1"><span class="nav-number">99.</span> <span class="nav-text">14、ArrayList和vector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15、数组比线性表速度更快：返回中间节点-选择随机节点-原地逆序-1"><span class="nav-number">100.</span> <span class="nav-text">15、数组比线性表速度更快：返回中间节点/选择随机节点/原地逆序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16、堆排序在最坏情况下的时间复杂度（O-nlogn-）-1"><span class="nav-number">101.</span> <span class="nav-text">16、堆排序在最坏情况下的时间复杂度（O(nlogn)）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17、哈希冲突-1"><span class="nav-number">102.</span> <span class="nav-text">17、哈希冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18、分支限界法-1"><span class="nav-number">103.</span> <span class="nav-text">18、分支限界法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19、递归-1"><span class="nav-number">104.</span> <span class="nav-text">19、递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20、快速排序算法-1"><span class="nav-number">105.</span> <span class="nav-text">20、快速排序算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21、SCAN寻道-1"><span class="nav-number">106.</span> <span class="nav-text">21、SCAN寻道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22、平衡二叉树寻找-1"><span class="nav-number">107.</span> <span class="nav-text">22、平衡二叉树寻找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23、赫尔曼编码-1"><span class="nav-number">108.</span> <span class="nav-text">23、赫尔曼编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24、平衡二叉树深度-1"><span class="nav-number">109.</span> <span class="nav-text">24、平衡二叉树深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25、若串s-“facetime”，其子串个数为（37）-1"><span class="nav-number">110.</span> <span class="nav-text">25、若串s=“facetime”，其子串个数为（37）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26、String方法-1"><span class="nav-number">111.</span> <span class="nav-text">26、String方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27、MySQL存储过程优点-1"><span class="nav-number">112.</span> <span class="nav-text">27、MySQL存储过程优点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点：-1"><span class="nav-number">112.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点：-1"><span class="nav-number">112.2.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28、第一个体现结构化思想编程语言-1"><span class="nav-number">113.</span> <span class="nav-text">28、第一个体现结构化思想编程语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29、运行Test-class-java-Test-class-1"><span class="nav-number">114.</span> <span class="nav-text">29、运行Test.class: java Test.class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30、HTML5标签-略-1"><span class="nav-number">115.</span> <span class="nav-text">30、HTML5标签(略)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31、IP协议属于（网络层协议）-1"><span class="nav-number">116.</span> <span class="nav-text">31、IP协议属于（网络层协议）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32、CSMA-CD协议特点：可抢占性-全双工-1"><span class="nav-number">117.</span> <span class="nav-text">32、CSMA/CD协议特点：可抢占性/全双工</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）-1"><span class="nav-number">118.</span> <span class="nav-text">33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34、sql用于将事务处理写到数据库-1"><span class="nav-number">119.</span> <span class="nav-text">34、sql用于将事务处理写到数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35、运算符优先顺序：赋值-lt-与-lt-关系-lt-算术-1"><span class="nav-number">120.</span> <span class="nav-text">35、运算符优先顺序：赋值&lt;与&lt;关系&lt;算术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36、二分查找-1"><span class="nav-number">121.</span> <span class="nav-text">36、二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#37、正则表达式-1"><span class="nav-number">122.</span> <span class="nav-text">37、正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#38、指针-1"><span class="nav-number">123.</span> <span class="nav-text">38、指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39、XSS攻击-SQL注入攻击-CSRF攻击-1"><span class="nav-number">124.</span> <span class="nav-text">39、XSS攻击/SQL注入攻击/CSRF攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#40、for和while的区别-1"><span class="nav-number">125.</span> <span class="nav-text">40、for和while的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#41、暗黑-1"><span class="nav-number">126.</span> <span class="nav-text">41、暗黑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）-1"><span class="nav-number">127.</span> <span class="nav-text">42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#43、使用队列做辅助存储空间：广度优先搜索图-1"><span class="nav-number">128.</span> <span class="nav-text">43、使用队列做辅助存储空间：广度优先搜索图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#44、属于mysql流程控制（case-when）-1"><span class="nav-number">129.</span> <span class="nav-text">44、属于mysql流程控制（case when）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#45、Java-Set中对象特点-1"><span class="nav-number">130.</span> <span class="nav-text">45、Java Set中对象特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46、原型模式的本质-1"><span class="nav-number">131.</span> <span class="nav-text">46、原型模式的本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#47、折半查找条件-1"><span class="nav-number">132.</span> <span class="nav-text">47、折半查找条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#48、DAG-DFS-1"><span class="nav-number">133.</span> <span class="nav-text">48、DAG/DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#49、简述java-web-中getAttribute-和getParameter-1"><span class="nav-number">134.</span> <span class="nav-text">49、简述java web 中getAttribute()和getParameter()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#50、返回第一次匹配字符串位置-1"><span class="nav-number">135.</span> <span class="nav-text">50、返回第一次匹配字符串位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#51、100，随机10组，每组10个，数字1和数字2分到同一组概率-1"><span class="nav-number">136.</span> <span class="nav-text">51、100，随机10组，每组10个，数字1和数字2分到同一组概率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#52、链表法解决冲突-1"><span class="nav-number">137.</span> <span class="nav-text">52、链表法解决冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53、TTL字段-1"><span class="nav-number">138.</span> <span class="nav-text">53、TTL字段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#54、输入正整数n，d，n为字符串，n的子串被d整除的个数-1"><span class="nav-number">138.1.</span> <span class="nav-text">54、输入正整数n，d，n为字符串，n的子串被d整除的个数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#55、可被多个线程共享（data-section-file-fd）-1"><span class="nav-number">139.</span> <span class="nav-text">55、可被多个线程共享（data section/file fd）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#线程共享的内容-1"><span class="nav-number">139.1.</span> <span class="nav-text">线程共享的内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程独有的内容包括-1"><span class="nav-number">139.2.</span> <span class="nav-text">线程独有的内容包括</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#56、小顶堆的中序遍历-1"><span class="nav-number">140.</span> <span class="nav-text">56、小顶堆的中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#57、稳定的排序算法-1"><span class="nav-number">141.</span> <span class="nav-text">57、稳定的排序算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#58、结构型设计模式-1"><span class="nav-number">142.</span> <span class="nav-text">58、结构型设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#结构型模式共七种：-1"><span class="nav-number">142.1.</span> <span class="nav-text">结构型模式共七种：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其中又分为-1"><span class="nav-number">142.2.</span> <span class="nav-text">其中又分为</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#59、ICMP协议功能-1"><span class="nav-number">143.</span> <span class="nav-text">59、ICMP协议功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#60、不引起进程阻塞-1"><span class="nav-number">144.</span> <span class="nav-text">60、不引起进程阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#61、稳定且平均时间复杂度最优算法-归并排序-1"><span class="nav-number">145.</span> <span class="nav-text">61、稳定且平均时间复杂度最优算法(归并排序)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#62、二分查找（顺序）-1"><span class="nav-number">146.</span> <span class="nav-text">62、二分查找（顺序）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#63、地址传递-1"><span class="nav-number">147.</span> <span class="nav-text">63、地址传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64、Linux改变文件所有者命令：chown-1"><span class="nav-number">148.</span> <span class="nav-text">64、Linux改变文件所有者命令：chown</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#65、byte-b-0x175-1"><span class="nav-number">149.</span> <span class="nav-text">65、byte b=0x175</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#66、逻辑短路运算符-1"><span class="nav-number">150.</span> <span class="nav-text">66、逻辑短路运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#67、Map的value可以是list或Map（true）-1"><span class="nav-number">151.</span> <span class="nav-text">67、Map的value可以是list或Map（true）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#68、js变量默认值：undefined-1"><span class="nav-number">152.</span> <span class="nav-text">68、js变量默认值：undefined</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#69、jdk核心源码：src目录（true）-1"><span class="nav-number">153.</span> <span class="nav-text">69、jdk核心源码：src目录（true）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#70、分支覆盖测试用例-1"><span class="nav-number">154.</span> <span class="nav-text">70、分支覆盖测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#71、冒烟测试-1"><span class="nav-number">155.</span> <span class="nav-text">71、冒烟测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#72、HTTP服务器端错误-1"><span class="nav-number">156.</span> <span class="nav-text">72、HTTP服务器端错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#73、Linux强制删除非空目录-1"><span class="nav-number">157.</span> <span class="nav-text">73、Linux强制删除非空目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#74、TCP拥塞控制方法-1"><span class="nav-number">158.</span> <span class="nav-text">74、TCP拥塞控制方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#75、二分查找and二叉排序树（对于有序序列，非递归时度-lt-递归）-1"><span class="nav-number">159.</span> <span class="nav-text">75、二分查找and二叉排序树（对于有序序列，非递归时度&lt;递归）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#76、sleep-wait-1"><span class="nav-number">160.</span> <span class="nav-text">76、sleep()/wait()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#77、防止死锁发生-1"><span class="nav-number">161.</span> <span class="nav-text">77、防止死锁发生</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#78、Python类、操作、属性（-add）-1"><span class="nav-number">162.</span> <span class="nav-text">78、Python类、操作、属性（_add）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#79、shell脚本输出-1"><span class="nav-number">163.</span> <span class="nav-text">79、shell脚本输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#80、不能用来修饰interface-1"><span class="nav-number">164.</span> <span class="nav-text">80、不能用来修饰interface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#81、分时操作系统，进程调度采用“时间片轮转”-true-1"><span class="nav-number">165.</span> <span class="nav-text">81、分时操作系统，进程调度采用“时间片轮转”(true)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#82、ROM中存放的信息在计算机断电后内容（不会丢失）-1"><span class="nav-number">166.</span> <span class="nav-text">82、ROM中存放的信息在计算机断电后内容（不会丢失）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#83、in-interval-0-11-1"><span class="nav-number">167.</span> <span class="nav-text">83、in interval(0,11)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#84、处理外部中断时，应该由操作系统保存（程序计数器PC）-1"><span class="nav-number">168.</span> <span class="nav-text">84、处理外部中断时，应该由操作系统保存（程序计数器PC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#85、在jsp可以操作cookie-jsp在浏览器的执行是单线程的-1"><span class="nav-number">169.</span> <span class="nav-text">85、在jsp可以操作cookie/jsp在浏览器的执行是单线程的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#86、微型计算机的cache是（高速缓冲存储器）-1"><span class="nav-number">170.</span> <span class="nav-text">86、微型计算机的cache是（高速缓冲存储器）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#87、最速下降法-1"><span class="nav-number">171.</span> <span class="nav-text">87、最速下降法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#88、发货功能测试用例-1"><span class="nav-number">172.</span> <span class="nav-text">88、发货功能测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#89、双向链表定义-1"><span class="nav-number">173.</span> <span class="nav-text">89、双向链表定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#90、词法分析阶段错误-1"><span class="nav-number">174.</span> <span class="nav-text">90、词法分析阶段错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#91、序列安全（银行家算法）-1"><span class="nav-number">175.</span> <span class="nav-text">91、序列安全（银行家算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#92、？？-1"><span class="nav-number">176.</span> <span class="nav-text">92、？？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#93、变量在内存中的存储位置-1"><span class="nav-number">177.</span> <span class="nav-text">93、变量在内存中的存储位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#94、进程通信-进程同步-1"><span class="nav-number">178.</span> <span class="nav-text">94、进程通信/进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程通信方式-1"><span class="nav-number">178.1.</span> <span class="nav-text">进程通信方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程同步的四种方法-1"><span class="nav-number">178.2.</span> <span class="nav-text">进程同步的四种方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#95、网络服务接口，Linux-1"><span class="nav-number">179.</span> <span class="nav-text">95、网络服务接口，Linux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#96、匹配输出log文件中第5行的数字并由小到大排序-1"><span class="nav-number">180.</span> <span class="nav-text">96、匹配输出log文件中第5行的数字并由小到大排序</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
<div id="music163player">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=477786576&auto=0&height=32"></iframe>
</div>

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">十点一刻</span>

  
</div>








<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">全站共216.7k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  




<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


</body>
</html>
