<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="操作系统是配置在计算机硬件的第一层软件，是对硬件系统的首次扩充。其主要作用是管理设备，提高设备的利用率和系统的吞吐量 操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合 &amp;lt; !–more–&amp;gt; 操作系统的目标：1、方便性：编译将高级语言翻译成机器代码2、有效性：提高系统资源的利用率和提高系统的吞吐量3、可扩充性：适应计算机硬件、体">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://yoursite.com/2017/06/14/操作系统/index.html">
<meta property="og:site_name" content="Welcome">
<meta property="og:description" content="操作系统是配置在计算机硬件的第一层软件，是对硬件系统的首次扩充。其主要作用是管理设备，提高设备的利用率和系统的吞吐量 操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合 &amp;lt; !–more–&amp;gt; 操作系统的目标：1、方便性：编译将高级语言翻译成机器代码2、有效性：提高系统资源的利用率和提高系统的吞吐量3、可扩充性：适应计算机硬件、体">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-08-17T16:27:03.649Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统">
<meta name="twitter:description" content="操作系统是配置在计算机硬件的第一层软件，是对硬件系统的首次扩充。其主要作用是管理设备，提高设备的利用率和系统的吞吐量 操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合 &amp;lt; !–more–&amp;gt; 操作系统的目标：1、方便性：编译将高级语言翻译成机器代码2、有效性：提高系统资源的利用率和提高系统的吞吐量3、可扩充性：适应计算机硬件、体">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/14/操作系统/"/>





  <title>操作系统 | Welcome</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Welcome</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  
  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  

  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/14/操作系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="十点一刻">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/qifang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-14T08:59:48+08:00">
                2017-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>操作系统是配置在计算机硬件的第一层软件，是对硬件系统的首次扩充。其主要作用是管理设备，提高设备的利用率和系统的吞吐量</p>
<p>操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合</p>
<p>&lt; !–more–&gt;</p>
<p>操作系统的目标：<br>1、方便性：编译将高级语言翻译成机器代码<br>2、有效性：提高系统资源的利用率和提高系统的吞吐量<br>3、可扩充性：适应计算机硬件、体系结构以及计算机应用发展的要求<br>4、开放性：彼此兼容，实现互连</p>
<p>操作系统的作用：<br>1、OS作为用户与计算机硬件系统之间的接口<br>方式：⑴命令<br>⑵系统调用<br>⑶图标-窗口<br>2、OS作为计算机系统资源的管理者<br>资源类型：⑴处理机<br>⑵存储器<br>⑶I/O设备<br>⑷文件（数据、程序）<br>3、OS实现了对计算机资源的抽象<br>        含义：利用数据结构及操作命令来进行数据输入或输出，无需关心具体实现</p>
<p>推动操作系统发展的主要动力：<br>1、不断提高计算机资源利用率（昂贵，但利用率不高）<br>2、方便用户（上机调试程序不方便）<br>3、器件的不断更新换代<br>4、计算机体系结构的不断发展<br>5、不断提出新的应用需求</p>
<p>操作系统的发展过程<br>1、    未配置操作系统的计算机系统<br>1)    人工操作方式<br>缺点：①用户独占全机<br>②CPU等待人工操作<br>2)    脱机输入/输出方式Off-Line I/O<br>含义：在脱离主机的情况下进行的<br>反义：联机输入输出（在主机的直接控制下进行输入/输出的方式）<br>优点：①减少了CPU的空闲时间<br>②提高了I/O速度<br>2、    单道批处理系统<br>含义：把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序，在它的控制下，使这批作业能一个接一个地连续处理<br>局限性：虽然系统对作业的处理是成批进行的，但在内存中始终只保持一道作业<br>缺点: 系统中的资源得不到充分的利用<br>3、    多道批处理系统<br>含义：作业存放在外存，并排成一个队列（后备队列），共享CPU和系统资源<br>        优缺点：⑴资源利用率高<br>                ⑵系统吞吐量大：①CPU和其他资源保持“忙碌”状态<br>②系统开销小<br>                ⑶平均周转时间长<br>                ⑷无交互能力<br>        需解决的问题：⑴处理机争用问题<br>                      ⑵内存分配和保护问题<br>⑶I/O设备分配问题<br>                      ⑷文件的组织和管理问题<br>⑸作业管理问题<br>⑹用户与系统的接口问题<br>4、分时系统<br>    用户的需求：⑴人-机交互（方便进行修改）<br>⑵共享主机（昂贵，共享资源）<br>    问题解决方法：⑴及时接收：多路卡（实现分时多路复用）<br>                    ⑵及时处理：①作业直接进入主存<br>②采用轮转运行方式（每个作业每次只能运行一个时间片）<br>    特征：⑴多路性（运行多个用户共享一台计算机）<br>          ⑵独立性（彼此之间互不干扰）<br>          ⑶及时性（用户请求在短时间得到响应）<br>          ⑷交互性（人机对话）<br>5、实时系统：<br>实时系统的定义：系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行<br>实时系统的类型：⑴工业（武器）控制系统<br>                    ⑵信息查询系统<br>                    ⑶多媒体系统<br>                    ⑷嵌入式系统<br>实时任务的类型：⑴周期性实时任务（按周期循环执行）<br>                    ⑵非周期性实时任务<br>最后期限：①开始截止时间（某任务在某时间以前必须开始执行）<br>②完成截止时间（某任务在某时间以前必须完成）<br>⑶硬实时任务（系统必须满足任务对截止时间的要求）<br>⑷软实时任务<br>    实时系统特征：⑴多路性<br>                  ⑵独立性（彼此之间互不干扰）<br>                  ⑶及时性<br>                  ⑷交互性（立即响应）<br>                    ⑸可靠性（要求系统高度可靠）<br>6、微机操作系统的发展：<br>⑴单用户单任务操作系统<br>含义：只允许一个用户上机，且只允许用户程序作为一个任务运行<br>代表性操作系统：①CP/M（8位）<br>②MS-DOS（16位）<br>⑵单用户多任务操作系统：<br>含义：只允许一个用户上机，但允许用户把程序分为若干个任务，使它们并发执行<br>代表性操作系统：Windows<br>⑶多用户多任务操作系统：UNIX OS</p>
<p>操作系统的基本特性：<br>1、    并发<br>⑴    并行性：两个或多个事件在同一时刻发生<br>⑵    并发性：两个或多个事件在同一时间间隔内发生<br>⑶    进程：在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、<br>数据和堆栈等组成的，是一个能独立运行的活动实体<br>2、    共享（复用，指系统中的资源可供内存中多个并发执行的进程共同使用）<br>⑴    互斥共享方式：在一段时间内，只允许一个进程访问该资源<br>⑵    同时访问方式：允许在一段时间内由多个进程“同时”对资源进行访问<br>3、    虚拟（将一条物理信道变为若干条逻辑信道）<br>⑴    时分复用技术（利用处理机的空闲时间）<br>①    虚拟处理机技术<br>②    虚拟设备技术<br>⑵    空分复用技术（利用存储器的空闲空间）<br>①    空分复用存储器：提高内存的利用率<br>②    虚拟存储技术：实现内存的分时复用<br>4、    异步（停停走走，进程是以人们不可预知的速度向前推进的）</p>
<p>临界资源（独占资源）：在一段时间内只允许一个进程访问的资源</p>
<p>操作系统的主要功能：<br>1、    处理机管理功能<br>⑴    进程控制：创建和撤销进程，以及进程的状态转换<br>⑵    进程同步：对诸进程的运行进行协调<br>①进程互斥方式（临界资源）<br>②进程同步方式（共同任务）<br>⑶    进程通信：实现进程之间的信息交换<br>⑷    调度：按照一定的算法把处理机分配给进程<br>①作业调度<br>②进程调度<br>2、    存储器管理功能<br>⑴    内存分配<br>1)    任务：①为每道程序分配内存空间<br>②提高存储器的利用率<br>③允许正在运行的程序申请附加的内存空间<br>2)    方式：①静态分配方式<br>②动态分配方式<br>⑵    内存保护（设置内存保护机制）<br>任务：①确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰<br>②绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行<br>⑶    地址映射<br>⑷    内存扩充<br>实现功能：①请求调入功能<br>          ②置换功能<br>3、设备管理功能<br>⑴缓冲管理（缓和CPU和I/O设备速度不匹配的矛盾）<br>    缓冲区机制：①单缓冲机制<br>②能实现双向同时传送数据的双缓冲机制<br>③能供多个设备同时使用的公用缓冲池机制<br>⑵设备分配<br>⑶设备处理<br>4、文件管理功能<br>⑴文件存储空间的管理：为每个文件分配必要的外存空间<br>⑵目录管理：为每个文件建立一个目录项<br>⑶文件的读/写管理和保护<br>a)    文件的读/写管理：合用一个读/写指针<br>b)    文件保护：①防止未经核准的用户存取文件<br>②防止冒名顶替存取文件<br>③防止以不正确的方式使用文件</p>
<p>操作系统与用户之间的接口：<br>⑴用户接口<br>①联机用户接口<br>②脱机用户接口<br>③图形用户接口<br>⑵程序接口（系统调用子程序）</p>
<p>现代操作系统的新功能：<br>⑴系统安全<br>①    认证技术：确定对象的真实性<br>②    密码技术：对系统所需存储和传输的数据进行加密<br>③    访问控制技术：<br>i.    对用户存取权限的设置<br>ii.    对文件属性的设置<br>④    反病毒技术：反病毒软件<br>⑵网络的功能和服务<br>A.    网络通信：实现无差别错的数据传输<br>B.    资源管理：保证数据的安全性和一致性<br>C.    应用互操作：实现信息的互通性和信息的互用性<br>⑶支持多媒体<br>a)    接纳控制功能<br>b)    实时调度<br>c)    多媒体文件的存储</p>
<p>OS结构：<br>1、传统操作系统结构<br>⑴无结构操作系统：每个过程可以任意地相互调用其他过程<br>⑵模块化结构OS：“分解”、“模块化”、模块-接口法<br>⑶分层化结构OS：有序分层法<br>2、微内核OS结构（现代OS）：<br>    ⑴描述：①足够小的内核：实现现代OS最基本核心功能<br>②基于客户/服务器模式<br>③应用“机制与策略分离”原理<br>④采用面向对象技术<br>    ⑵功能：①进程（线程）管理<br>②低级存储器管理<br>③中断和陷入处理<br>    ⑶优点：①提高了系统的可扩展性<br>②增强了系统的可靠性<br>③可移植性强<br>④提供了对分布式系统的支持<br>⑤融入了面向对象技术</p>
<p>前趋图：描述进程之间执行的先后顺序，有向无循环图DAG，结点表示进程或程序段，有向边表示存在的偏序或前趋关系</p>
<p>如果进程Pi和Pj存在着前趋关系，表示Pj开始执行之前Pi必须完成</p>
<p>初始结点：没有前趋的结点<br>终止结点：没有后继的结点<br>每个结点具有一个重量，用于表示该结点所含有的程序量或程序的执行时间</p>
<p>前趋图不允许有循环</p>
<p>程序顺序执行时的特征<br>⑴顺序性：每一操作必须在下一个操作开始之前结束<br>⑵封闭性：程序运行时独占全机资源<br>⑶可再现性：程序重复执行，获得相同结果</p>
<p>程序并发执行时的特征：<br>⑴间断性：并发执行的程序之间形成了相互制约，相互制约将导致并发程序具有“执行—暂停—执行”这种间断性的活动规律<br>⑵失去封闭性：资源共享。当任一程序运行，其环境必然受到其他程序的影响<br>⑶不可再现性：失去可再现性，得到的结果却各不相同</p>
<p>进程：为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制<br>进程控制块PCB：为使参与并发执行的每个程序（含数据）都能独立地运行，操作系统配置的专门的数据结构。描述进程的基本情况和活动过程，进而控制和管理进程<br>进程（进程实体、进程映像）：程序段、相关的数据段和PCB<br>创建（撤销）进程：创建（撤销）进程实体中的PCB</p>
<p>进程<br>⑴定义：①进程是程序的一次执行<br>②进程是一个程序及其数据在处理机上顺序执行时所发生的活动<br>③进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位<br>④进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位<br>（传统OS定义）<br>⑵特征：①动态性：由创建而产生，由调度而执行，由撤销而消亡<br>        ②并发性：多个进程实体同存于内存中，且能在一段时间内同时运行<br>        ③独立性：独立运行、独立获得资源、独立接受调度<br>        ④异步性：按各自独立的、不可预知的速度向前推进<br>⑶基本状态：①就绪：进程已分配到除CPU以外的所有必要资源<br>②执行：进程已获得CPU，其程序正在执行<br>③阻塞：进程的执行受到阻塞</p>
<p>⑷切换：①就绪-&gt;执行：调度程序分配了处理机<br>②执行-&gt;就绪：时间片已完<br>③执行-&gt;阻塞：I/O请求（发生某事件）</p>
<p>创建状态：进程所需的资源得不到满足，系统无足够的内存<br>终止状态：进程到达自然结束点，出现无法克服的错误，被操作系统终结。进入终止态的进程以后不能再执行</p>
<p>创建进程的过程：首先向进程申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所需要的资源；最后，把该进程转入就绪状态并插入就绪状态并插入就绪队列之中<br>终止进程的步骤：等待操作系统进行善后处理，最后将其PCB清零，并将PCB空间返还系统</p>
<p>挂起：此时该进程处于静止状态<br>引入挂起操作的原因：①终端用户的需要：以便用户研究其执行情况或对程序进行修改<br>②父进程请求：考查和修改该子进程，或协调各子进程之间的活动<br>③负荷调节的需要：以保证系统能正常进行<br>④操作系统的需要：检查运行中的资源使用情况或进行记账</p>
<p>活动就绪：此时进程可以接受调度<br>静止就绪：进程不再被调度执行<br>活动阻塞：进程处于未被挂起的阻塞状态<br>静止阻塞-&gt;静止就绪：出现其所期待的事情后</p>
<p>挂起原语：Suspend<br>激活原语：Active</p>
<p>记录和查询各种资源的使用及各类进程运行情况的信息</p>
<p>进程信息表（资源信息表）：包含了资源或进程的标识、描述、状态等信息以及一批指针<br>数据结构：①内存表<br>②设备表<br>③文件表<br>④用于进程管理的进程表</p>
<p>PCB（记录型数据结构）的作用：<br>①作为独立运行基本单位的标志：系统通过PCB感知进程的存在<br>②能实现间断性运行方式：PCB可保存恢复CPU现场信息<br>③提供进程管理所需要的信息：操作系统根据PCB实施对进程的控制和管理<br>④提供进程调度所需要的信息：PCB提供了进程处于何种状态的信息<br>⑤实现与其他进程的同步与通信：PCB具有用于实现进程通信的区域或通信队列指针</p>
<p>进程控制块中的信息：<br>进程标识符（唯一地标识一个进程）：<br>①外部标识符：父进程标识、子进程标识、用户标识<br>②内部标识符：赋予每一个进程一个唯一的数字标识符</p>
<p>处理机状态：①通用寄存器（用户可视寄存器）：暂存信息<br>②指令计数器：存放要访问的下一条指令的地址<br>③程序状态字PSW：状态信息（条件码、执行方式、中断屏蔽标志）<br>④用户栈指针：存放过程和系统调用参数及调用地址<br>进程调度信息：①进程状态：进程的当前状态<br>②进程优先级：进程使用处理机的优先级别<br>③进程调度所需的其他信息：与所采用的进程调度算法有关<br>④事件：阻塞原因<br>进程控制信息：①程序和数据的地址<br>②进程同步和通信机制<br>③资源清单：在运行期间所需的资源和已分配到该进程的资源的清单<br>④链接指针：本进程PCB所在队列的下一个进程PCB的首地址<br>PCB的组成方式：<br>①线性方式：系统的所有PCB组织的一张线性表<br>②链接方式：把具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列<br>③索引方式：系统根据所有进程状态的不同建立的索引表，每张索引表表目记录具有相应状态的某个PCB在PCB表中的地址</p>
<p>进程控制一般是由OS的内核中的原语来实现的</p>
<p>OS内核安排在紧靠硬件的软件层次的目的：<br>⑴便于对其进行保护<br>⑵提高OS的运行效率</p>
<p>处理机的执行状态：①系统态、管态、内核态：能执行一切指令，访问所有寄存器和存储区<br>②用户态（目态）：仅能执行规定的指令，访问指定的寄存器和存储区</p>
<p>OS内核功能：<br>⑴支撑功能：①中断处理（最基本）<br>②时钟管理<br>③原语操作：原语在执行过程中不允许被中断<br>⑵资源管理功能：①进程管理<br>②存储器管理<br>③设备管理</p>
<p>应用程序只能在用户态运行，防止应用程序对OS的破坏<br>原子操作在系统态下执行，常驻内存</p>
<p>父进程：创建进程的进程<br>子进程：被创建的进程</p>
<p>进程图：用于描述进程间关系的一棵有向树，树的根结点是进程家族的祖先</p>
<p>导致一个进程创建另一个进程的事件：①用户登录<br>②作业调度<br>③提供服务<br>④应用请求</p>
<p>创建新进程：①申请空白PCB<br>②为新进程分配其运行所需的资源<br>③初始化进程控制块PCB：<br>i.    初始化标识信息<br>ii.    处理机状态信息<br>iii.    处理机控制信息<br>④当能接纳，将新进程插入就绪队列</p>
<p>引起进程终止的事件：<br>⑴正常结束：有一个用于表示进程已经运行完成的指示<br>⑵异常结束：进程在运行时发生了某种异常事件，使程序无法继续运行<br>①越界错：越出该进程的区域<br>②保护错：进程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问<br>③非法指令：程序试图去执行一条不存在的指令<br>④特权指令错：指用户进程试图去执行一条只允许OS执行的指令<br>⑤运行超时：指进程的执行时间超过了指定的最大值<br>⑥等待超时：指进程等待某事件的时间超过了规定的最大值<br>⑦算术运算错：进程试图去执行一个被禁止的运算<br>⑧I/O故障：在I/O过程中发生错误<br>⑶外界干预：进程应外界的请求而终止运行<br>①操作员或操作系统干预<br>②父进程请求结束子进程<br>③在终止父进程时，终止所有子孙进程</p>
<p>进程的终止过程<br>①根据标识符，从PCB集合中检索出被终止进程的PCB，从中读出该进程的状态<br>②若处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度<br>③终止所有子孙进程<br>④将所终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统<br>⑤将被终止进程PCB从所在队列（或链表）中移出，等待其他程序来搜集信息</p>
<p>引起进程阻塞和唤醒的事件<br>①向系统请求共享资源失败<br>②等待某种操作的完成<br>③新数据尚未到达<br>④等待新任务的到达</p>
<p>阻塞是进程自身的一种主动行为</p>
<p>进程同步机制的主要任务：是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好地相互合作，从而使程序的执行具有可再现性</p>
<p>多个进程并发时可能存在的制约关系：<br>⑴间接相互制约关系：①多个进程对临界资源只能互斥地访问<br>②资源由系统实施统一分配<br>⑵直接相互制约关系：为完成同一项任务而相互合作</p>
<p>异步性会发生“与时间有关的错误”，为杜绝，需对进程的执行次序进行协调，保证诸进程能按序执行</p>
<p>临界区：每个进程中访问临界资源的那段代码</p>
<p>同步机制应遵循的规则：①空闲让进<br>②忙则等待：以保证对临界资源的互斥访问<br>③有限等待：应保证在有限时间内能进入自己的临界区<br>④让权等待：若不能进入临界区，释放处理机</p>
<p>硬件同步机制<br>⑴关中断：<br>i.    方法：在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断<br>ii.    缺点：①滥用关中断权利可能导致严重后果<br>②关中断时间过长，会影响系统效率<br>③不适用多CPU系统<br>⑵利用Test-and-Set指令实现互斥：“测试并建立”<br>⑶利用Swap指令实现进程互斥：为每个临界资源设置一个全局的布尔变量lock</p>
<p>信号量机制<br>⑴整型信号量：wait(S)和signal(S)[原子操作]<br>1)    wait(S){<br>while(S&lt;=0);<br>S–;<br>}<br>2)    signal(S){<br>S++;<br>}<br>⑵记录型信号量<br>A.    S-&gt;value的初值表示系统中某类资源的数目（资源信号量）<br>B.    S-&gt;value&lt;0，表示该类资源已分配完毕<br>⑶AND信号量：将进程在整个运行过程中需要的所有资源，一次性全部的分配给进程，待进程使用完后再一起释放<br>⑷信号量集：当进程申请某类临界资源时，在每次分配之前，都必须测试资源的数量，判断是否大于可分配的下限值，决定是否予以分配<br>信号量的应用<br>⑴利用信号量实现进程互斥<br>    互斥信号量mutex<br>    wait：资源此刻未被访问，操作成功<br>    signal：释放该临界资源<br>⑵利用信号量实现前趋关系<br>    公用信号量S<br>    signal放在S1后面，wait插在S2前面</p>
<p>信号量机制的每个要访问临界资源的进程都必须自备同步操作</p>
<p>管程：<br>⑴定义：①用少量信息和对该资源所执行的操作来表征该资源，而忽略它们内部结构和实现细节<br>②代表共享资源的数据结构以及对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块<br>③一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据<br>⑵组成：①管程的名称<br>②局部于管程的共享数据结构说明<br>③对该数据结构进行操作的一组过程<br>④对局部于管程的共享数据设置初始值的语句<br>⑶特性：①模块化：管程是一个基本程序单位，可以单独编译<br>②抽象数据类型：数据，和对数据的操作<br>③信息隐蔽：管程中的数据结构只能被管程中的过程访问，具体实现外部不可见</p>
<p>所有进程要访问临界资源时，都只能通过管程间接访问，而管程每次只准许一个进程进入管程，执行管程内的过程，从而实现了进程互斥</p>
<p>进程通信：进程之间的信息交换</p>
<p>高级通信工具的特点：①使用方便<br>②高效地传送大量数据</p>
<p>进程通信的类型：<br>⑴共享存储器系统<br>①基于共享数据结构的通信方式<br>②基于共享存储区的通信方式<br>⑵管道通信系统<br>    ①管道：用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件<br>②协调能力：<br>i.    互斥<br>ii.    同步<br>iii.    确定对方是否存在<br>⑶消息传递系统（使通信过程对用户透明化）<br>①直接通信方式：OS的发送原语<br>②间接通信方式：共享中间实体<br>⑷客户机、服务器系统<br>①套接字<br>i.    基于文件型<br>ii.    基于网络型<br>②远程过程调用和远程方法调用<br>i.    本地客户进程<br>ii.    远程服务器进程</p>
<p>消息传递通信的实现方式<br>⑴直接消息传递系统：<br>①直接通信原语<br>i.    对称寻址方式：不利于实现进程定义的模块化<br>ii.    非对称寻址方式：无法事先指定发送进程<br>②消息的格式：比较短的定长消息格式<br>③进程的同步方式<br>④通信链路<br>i.    单向通信链路<br>ii.    双向通信链路<br>⑵信箱通信：进程之间的通信<br>①信箱的结构：<br>i.    信箱头：存放有关信箱的描述信息<br>ii.    信箱体：若干个可以存放消息（头）的信箱格组成<br>②信箱通信原语：<br>i.    邮箱的创建和撤销<br>ii.    消息的发送和接收<br>③信箱的类型：<br>i.    私用信箱：用户<br>ii.    公用信箱：操作系统<br>iii.    共享信箱：进程</p>
<p>发送进程和接收进程之间的关系：①一对一关系<br>                              ②多对一关系<br>                              ③一对多关系<br>                              ④多对多关系</p>
<p>引入线程的原因：为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性</p>
<p>程序并发执行所需付出的时空开销：①创建进程<br>②撤销进程<br>③进程切换</p>
<p>线程：作为调度和分派的基本单位，轻型进程<br>⑴调度的基本单位：在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然就会引起进程的切换<br>⑵并发性：允许在一个进程中的所有线程都能并发执行<br>⑶拥有资源：线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源<br>⑷独立性：在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多<br>⑸系统开销：线程的切换、同步和通信都无需操作系统内核的干预<br>⑹支持多处理机系统：对于多线程进程，可以将一个进程的多个线程分配到多个处理机上</p>
<p>线程的基本状态：执行、就绪、阻塞</p>
<p>线程控制块TCB：线程标识符、一组寄存器、线程运行状态、优先级、线程专有存储区、信号屏蔽、堆栈指针</p>
<p>多线程OS中的进程属性：⑴进程是一个可拥有资源的基本单位<br>⑵多个进程可并发执行<br>⑶进程已不是可执行的实体</p>
<p>线程的实现方式：<br>⑴内核支持线程KST：为每一个内核线程设置了一个线程控制块<br>⑵用户级线程ULT：每个线程轮流执行一个时间片</p>
<p>调度的实质是一种资源分配，处理机调度室对处理机资源进行分配</p>
<p>处理机调度的层次：<br>①高级调度（长程调度、作业调度）：调度对象是作业，主要用于多道批处理系统<br>②低级调度（进程调度、短程调度）：所调度的对象是进程（或内核级线程）<br>③中级调度（内存调度，目的是提供内存利用率和系统吞吐量）：存储器管理的对换功能</p>
<p>进程调度的运行频率最高，作业调度算法花费较多时间</p>
<p>处理机调度算法的共同目标：①资源利用率：使处理机和其他资源尽可能保持忙碌状态<br>②公平性：应使诸进程都获得合理的CPU时间，不会发生进程饥饿现象<br>③平衡性：保持系统资源使用的平衡性<br>④策略强制执行：只要需要，就必须予以准确地执行</p>
<p>批处理系统的目标：①平均周转时间短：<br>i.    作业在外存后备队列上等待（作业调度）的时间<br>ii.    进程在就绪队列上等待进程调度的时间<br>iii.    进程在CPU上执行的时间<br>iv.    进程等待I/O操作完成的时间<br>②系统吞吐量高<br>③处理机利用率高：单纯为使处理机利用率高，尽量多选择计算量大的作业运行</p>
<p>周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔<br>带权周转时间：作业的周转时间T与系统为它提供服务的时间Ts之比（W=T/Ts）<br>吞吐量：在单位时间内系统所完成的作业数</p>
<p>分时系统的目标：①响应时间快<br>②均衡性<br>实时系统的目标：①截止时间的保证<br>②可预测性</p>
<p>响应时间：从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为止的一段时间间隔<br>均衡性：系统响应时间的快慢应与用户所请求服务的复杂性相适应<br>截止时间：某任务必须开始执行的最迟时间，或必须完成的最迟时间</p>
<p>作业：程序、数据，作业说明书<br>作业步：每一个加工步骤称为一个作业步，各作业步之间存在着相互联系<br>作业控制块JCB：作业在系统中存在的标志<br>1)    作业标识<br>2)    用户名称<br>3)    用户账号<br>4)    作业类型<br>5)    作业状态<br>6)    调度信息<br>7)    资源需求<br>8)    资源使用情况</p>
<p>作业运行的三个阶段三个状态：<br>⑴收容阶段（后备状态）：为作业建立JCB，放入后备队列<br>⑵运行阶段（运行状态）：分配必要的资源和建立进程<br>⑶完成阶段（完成状态）：运行完成或者异常结束</p>
<p>作业调度的主要任务：<br>根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度</p>
<p>被称为接纳调度需作出的决定：<br>①接纳多少个作业：允许多少个作业同时在内存中运行<br>②接纳哪些作业：取决于所采用的调度算法<br>作业调度算法：<br>⑴先来先服务FCFS：①按照作业到达的先后次序来进行调度<br>②优先考虑在系统中等待时间最长的作业<br>⑵短作业优先SJF：<br>1)    定义：作业越短，其优先级越高<br>2)    缺点：①必须预知作业的运行时间。一般会偏长估计<br>              ②对长作业非常不利。可能使作业等待时间过长，出现饥饿现象<br>              ③人–机无法实现交互<br>              ④不能保证紧迫性作业能得到及时处理<br>⑶优先级调度算法PSA：基于作业的紧迫程度，由外部赋予作业相应的优先级<br>⑷高响应比优先调度算法HRRN：既考虑了作业的等待时间，又考虑作业运行时间的调度算法<br>响应比Rp=等待+要求服务时间/要求服务时间=响应时间/要求服务时间</p>
<p>进程调度的任务：<br>⑴保存处理机的现场信息<br>⑵按某种算法选取进程<br>⑶把处理器分配给进程</p>
<p>进程调度机制：<br>⑴排队器：为提高进程调度的效率，事先将系统中的所有就绪进程按照一定的策略排成一个或多个队列<br>⑵分派器：将处理机分配给新选出的进程<br>⑶上下文切换器：两对上下文切换</p>
<p>减少上下文切换：采用两组寄存器，一组寄存器供处理机在系统态使用，另一组供应用程序使用</p>
<p>进程调度方式<br>⑴非抢占方式<br>①定义：一旦把处理机分配给某进程后，就一直让它运行下去<br>②优点：实现简单，系统开销小<br>⑵抢占方式：<br>①定义：允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程<br>②抢占原则<br>i.    优先权原则<br>ii.    短进程优先原则<br>iii.    时间片原则</p>
<p>进程调度算法：<br>⑴轮转调度算法RR：让就绪队列上的每个进程每次仅运行一个时间片，每个一定时间间隔产生一次中断，一个时间片大小是略大于一次典型的交互所需要的时间<br>⑵优先级调度算法：把处理机分配给就绪队列中优先级最高的进程<br>    ①调度算法类型：<br>i.    非抢占式优先级调度算法：一直执行下去直至完成<br>ii.    抢占式优先级调度算法：将处理机分配给新到的优先级最高的进程，常用于对<br> 实时性要求较高的系统中<br>    ②优先级类型：<br>i.    静态优先级：<br>1)    含义：在创建进程时确定，在进程的整个运行期间保持不变<br>2)    影响大小的因素：<br>i.    进程类型<br>ii.    进程对资源的需求<br>iii.    用户要求<br>ii.    动态优先级：在创建进程之初，先赋予其一个优先级，其值随进程的推进或等待时间的增长，使其优先级相应提高。可防止一个长作业长期地垄断处理机<br>1)    含义：在创建进程时确定，在进程的整个运行期间保持不变<br>2)    影响大小的因素：<br>i.    进程类型<br>ii.    进程对资源的需求<br>iii.    用户要求<br>⑶多队列调度算法：将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法<br>⑷多级反馈队列调度算法：<br>①调度机制：<br>i.    设置多个就绪队列<br>ii.    每个队列都采用FCFS<br>iii.    按队列优先级调度<br>②算法性能：<br>i.    终端型用户<br>ii.    短批处理作业用户<br>iii.    长批处理作业用户：不必担心其作业长期得不到处理<br>⑸基于公平原则的调度算法：<br>    ①保证调度算法：保证每个进程都获得相同的处理机时间<br>    ②公平分享调度算法：使所有用户能获得相同的处理机时间，或所要求的时间比例，考<br>虑到每一个用户所拥有的进程数目</p>
<p>实现实时调度的基本条件<br>⑴提供必要的信息：①就绪时间：某任务称为就绪状态的起始时间<br>②开始截止时间和完成截止时间<br>③处理时间：一个任务从开始执行，直至完成时所需的时间<br>④资源要求<br>⑤优先级<br>⑵系统处理能力强<br>    提高系统处理能力：①单处理机：减少对每一个任务的处理时间<br>                      ②多处理机：Ci/Pi&lt;=N<br>⑶采用抢占式调度机制<br>⑷具有快速切换机制<br>    应具有的能力：①对中断的快速响应能力：使禁止中断的时间间隔尽量短<br>②快速的任务分派能力</p>
<p>实时调度算法类型：<br>⑴非抢占式调度算法：①非抢占式调度算法：轮转队列<br>                    ②非抢占式优先调度算法：赋予较高的优先级<br>⑵抢占式调度算法：①基于时钟中断的抢占式优先级调度算法<br>②立即抢占的优先级调度算法</p>
<p>实时调度算法：<br>⑴最早截止时间优先EDF算法<br>①定义：根据任务的截止时间确定任务的优先级，任务的截止时间愈早，其优先级愈高<br>②类型：<br>i.    非抢占式调度方式用于非周期实时任务<br>ii.    抢占式调度方式用于周期实时任务<br>⑵最低松弛度优先LLF<br>①定义：任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。<br>②要求：系统中有一个按松弛度排序的实时任务就绪队列<br>③目的：保证不遗漏任何一次截止时间<br>④公式：松弛度=必须完成时间–其本身的运行时间–当前时间</p>
<p>优先级倒置：①定义：高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞<br>②解决方法：<br>i.    简单：假如进程p3在进入临界区后p3所占用的处理机就不允许抢<br> 占<br>ii.    实用：建立在动态优先级继承基础上。当高优先级进程p1要进入<br>临界区，去使用临界资源R，如果已有一个低优先级进程p3正在使用该资源，此时一方面p1被阻塞，另一方面由p3继承p1的优先级，并一直保持到p3退出临界区</p>
<p>引起死锁的主要是临界资源</p>
<p>可重用性资源：①定义：一种可供用户重复使用多次的资源<br>              ②性质：<br>a)    每一个资源单元只能分配给一个进程使用<br>b)    按顺序：请求资源-&gt;使用资源-&gt;释放资源<br>c)    单元数目相对固定，进程在运行期间既不能创建也不能删除</p>
<p>可消耗性资源（临时性资源）：<br>①定义：在进程运行期间，由进程动态地创建和消耗的<br>    ②性质：<br>a)    单元数目可不断变化<br>b)    进程在运行过程中，可以不断地创造可消耗性资源的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目<br>c)    进程在运行过程中，可以请求若干个可消耗性资源单位，用于进程自身的消耗</p>
<p>可消耗性资源通常是由生产者进程创建，由消费者进程消耗，如用于进程间通信的消息</p>
<p>可抢占性资源：某进程在获得这类资源后，该资源可以再被其他进程或系统抢占<br>不可抢占性资源：一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放</p>
<p>死锁的起因：<br>①竞争不可抢占性资源引起死锁：资源数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局<br>②竞争可消耗资源引起死锁：如消息通信机制<br>③进程推进顺序不当引起死锁：对资源进行申请和释放的顺序是否合法</p>
<p>死锁的定义：如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的</p>
<p>产生死锁的必要条件：（必须同时具备）<br>①互斥条件：进程对所分配到的资源进行排它性使用。在一段时间内，某资源只能被一个进程使用<br>②请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求<br>③不可抢占条件：进程已获得的资源在未使用完之前不能被抢占，只能在进程使用完时由自己释放<br>④循环等待条件：在发生死锁时，必然存在一个进程–资源的循环链</p>
<p>处理死锁的方法：（对死锁的防范程度逐渐减弱，资源利用率提高，并发程度提高）<br>①预防死锁：设置某些限制条件，去破坏产生死锁四个必要条件的一个或几个来预防产生死锁<br>②避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态<br>③检测死锁：通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来<br>④解除死锁：撤销一些进程，回收它们的资源，分配给已处于阻塞状态的进程，使其能继续运行</p>
<p>预防死锁：<br>⑴互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证<br>⑵破坏“请求和保持条件”：（当一个进程在请求资源时，不能持有不可抢占资源）<br>    ①第一种协议：<br>1)    定义：所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需<br>的全部资源<br>2)    优点：简单易行安全<br>3)    缺点：资源被严重浪费，严重地恶化了资源的利用率，还会使进程经常会发生<br>饥饿现象<br>②第二种协议：<br>1)    定义：允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中<br>再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源<br>2)    优点：使进程更快地完成任务，提高设备的利用率，还可以减少进程发生饥饿的几<br>率<br>⑶破坏“不可抢占”条件<br>①定义：当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请<br>②缺点：使进程的执行被无限地推迟，延长了进程的周转时间，增加了系统开销，降低了系统的吞吐量<br>⑷破坏“循环等待”条件<br>    ①定义：对系统所有资源类型进行线性排序，并赋予不同的序号，并规定每个进程必须<br>按序号递增的顺序请求资源。例如，进程已请求到一些序号高的资源，又想申<br>请序号低的资源时，必须先释放所有具有相同和更高序号的资源后，才能申请序号低的资源<br>    ②问题：<br>a)    序号必须相对稳定，则限制了新类型设备的增加<br>b)    作业使用各类资源的顺序与系统规定的顺序不同，造成对资源的浪费<br>c)    限制用户简单、自主地编程</p>
<p>避免死锁：在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁</p>
<p>当系统处于安全状态，可避免发生死锁（便不会进入死锁状态）<br>当系统处于不安全状态，则可能进入到死锁状态</p>
<p>避免死锁的实质在于，系统在进行资源分配时，应使系统不进入不安全状态<br>避免死锁的基本思想，确保系统始终保持安全状态</p>
<p>安全状态：系统能按某种进程推进顺序（P1，P2，…  ,Pn）为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成，此时称（P1，P2，…,Pn）为安全序列</p>
<p>最有代表性的避免死锁的算法是Dijkstra的银行家算法。<br>为实现银行家算法，每一个新进程在进入进程时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。系统必须首先确定是否有足够的资源分配给该进程</p>
<p>银行家算法中的数据结构：<br>①可利用资源向量Available：系统可利用的资源，初始值是系统中所配置的该类全部可用资源的数目<br>②最大需求矩阵Max：所有进程对资源的最大需求<br>③分配矩阵Allocation：已分配给每一进程的资源数<br>④需求矩阵Need：每一个进程尚需的各类资源<br>⑤矩阵关系：Need[i-j]=Max[I,j]-Allocation[i,j]</p>
<p>银行家算法：（Request是进程P的请求向量）<br>①Request[j]&lt;=Need[i,j]：判断是否超过最大值<br>②Request[j]&lt;=Available[j]：判断是否能够满足<br>③系统试探着把资源分配给进程，并修改数值：<br>Available[j]= Available[j]- Request[j]<br>Allocation[i,j]= Allocation[i,j]+ Request[j]<br>Need[i,j]= Need[i,j]-Request[j]<br>④系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。</p>
<p>安全性算法：<br>①设置向量：<br>a)    工作向量Work：系统可提供给进程继续执行所需的各类资源数目，最初Work=Available<br>b)    Finish：系统是否有足够的资源分配给进程，使之运行完成，最初Finish[i]=false<br>②找到满足下列条件的进程：<br>a)    Finsh[i]=false<br>b)    Need[i,j]&lt;=Work[j];<br>③进程P获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，执行：<br>a)    Work[j]=Work[j]+Allocation[i,j];<br>b)    Finish[i]=true<br>c)    go to step 2；<br>④假如所有进程的Finish[i]=true都满足，则表示系统处于安全状态</p>
<p>死锁检测对系统的要求：①保存有关资源的请求和分配信息<br>                      ②提供一种算法，它利用这些信息来检测系统是否已进入死锁状态</p>
<p>资源分配图：①圆圈：一个进程<br>            ②方框：一类资源</p>
<p>若能消去图中所有的边，是所有的进程节点都成为孤立结点，则称该图是可完全简化的<br>所有的简化顺序都将得到相同的不可简化图</p>
<p>死锁定理：S为死锁状态的充分条件，当且仅当S状态的资源分配图是不可完全简化的</p>
<p>死锁解除：<br>①简单：立即通知操作员，请操作员来以人工方法处理死锁<br>②利用死锁解除算法：<br>a)    抢占资源：从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态<br>b)    终止（或撤销）进程：<br>I.    终止所有死锁进程：付出代价大<br>II.    逐个终止进程：按照某种顺序，逐个地终止进程，直至有足够的资源，以打破循环等待，把系统从死锁状态中解脱出来为止<br>c)    付出代价最小的死锁解除算法</p>
<p>存储器的主要对象是内存</p>
<p>存储层次：<br>①CPU寄存器：寄存器<br>②主存：高速缓存、主存储器、磁盘缓存<br>③辅存：固定磁盘、可移动存储介质</p>
<p>存储器的要求：①速度快<br>②容量大<br>③价格便宜</p>
<p>操作系统的存储管理范畴：寄存器，高速缓存，主存储器，磁盘缓存<br>（掉电后存储信息不再存在）</p>
<p>可执行存储器：寄存器和主存储器</p>
<p>对辅存的访问需要通过I/O设备实现</p>
<p>操作系统的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制</p>
<p>主存储器（主存、内存）：用于保存进程运行时的程序和数据，访问速度远低于CPU执行指令的速度</p>
<p>寄存器：具有与处理机相同的速度，主要存放处理机运行时的数据，以加速存储器的访问速度</p>
<p>高速缓存：备份主存中较常用的数据，以减少处理机对主存储器的访问次数，缓和内存与处理机速度之间的矛盾</p>
<p>当CPU访问一组特定信息时，须检查它是否在高速缓存，若存在，可避免访问主存</p>
<p>紧靠内存的一级高级缓存的速度最高，而容量最小</p>
<p>磁盘缓存：缓和磁盘的I/O速度和对主存的访问速度。不实际存在的存储器，而是利用主存中的部分存储空间暂时存放从磁盘中读出（或写入）的信息<br>辅存中的数据必须复制到主存方可使用，数据也必须先存在主存，才能输出到辅存</p>
<p>应用程序步骤：<br>①编译：编译程序对源程序进行编译，形成若干个目标模块<br>②链接：链接程序将目标模块和所需的库函数链接，形成一个完整的装入模块<br>③装入：装入程序将装入模块装入内存</p>
<p>装入方式：<br>⑴绝对装入方式：将目标模块装入到内存中事先指定的位置<br>⑵可重定位装入方式：可根据内存的具体情况将装入模块装入到内存的适当位置，不允许程序运行时在内存中移动位置<br>⑶动态运行时的装入方式：装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是将这种地址转换推迟到程序真正要执行时才进行</p>
<p>链接方式：<br>⑴静态链接方式：<br>①定义：在程序执行之前，将各目标模块及它们所需的库函数连接成一个完整的装配模块，以后不再拆开<br>    ②问题：<br>i.    对相对地址进行修改<br>ii.    变换外部调用符号<br>⑵装入时动态链接：<br>①定义：在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块<br>    ②优点：<br>i.    便于修改和更新<br>ii.    便于实现对目标模块的共享<br>⑶运行时动态链接：<br>①定义：将对某些模块的链接推迟到程序执行时才去进行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块，并将之装入内存，将其链接到调用者模块上<br>②优点：<br>I.    加快程序的装入过程<br>II.    节省大量的内存空间</p>
<p>连续分配方式：（程序中代码或数据的逻辑地址相邻，内存空间分配时物理地址的相邻）<br>⑴单一连续分配：系统区、用户区<br>⑵固定分区分配：<br>①定义：每个分区只装入一道作业，不相互干扰<br>    ②方法：<br>I.    分区大小相等：方便实用，小则浪费内存空间，大则不足以装入程序<br>II.    分区大小不等：可根据程序的大小，为之分配适当的分区<br>    ③分区使用表：<br>i.    起始地址<br>ii.    大小<br>iii.    状态<br>⑶动态分区分配（可变分区分配）：根据进程的实际需要，动态地为之分配内存空间<br>    ①数据结构：<br>I.    空闲分区表：分区号、分区大小、分区始址<br>II.    空闲分区链：用于控制分区分配的信息、前向指针、后向指针<br>②分配操作：分配内存-&gt;回收内存</p>
<p>基于顺序搜索的动态分区分配算法：依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区<br>⑴首次适应算法（FF）：<br>    ①要求：空闲分区链以地址递增的次序链接<br>    ②优点：优先利用内存中低址部分的空闲分区，为以后到达的大作业分配大的内存空间<br>创造了条件<br>    ③缺点：低址部分不断被划分，留下很多碎片，且增加查找可用空闲分区时的开销<br>⑵循环首次适应算法（NF）：在为进程分配内存空间时，从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区<br>⑶最佳适应算法（BF）：每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免“大材小用”<br>⑷最坏适应（WF）：<br>①定义：在扫描整个空闲分区表或链表时，总是挑选一个最大的空闲区，从中分割一部分存储空间给作业使用<br>②要求：所有的空闲分区按其容量以从大到小的顺序形成一空闲分区链</p>
<p>基于索引搜索的动态分区分配算法：<br>⑴快速适应算法（分类搜索法）：将空闲分区根据其容量大小进行分类，管理索引表和指针<br>⑵伙伴系统：无论已分配分区或空闲分区，其大小均为2的k次幂<br>⑶哈希算法：以空闲分区大小为关键字的哈希表和表头指针</p>
<p>连续分配方式的特点：一个系统或用户程序必须被装入一片连续的内存空间中</p>
<p>碎片（零头）：不能被利用的小分区</p>
<p>紧凑（拼接）：通过移动内存中作业的位置，把原来多个分散的小分区拼接成一个大分区的方法。</p>
<p>每次“紧凑”后必须对移动了的程序或数据进行重定位</p>
<p>重定位寄存器：存放程序（数据）在内存中的起始地址</p>
<p>地址变换过程是在程序执行期间，随着对每条指令或数据的访问自动进行的，故称为动态重定位</p>
<p>使用可变分区分配方式，分配给每一个进程的内存空间根据进程程序而定。</p>
<p>离散分配：（一个进程直接分散地装入到许多不相邻接的分区）<br>⑴分页存储管理方式：（将用户程序的地址空间分为若干个固定大小的区域）<br>①页面和物理块：<br>I.    页面：内存分配以块为单位<br>II.    页面大小：2的幂，选择适中<br>    ②地址结构：页号P、位移量W<br>    ③页表（页面映像表）：通过查找该表，能找到每页在内存中的物理块号，作用是实现<br>从页号到物理块号的地址映射<br>    ④存取控制字段：用于对该存储块中的内容加以保护<br>⑵分段存储管理方式：（为每个分段分配一个连续的分区）<br>①分段：每一段定义了一组逻辑信息<br>    ②分段地址：段号+段内地址<br>    ③段表：记录该段在内存中的起始地址（基址）和段的长度，实现从逻辑段到物理内存<br>区的映射<br>⑶段页式存储管理方式（同时具备两者的优点。）<br>①定义：将用户程序分成若干段，再把每个段分成若干页，并为每一个段赋予一个段名<br>    ②作业地址空间：主程序段、子程序段和数据段<br>    ③地址结构：段号、段内页号、页内地址<br>④三次访问内存：<br>I.    访问段表，取得页表始址<br>II.    访问页表，取得物理地址<br>III.    取出指令或地址</p>
<p>地址变换机构<br>⑴基本任务：将逻辑地址的页号转换为内存中的物理块号，实现从逻辑地址到物理地址的转换<br>⑵类型：<br>①基本的地址变换机构：设置一个页表寄存器PTR存放页表在内存的始址和页表的长度<br>（CPU每存取一个数据时，两次访问内存）<br>②具有快表的地址变换机构：<br>I.    硬件支持：具有并行查寻能力的联想寄存器（快表）<br>II.    变换过程：由地址变换机构自动的将页号P送入高速缓冲寄存器。未找到则再<br>访问内存</p>
<p>内存的有效访问时间EAT：<br>①定义：从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间）<br>②公式：EAT=a<em>λ +(t+λ)(1-a)+t=2t+λ-t</em>a<br>（λ表示查找快表所需要的时间，a表示命中率，t表示访问一次内存所需要的时间）</p>
<p>命中率：使用快表并在其中成功查找到所需页面的表项的比率</p>
<p>在外层页表的每个页表项中所存放的是某页表分页的首址<br>外层页表寄存器：存放外层页表的始址<br>多级页表：将外层页表再进行分页<br>离散分配空间的办法并未减少页表所占用的内存空间</p>
<p>反置页表：<br>①定义：为每一个物理块设置一个页表项，并将它们按物理块的编号排序<br>②优点：可有效地减少页表占用的内存</p>
<p>引入分段存储管理方式的原因：（为了满足用户程序员在编程和使用上多方面的要求）<br>①方便编程：使程序直观，更具可读性<br>②信息共享：段是信息的逻辑单位，简化了共享的实现<br>③信息保护：每个程序段有不同的保护属性，更有效方便地实现对信息的保护功能<br>④动态增长：数据量、数据段、存储空间动态增加<br>⑤动态链接：以目标程序（即段）作为链接的基本单位</p>
<p>分段和分页的区别：①页是信息的物理单位，段是信息的逻辑单位<br>②页的大小固定且由系统决定，段的长度不固定<br>③分页的用户程序地址属于单一的线性地址空间，而分段的地址空间是二维的，既给出段名，又给出段内地址</p>
<p>分段系统的优点：易于实现段的共享，即允许若干个进程共享一个或多个分段</p>
<p>可重入代码（纯代码）：一种允许多个进程同时访问的代码，不允许任何进程对它进行修改</p>
<p>虚拟存储器：具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。逻辑容量由内存容量和外存容量之和所决定，运行速度接近内存，成本接近外存。既满足用户需要，又改善了系统的性能。</p>
<p>常规存储器管理方式的特征：<br>①一次性：作业必须一次性地全部装入内存后方能开始运行。直接限制了对处理机的利用率和系统的吞吐量的提高<br>②驻留性：作业被装入内存后，整个作业都一直驻留在内存中，直至作业运行结束才换出</p>
<p>局部性原理：在一较短的时间内，程序的执行仅局限于某一部分，相应的，它所访问的存储空间也局限于某个区域<br>①程序执行时，除了少部分的转移和过程调用指令外，在大多数情况下是顺序执行的<br>②过程调用的深度在大多数情况下都不超过5<br>③程序中存在许多循环结构，被多次执行<br>④对数据结构的处理局限于很小的范围内</p>
<p>局限性：<br>⑴时间局限性<br>    ①原因：在程序中存在大量的循环操作<br>    ②现象：如果程序中的某条指令被执行，则不久以后该指令可能再次执行<br>            如果某数据被访问过，则不久以后该数据可能再次被访问<br>⑵空间局限性<br>    ①原因：程序的顺序执行<br>    ②现象：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问</p>
<p>虚拟存储器的基本工作情况：<br>    程序在运行时，如果它所要访问的页（段）已调入内存，便可继续执行下去；但如果程序所要访问的页（段）尚未调入内存（称为缺页或缺段），便发出缺页（段）中断请求，此时OS将利用请求调页（段）功能将它们调入内存，以使进程能继续执行下去。如果此时内存已满，无法再装入新的页（段），OS还需再利用页（段）的置换功能，将内存暂时不用的页（段）调至盘上，腾出足够的内存空间后，再将要访问的页（段）调入内存，使程序继续执行下去</p>
<p>虚拟存储器的特征：（虚拟性是以多次性和对换性为基础的）<br>⑴多次性（最重要特征）：一个作业中的程序和数据允许被分成多次调入内存运行，即只需将当前要运行的那部分程序和数据装入内存即可开始运行<br>⑵对换性：<br>①在进程运行期间，允许将那些暂不使用的代码和数据从内存调至外存的对换区（换出），待以后需要时再将它们从外存调至内存（换进）<br>②允许在作业的运行过程中进行换进换出<br>③换进和换出能有效的提高内存利用率<br>⑶虚拟性：<br>①从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量<br>②优点：改善内存的利用率，提高程序执行的并发程度，增加系统的吞吐量<br>虚拟存储器的实现，建立在离散分配存储管理方式的基础上</p>
<p>分页请求系统：在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统，允许用户程序只装入少数页面的程序数据即可启动运行<br>⑴硬件支持：①请求分页的页表机制<br>②缺页中断机构<br>③地址变换机构<br>⑵软件支持：①实现请求调页的软件<br>②实现页面置换的软件</p>
<p>请求分段系统：在分段系统的基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统，允许用户出现只要装入少数段的程序和数据即可启动运行<br>⑴硬件支持：①请求分段的段表机制<br>②缺段中断机构<br>③地址变换机构<br>⑵软件支持：①实现请求调段的软件<br>②实现段置换的软件</p>
<p>请求分页系统在实现上要比请求分段系统简单</p>
<p>请求页表机制：（请求页表）<br>①页号<br>②物理块号<br>③状态位（存在位）P：用于指示该页是否被调入内存，供程序访问时参考<br>④访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问<br>⑤修改位M：标识该页在调入内存后是否被修改过<br>⑥外存地址：该页在外存的地址</p>
<p>缺页中断机构：<br>①在指令执行期间产生和处理中断信号（立即）<br>②一条指令在执行期间可能产生多次缺页中断</p>
<p>地址变换机构：①检索快表：修改访问位和修改位<br>②到内存去查找页表：判断状态位，写入快表</p>
<p>请求分页中的内存分配：<br>⑴最小物理块数的确定：能保证进程正常运行所需的最小物理块数<br>⑵内存分配策略：①固定分配局部置换<br>②可变分配全局置换<br>③可变分配局部置换：当某进程发现缺页时，只允许从该进程在内存的页面中选择一页换出<br>i.    固定分配：为每个进程分配一组固定数目的物理块，在进程运行期间不再改变<br>ii.    可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做<br>适当的增加或减少<br>iii.    局部置换：如果进程在运行中发现缺页，则只能从分配给该进程的n个页面中选出<br>一页换出。然后再调入一页，以保证分配给该进程的内存空间不变<br>iv.    全局置换：如果进程在运行中发现缺页，则将OS所保留的空闲物理块取出一块分<br>配给该进程，或者以所有进程的全部物理块为标的，选择一块换出，然<br>后将所缺之页调入</p>
<p>物理块分配算法<br>①平均分配算法：将系统中所有可供分配的物理块平均分配的物理块平均分配给各个进程<br>②按比例分配算法：根据进程的大小按比例分配物理块<br>③考虑优先权的分配算法：为高优先进程适当地增加其相应份额</p>
<p>页面调入策略：<br>⑴确定系统将进程运行时所缺的页面调入内存的时机：<br>①预调页策略：将预计在不久之后便会被访问的页面预先调入内存<br>②请求调页策略：进程访问程序数据，若发现其所在页面不在内存，便立即提出请求<br>⑵从何处将缺页调入内存（三种情况）<br>    ①系统拥有足够的对换区空间：全部从对换区调入所需页面<br>    ②系统缺少足够的对换区空间：直接从文件区调入，换出时调到对换区<br>    ③UNIX方式：该系统允许页面共享，页面可能已被其他进程调入内存</p>
<p>页面调入过程：<br>    每当程序所要访问的页面未在内存时（存在位为“0”），便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后转入缺页中断处理程序。该程序通过查找页表得到该页在外存的物理块后，如果此时内存能容纳新页，则启动磁盘I/O，将所缺之页调入内存，然后修改页表。如果内存已满，则须先按照某种置换算法，从内存中选出一页准备换出；如果该页未被修改过（修改位为“0”），可不必将该页写回磁盘；但如果此页已被修改过（修改位为“1”），则必须将它写回磁盘，然后再把所缺的页调入内存，并修改页表中的相应表项，置其存在位为“1”，并将此页表项写入快表中</p>
<p>缺页率：<br>①公式=访问失败次数/页面访问次数<br>    ②影响因素：<br>a)    页面大小<br>b)    进程所分配物理块的数目<br>c)    页面置换算法<br>d)    程序固有属性：程序编制的局部化程度越高，相应执行时的缺页程度越低<br>③缺页中断处理时间：t=β<em>tA+(1-β)</em>tB<br>    （置换页面被修改概率β，其缺页中断时间tA，置换页面没有被修改的时间tB）</p>
<p>页面置换算法：（选择换出页面的算法）<br>⑴最佳Optimal置换算法：所选择的被淘汰页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面<br>⑵先进先出FIFO页面置换算法：淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰<br>⑶最近最久未使用LRU置换算法<br>①描述：选择最近最久未使用的页面予以淘汰<br>②硬件支持<br>a)    寄存器：页面配置移位寄存器<br>b)    栈：保存当前使用的各个页面的页面号，栈顶始终是最新被访问页面的编号，<br>栈底则是最近最久未使用页面的页面号<br>⑷最少使用LFU置换算法：选择在最近时期使用最少的页面作为淘汰页<br>（移位寄存器：记录该页面被访问的频率）<br>⑸Clock置换算法（循环的检查各页面的使用情况）<br>    ①简单的Closk置换算法（最近未用算法NRU）：<br>    为每页设置一位访问位，再将内存中的所有页面都通过链接指针连接成一个循环队<br>列。若0则选择该页换出，若1则将其置0<br>    ②改进型Clock置换算法：同时检查访问位与修改位（置换代价）</p>
<p>页面缓冲算法PBA：<br>    特点：①显著地降低了页面换进换出的频率<br>          ②不需要特殊硬件的支持，实现简单<br>    设置的两个链表：①空闲页面链表：免除从磁盘读入数据的操作<br>                    ②修改页面链表：减少已修改页面换出的次数</p>
<p>影响页面换进换出效率的因素：①页面置换算法：缺页率低可减少页面换进换出的开销<br>                            ②写回磁盘的频率<br>                            ③读入内存的频率</p>
<p>被访问页不在内存中，内存的有效访问时间EAT=λ+a<em>λ +(1-a)</em>[t+f<em>(+λ+t)+(1-f)</em>(λ+t)]<br>λ表示查找快表所需要的时间，a表示命中率，t表示访问实际物理地址所需要的时间，缺页中断时间ε，缺页率f</p>
<p>抖动：⑴定义：造成每个进程的大部分时间用于页面的换进换出<br>⑵产生原因：同时运行的进程太多，分配给每一个进程的物理块太少，频繁出现缺页<br>⑶预防方法：①采取局部置换策略<br>②把工作集算法融入到处理机调度中<br>③利用“L=S”准则调节缺页率<br>④选择暂停的进程</p>
<p>工作集：在某段时间间隔里，进程实际所要访问页面的集合</p>
<p>请求段表：①段名<br>②段长<br>③段基址<br>④存取方式：只执行、只读、允许读/写<br>⑤访问字段A：用于记录该段被访问的频繁程度<br>⑥修改位M：表示该页在进入内存后是否已被修改过<br>⑦存在位：用于指示本段是否已调入内存<br>⑧增补位：用于表示本段在运行过程中是否做过动态增长<br>⑨外存始址：指示本段在外存中的起始地址</p>
<p>不可能出现一条指令被分割在两个分段中，和一组信息被分割在两个分段中的情况</p>
<p>共享段表：①共享进程计数count：记录有多少进程正在共享该分段<br>②存取控制字段：为不同的进程赋予不同的存取权限<br>③段号：每个进程可用自己进程的段号去访问该共享段</p>
<p>分段保护：①越界检查：利用地址变换机构完成<br>②存取控制检查：用于规定对该段程序或数据进行读访问<br>③环保护机构（规则）：<br>I.    一个程序可以访问驻留在相同环或者较低特权环（外环）中的数据<br>II.    一个程序可以调用驻留在相同环或者较高特权环（内环）中的服务</p>
<p>I/O系统管理：<br>⑴主要对象：I/O设备和相应的设备控制器<br>⑵主要任务：完成用户提出的I/O请求，提高I/O速率，以及提高设备的使用率，并能为更高层的进程方便地使用这些设备提供手段</p>
<p>I/O系统的基本功能<br>⑴隐藏物理设备的细节：对设备加以适当的抽象，隐藏物理设备的实现细节<br>⑵与设备的无关性：使用抽象的I/O命令，还可使用抽象的逻辑设备名来使用设备<br>⑶提高处理机和I/O设备的利用率：尽可能地让处理机和I/O设备并行操作<br>⑷对I/O设备进行控制<br>    控制方式：①采用轮询的可编程的I/O方式<br>              ②采用中断的可编程I/O方式<br>              ③直接存储器访问方式<br>              ④I/O通道方式<br>⑸确保对设备的正确共享<br>    共享属性的设备类型：①独占设备（打印机、磁带机）：进程互斥访问<br>②共享设备（磁盘）：在一段时间内允许多个进程同时访问<br>⑹错误处理：①临时性错误：可通过重试操作纠正<br>②持久性错误：向上层报告</p>
<p>I/O软件的层次结构：<br>①用户层I/O软件：实现与用户交互的接口<br>②设备独立性软件：实现用户程序与设备驱动器的统一接口、设备命名、设备保护及设备分配释放<br>③设备驱动程序：具体实现系统对设备发出的操作指令<br>④中断处理程序</p>
<p>I/O系统的分层：①中断处理程序<br>②设备驱动程序<br>③设备独立性软件</p>
<p>I/O系统的上下接口：<br>⑴I/O系统接口：（方便高层对设备的使用）<br>    ①块设备接口：（块设备管理程序与高层之间的接口）<br>I.    块设备：数据的存取和传输都是以数据块为单位的设备<br>特征：<br>a)    传输速率较高<br>b)    可寻址：能指定数据的输入源地址及输出的目标地址<br>II.    隐藏了磁盘的二维结构：线性序列<br>III.    将抽象命令映射为低层操作<br>    ②流设备接口：<br>i.    字符设备：数据的存取和传输都是以字符为单位的设备<br>ii.    get和put操作：顺序存取方式、建立一个字符缓冲区<br>iii.    in-control指令<br>    ③网络通信接口<br>⑵软件/硬件接口</p>
<p>I/O设备的类型：<br>⑴按使用特性：①存储设备：用以存储信息<br>②I/O设备：<br>I.    输入设备<br>II.    输出设备<br>III.    交互式设备<br>⑵按传输速率：①低速设备：键盘、鼠标器<br>②中速设备：行式打印机、激光打印机<br>③高速设备：磁带机、磁盘机、光盘机</p>
<p>信号线类型：（设备与设备通信器的接口）<br>①数据信号线：在设备和设备控制器之间传送数据信号<br>②控制信号线：由设备控制器向i/o设备发送控制信号时的通路<br>③状态信号线：传送指示设备当前状态的信号</p>
<p>设备控制器的主要功能：控制一个或多个I/O设备和计算机之间的数据交换</p>
<p>设备控制器的基本功能：①接收和识别命令<br>②数据交换：设置数据寄存器<br>③标识和报告设备的状态<br>④地址识别：识别所控制的每个设备的地址<br>⑤数据缓冲区：暂存主机和I/O设备的数据<br>⑥差错控制</p>
<p>设备控制器的组成：①设备控制器与处理机的接口<br>②设备控制器与设备的接口<br>③I/O逻辑</p>
<p>对I/O设备的控制：①利用特定的I/O指令：访问内存和访问设备指令不同<br>②内存映像I/O</p>
<p>I/O通道不同于一般处理机的地方：①指令类型单一<br>②通道没有自己的内存</p>
<p>通道类型：<br>⑴字节多路通道：按字节交叉方式工作<br>⑵数组选择通道：按数组方式进行数据传送<br>⑶数组多路通道：两者优点相结合</p>
<p>“瓶颈”问题：<br>⑴原因：通道不足<br>⑵解决方法：增加设备到主机间的通路而不增加通道</p>
<p>中断（外中断）：CPU对I/O设备发出的中断信号的一种响应<br>陷入（内中断）：由CPU内部事件所引起的中断（如上下溢）</p>
<p>中断向量表：为每种设备配以相应的中断处理程序，中断号+人口地址<br>中断优先级：对服务要求的紧急程度</p>
<p>对多中断源的处理方式：<br>⑴屏蔽（禁止）中断：当处理机正在处理一个中断时，将屏蔽掉所有的中断<br>⑵嵌套中断<br>    规则：①CPU优先响应最高优先级的中断请求<br>          ②高优先级的中断请求可以抢占正在运行的低优先级中断的处理机</p>
<p>中断处理程序的处理过程：①测定是否有未响应的中断信号<br>②保护被中断进程的CPU进程<br>③转入相应的设备处理程序<br>④中断处理<br>⑤恢复CPU的现场并退出中断</p>
<p>设备驱动程序的功能：<br>⑴接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列<br>⑵检查用户I/O请求的合法性，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式<br>⑶发出I/O命令<br>⑷及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理</p>
<p>设备驱动程序特点：<br>⑴实现在与设备无关的软件和设备控制器之间通信和转换的程序<br>⑵与设备控制器以及I/O设备的硬件特性紧密相关<br>⑶与I/O设备所采用的I/O控制方式紧密相关<br>⑷用汇编语言书写<br>⑸允许可重入</p>
<p>设备处理方式（三种）：①为每一个设备设置一个进程<br>②在整个系统设置一个I/O进程<br>③不设置专门的设备处理进程</p>
<p>设备驱动程序的主要任务：启动指定设备，完成上层指定的I/O工作</p>
<p>设备驱动程序的处理过程：①将抽象要求转换为具体要求<br>②对服务请求进行校验<br>③检查设备的状态<br>④传送必要的参数<br>⑤启动I/O设备</p>
<p>对I/O设备的控制方式：<br>⑴采用轮询的可编程的I/O方式：在处理机向控制器发出一条I/O指令，启动输入设备输入数据时，要同时把状态寄存器中的忙/闲标志busy置为1，然后便不断的循环测试busy（称为轮询）<br>⑵采用中断的可编程I/O方式：当某进程要启动某个I/O设备工作时，便由CPU向相应的设备控制器发出一条I/O命令，然后立即返回继续执行原来的任务<br>⑶直接存储器访问方式<br>①特点：<br>I.    数据传输的基本单位是数据块<br>II.    所传送的数据是从设备直接送入内存的<br>III.    仅在传送一个或多个数据块的开始和结束时才需CPU干预，整块数据的传送是在控制器的控制下完成的<br>②DMA控制器的组成：<br>I.    主机与DMA控制器的接口<br>II.    DMA控制器与块设备的接口<br>III.    I/O控制逻辑<br>③四类寄存器：<br>I.    命令/状态寄存器CR：接收从CPU发来的I/O命令<br>II.    内存地址寄存器MAR：<br>III.    数据寄存器DR：暂存数据<br>IV.    数据计数器DC：存放本次CPU要读或写的字（节）数<br>④DMA工作过程：<br>当CPU要从磁盘读入一数据块时，便向磁盘控制器发送一条读命令。该命令被送入命令寄存器CR中。同时，需要将本次要读入数据在内存的起始目标地址送入内存地址寄存器MAR中。将要读数据的字（节）数送入数据计数器DC中、还需将磁盘中的源地址直接送至DMA控制器的I/O控制逻辑上。然后，启动DMA控制器进行数据传送。<br>当DMA控制器已从磁盘中读入一个字的数据，并送入数据寄存器DR后，再挪用一个存储器周期，将该字传送到MAR所指示的内存单元中。然后便对DMA内容加1，将DC内容减1，若减1后DC内容不为0，表示传送未完，便继续传送那个下一个字（节）；否则，由DMA控制器发出中断请求<br>⑷I/O通道控制方式</p>
<p>逻辑设备：抽象的设备名</p>
<p>I/O重定向：用于I/O操作的设备可以更换（重定向），而不必改变应用程序</p>
<p>逻辑设备表：将逻辑设备名称转换为某物理设备名称的功能</p>
<p>设备无关性：应用程序中所用的设备，不局限于使用某个具体的物理设备</p>
<p>与设备无关的软件：（I/O系统的最高层软件）<br>①设备驱动程序的统一接口：将抽象的设备名转换为具体的物理设备名<br>②缓冲管理：缓和CPU和I/O设备之间的矛盾<br>③差错控制：<br>i.    暂时性错误：因发生暂时性事件引起的<br>ii.    持久性错误：由持久性故障引起的<br>④对独立设备的分配与回收：由系统来统一分配，不允许进程自行使用<br>⑤独立于设备的逻辑数据块</p>
<p>设备控制表DCT：①设备队列队首指针<br>②忙/闲标志<br>③与设备连接的控制器表指针<br>④重复执行次数</p>
<p>控制器控制表COCT：记录控制器情况<br>通道控制表CHCT</p>
<p>系统设备表SDT：①设备类型<br>                ②设备标识符<br>                ③设备控制表<br>                ④设备驱动程序的入口项</p>
<p>设备分配时应考虑的因素：<br>⑴设备的固有属性（分配策略）<br>    ①独占设备：由该进程独占<br>    ②共享设备：同时分配给多个进程使用<br>    ③虚拟设备：可共享<br>⑵设备分配算法<br>    ①先来先服务：进程对某设备提出请求的先后次序<br>    ②优先级高者优先：优先级相同的，按先来先服务原则排队<br>⑶设备分配中的安全性<br>    ①安全分配方式：CPU与I/O设备是顺序工作的<br>    ②不安全分配方式：一个进程可同时操作多个设备，使进程推进迅速</p>
<p>设备分配顺序：①分配设备<br>②分配控制器<br>③分配通道</p>
<p>逻辑设备表LUT：逻辑设备名、物理设备名、设备驱动程序的入口地址</p>
<p>逻辑设备表的设置方式：①整个系统只设置一张LUT<br>                      ②为每个用户设置一张LUT</p>
<p>SPOOLing技术（假脱机技术）：在联机情况下实现的同时外围操作的技术</p>
<p>SPOOLing系统的组成：①输入井和输出井<br>                    ②输入缓冲区和输出缓冲区<br>                    ③输入进程和输出进程<br>                    ④井管理程序</p>
<p>SPOOLing系统的特点：①提高了I/O的速度<br>                    ②将独占设备改造为共享设备<br>                    ③实现了虚拟设备功能</p>
<p>假脱机打印机系统：①磁盘缓冲区<br>②打印缓冲区<br>③假脱机管理进程和假脱机打印进程</p>
<p>引入缓冲区的原因：<br>①缓和CPU与I/O设备间速度不匹配的矛盾<br>②减少对CPU的中断频率，放宽对CPU中断响应时间的限制<br>③解决数据粒度不匹配的问题<br>④提高CPU和I/O设备之间的并行性</p>
<p>缓冲区管理：<br>⑴单缓冲区：每当用户进程发出一I/O请求时，操作系统便在主存中为之分配一缓冲区<br>⑵双缓冲区：在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区<br>⑶环形缓冲区：多个缓冲区、多个指针</p>
<p>缓冲池：①空白缓存队列emq<br>②输入队列inq<br>③输出队列outq</p>
<p>缓冲区的工作方式：①收容输入<br>②提取输入<br>③收容输出<br>④提取输出</p>
<p>改善磁盘系统的性能的途径：<br>①选择好的磁盘调度算法，以减少磁盘的寻道时间<br>②提高磁盘I/O速度，以提高对文件的访问速度<br>③采取冗余技术，以提高系统的可靠性，建立高度可靠的文件系统</p>
<p>扇区字段：标识符字段、数据字段</p>
<p>磁盘类型：①固定头磁盘：每道磁道上有一读/写磁头，可访问所有各磁道，进行并行读写<br>②移动头磁盘：每一个盘面仅配有一个磁头，磁头移动以进行寻道，串行读写</p>
<p>磁盘访问时间：<br>⑴寻道时间Ts：启动磁臂的时间s与磁头移动n条磁道所花费的时间之和（Ts=m*n+s）<br>⑵旋转延迟时间Tr：指定扇区移动到磁头下面所经历的时间<br>⑶传输时间Tt：把数据从磁盘读出或向磁盘写入数据所经历的时间。</p>
<p>适当的集中数据传输将有利于提高传输效率</p>
<p>磁盘调度：（目标是使磁盘的平均寻道时间最少）<br>⑴早期的磁盘调度算法：<br>①先来先服务FCFS：根据进程请求访问磁盘的先后次序进行调度<br>②最短寻道时间优先SSTF：其要求访问的磁道与当前磁头所在的磁道距离最近<br>⑵基于扫描的磁盘调度算法：<br>①扫描SCAN算法（电梯调度算法）：既考虑欲访问的磁道与当前磁道间的距离，优先考虑磁头当前的移动方向<br>②循环扫描CSCAN算法：规定磁头单向移动。<br>                       将最小磁道号紧接着最大磁道号构成循环，进行循环扫描<br>③NStepSCAN算法：将磁盘请求队列分成若干个长度为N的子队列，按FCFS算法依次处理这些子队列，每处理一个队列时按SCAN算法<br>④FSCAN算法：将磁盘请求队列分成两个子队列，一个由当前所有请求磁盘I/O的进程形成的队列，另一个是新出现的所有请求磁盘I/O的进程</p>
<p>磁臂粘着：进程反复请求对某一磁道的I/O操作，从而垄断了整个磁盘设备</p>
<p>数据组成：<br>⑴数据项<br>    ①基本数据项（最小逻辑数据单位）<br>    ②组合数据项（由若干个基本数据项组成）<br>⑵记录（一组相关数据项的集合）<br>    关键字是唯一表示一个记录的数据项<br>⑶文件（若干个记录组成）<br>    ①文件类型<br>    ②文件长度<br>    ③文件的物理位置<br>    ④文件的建立时间</p>
<p>文件类型：<br>⑴按性质用途：<br>    ①系统文件<br>    ②用户文件<br>    ③库文件<br>⑵按文件中数据的形式分类<br>    ①源文件<br>    ②目标文件<br>    ③可执行文件</p>
<p>⑶按存取控制属性分类<br>    ①只执行文件<br>    ②只读文件<br>    ③读写文件<br>⑷按组织形式和处理方式分类<br>    ①普通文件<br>    ②目录文件<br>    ③特殊文件</p>
<p>文件系统的层次结构<br>⑴对象及其属性：①文件<br>②目录<br>③磁盘（磁带）存储空间<br>⑵对对象操纵和管理的软件集合<br>    ①I/O控制层<br>    ②基本文件系统层<br>    ③基本I/O管理程序<br>    ④逻辑文件系统<br>⑶文件系统的接口<br>    ①命令接口<br>    ②程序接口</p>
<p>文件操作：<br>①最基本的文件操作：创建文件、删除文件、读文件、写文件、设置文件的读/写位置<br>②文件的“打开”和“关闭”操作<br>③其他文件操作</p>
<p>文件逻辑结构的类型：<br>⑴按文件是否有结构分类<br>    ①有结构文件：定长记录、变长记录<br>    ②无结构文件<br>⑵按文件的组织方式分类<br>    ①顺序文件<br>I.    串结构<br>II.    顺序结构<br>    ②索引文件<br>    ③索引顺序文件</p>
<p>记录寻址：<br>①隐式寻址方式<br>②显式寻址方式<br>I.    通过文件中记录的位置<br>II.    利用关键字</p>
<p>对目录管理的要求：①实现“按名存取”<br>②提高对目录的检索速度<br>③文件共享<br>④允许文件重名</p>
<p>文件控制块FCB：<br>⑴基本信息类：①文件名<br>②文件物理位置<br>③文件逻辑结构<br>            ④文件的物理结构<br>⑵存取控制信息类：①文件主的存取权限<br>②核准用户的存取权限<br>③一般用户的存取权限<br>⑶使用信息类①文件的建立日期和时间<br>②文件上一次修改的日期和时间<br>③当前使用信息</p>
<p>索引结点：<br>⑴磁盘索引结点：①文件主标识符<br>②文件类型<br>③文件存取权限<br>                ④文件物理地址<br>                ⑤文件长度<br>                ⑥文件连接计数<br>                ⑦文件存取时间<br>⑵内存索引：①索引结点编号<br>②状态<br>③访问计数<br>I.    文件所属文件系统的逻辑设备号<br>II.    链接指针</p>

      
    </div>
    
    
    

<div>
  
    
  
</div>
    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/05/管理信息系统/" rel="next" title="管理信息系统">
                <i class="fa fa-chevron-left"></i> 管理信息系统
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/23/数据库原理/" rel="prev" title="数据库原理（考试版）">
                数据库原理（考试版） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/qifang.jpg"
                alt="十点一刻" />
            
              <p class="site-author-name" itemprop="name">十点一刻</p>
              <p class="site-description motion-element" itemprop="description">在没有路的丛林走出迷雾</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/tenneling" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:tenneling@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
<div id="music163player">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=477786576&auto=0&height=32"></iframe>
</div>

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">十点一刻</span>

  
</div>








<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">全站共132.7k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  




<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


</body>
</html>
