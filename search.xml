<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于hexo的那些事儿]]></title>
    <url>%2F2018%2F10%2F06%2F%E5%85%B3%E4%BA%8Ehexo%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[本菜鸡是听老姐的建议开始搞自己的博客的。 给个友情链接：https://wenxn.github.io/ 瞻仰一下年薪25W的dalao.. 鉴于本人比较.. 忙于其他的事情，所以这篇文就单单放链接了.. 毕竟一些东西还是要多看多搜索才知道.. 看了很多博客，感觉简书的比较实在，界面也不错，CSDN的广告太多了唉.. 其实不是想写这篇文，就是文件夹收藏太多了，找个地方放一下链接，也利于以后要搭建自己博客的娃少走点弯路，学习真的是一件无止境的事情啊.. —————————– 正文开始 —————————— git+github的启蒙文章，https://segmentfault.com/a/1190000002413519#articleHeader2 github启蒙，https://www.cnblogs.com/xiaocen/p/3727324.html git的启蒙，https://www.cnblogs.com/my-freedom/p/5701427.html git的用法，http://www.bootcss.com/p/git-guide/ 用github和hexo搭建博客（详细），https://www.jianshu.com/p/05289a4bc8b2 很详细的搭建教程，也有错误的处理方法，https://www.cnblogs.com/qyun/p/6628601.html hexo入门讲解，https://zhuanlan.zhihu.com/p/24763104 选择喜欢的hexo主题，https://www.zhihu.com/question/24422335 鉴于我和老姐都是next主题，所以都是相关设置咯 https://zhuanlan.zhihu.com/p/22735619 https://blog.csdn.net/u011475210/article/details/79023429 http://theme-next.iissnan.com/（官方） https://zhuanlan.zhihu.com/p/22745430（加强版功能） https://hexo.io/zh-cn/docs/writing（官方） http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html https://segmentfault.com/a/1190000009544924#articleHeader21 https://blog.csdn.net/Hoshea_chx/article/details/78826689 https://blog.csdn.net/linshuhe1/article/details/52424573 https://www.jianshu.com/p/efbeddc5eb19 https://www.jianshu.com/p/e17711e44e00 https://www.jianshu.com/p/ebbbc8edcc24 图标库，https://fontawesome.com/icons?d=gallery&amp;s=brands 自定义页面，https://blog.csdn.net/jiaojsun/article/details/76341379 更新博文，https://www.zhihu.com/question/59088760/answer/161640592 关于博文的维护，https://www.zhihu.com/question/21193762 关于如何将本地项目上传到github，本人也收藏了几个链接，应该比本站博文的更详细，供参考 https://blog.csdn.net/zamamiro/article/details/70172900 https://www.cnblogs.com/specter45/p/github.html#s4 https://www.cnblogs.com/eedc/p/6168430.html https://www.cnblogs.com/cxk1995/p/5800196.html 关于Markdown，本人用有道云笔记，不过老姐推荐用one，以后再试试.. 其实发布几乎只用到下面三个命令123hexo g //解编码？hexo s //本地服务器，端口号4000hexo d //部署到github]]></content>
      <categories>
        <category>实践操作</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用git发布项目到github]]></title>
    <url>%2F2018%2F10%2F06%2F%E4%BD%BF%E7%94%A8git%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[1. 安装git 下载地址：https://gitforwindows.org/ 2. 注册github3. 在github新建仓库4. 复制仓库的http地址5. 在本地的git命令行输入1git clone +http地址 注意：此时应该是在本地的项目文件夹（git bush here） 6. 发现多出了个文件夹，前面一步的目的是把github仓库复制到本地。然后我们可以把自己的项目放进这个文件夹。接着cd+文件夹名7. 输入以下代码123git add . git commit -m &quot;remark&quot; git push -u origin master 8. 完成！]]></content>
      <categories>
        <category>实践操作</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本操作]]></title>
    <url>%2F2018%2F10%2F06%2FGit%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[操作Git git clone url：把origin master上的项目克隆到本地 git add 文件名：向Git添加文件 git add -A：向Git添加所有文件 git commit -m “message”：向Git提交。-m是输入信息参数，双引号内是备注信息内容 git push：向远程Git进行push操作，push到远程同名分支 git push origin master：向远程主干进行push操作，push到远程主干 git status：查看本地分支以及当前的本地文件状态（是否提交到远程） 创建分支 git fetch：首先通过命令更新分支 git branch -a：查看本地分支和远程分支，带星号绿色的为当前所在分支 git checkout -b branch2 origin/master：以master为基础创建新的本地分支branch2 git checkout -b branch2 origin/master -b：创建branch2分支后，自动切换到新的分支 git push origin branch2：创建完成本地branch2分支之后，将本地新分支推送到远程branch2分支上 Git常用命令 git checkout 分支名：切换分支 git pull：获取文件（默认从当前分支） git merge 分支名：合并代码 gitlab-ctl stop：关闭GitLab服务 gitlab-ctl start：开启GitLab服务]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM常用注解]]></title>
    <url>%2F2018%2F10%2F06%2FSSM%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Mybatis注解 @Arg：单独的构造方法参数 @CacheNamespace：为给定的命名空间配置缓存 @CacheNamespaceRef：参照另外一个命名空间的缓存来使用 @Case：单独实例的值和它对应的映射 @ConstructorArgs：收集一组结果传递给对象构造方法 @Insert,@Update,@Delete：代表了执行的真实SQL，使用字符串数组 @InsertProvider,@UpdateProvider,@DeleteProvider：允许指定一个类名和一个方法在执行时返回运行的SQL @Many：复杂类型的集合属性映射 @One：复杂类型的单独属性值映射 @Options：提供访问交换和配置选项，通常在映射语句上作为属性出现 @Param：应用于映射器方法，给每个参数名字 @Result：在列和属性或字段之间的单独结果映射 @Results：结果映射的列表，包含了一个特别结果列如何被映射到属性或字段的详情 @TypeDiscriminator：一组实例值，用来决定结果映射的表现 Spring和Spring MVC常用注解 @After：定义最终增强 @AfterReturning：定义后置增强 @AfterThrowing：定义异常抛出增强 @Around：定义环绕增强 @Aspect：定义切面 @Autowired：实现Bean的装配，默认按类型装配 @Before：定义前置增强 @Cacheable：声明一个方法的返回值应该被缓存 @CacheFlush：声明一个方法是清空缓存的触发器 @Component：被此注解的类都将由Spring容器进行管理 @Controller：用于标注控制器类 @ControllerAdvice：能够将通用的@ExceptionHandler、@InitBinder和@ModelAttributes方法收集到一个类中，并应用于所有控制器中 @DateTimeFormat：可以用来格式化java.util.Date，java.util.Calendar和java.util.Long类型 @ExceptionHandler：配置在局部异常处理时定义异常处理 @InitBinder：添加自定义编辑器 @ModelAttribute： 参数：表明此参数的值来源于模型中的某个属性 方法：表明此方法会在此控制器的每个方法执行前被执行 @NumberFormat：可以用来格式化任何数字类型或java.util.Number的实例 @PathVariable：可以将URL中的{xxx}占位符参数绑定到控制器处理方法的入参中 @Pointcut：定义切入点表达式 @PostConstruct：被此注解标注的方法会在Bean初始化之后被Spring容器执行 @PreDestroy：被此注解标注的方法会在Bean销毁之前被Spring容器执行 @Qualifier：明确指定Bean的名称进行注入 @Repository：用于标注DAO类 @RequestMapping：定义控制器方法和URL的映射关系 @RequestParam：指定被标注的方法入参和URL请求的参数的对应关系 @Required：用于检查特定的属性是否被设置，如果没有设置则抛出异常 @Resource：实现Bean的装配，默认按名称装配 @ResponseBody：将标注该注解的处理方法的返回结果直接写入HTTP Response Body中 @Scope：定义一个类的作用范围 @Service：用于标注业务类 @SessionAttributes：使模型中的数据存储一份到session域中 @Transactional：为类或方法添加事务处理 Spring注解(另一版本)@Controller：用于指示Spring类的实例是一个控制器@RequestMapping：指示Spring用哪一个类或方法来处理请求动作@RequestParam：用于将指定的请求参数赋值给方法中的形参@PathVariable：可以非常方便地获得请求URL中的动态参数@MatrixVariable：允许开发者进行多条件组合查询@CrossOrigin：用于在SpringMVC中处理跨域请求@RequestHeader：用于将请求的头信息数据映射到功能处理方法的参数上@CookieValue：用于将请求的Cookie数据映射到功能处理方法的参数上@RequestAttribute：用于访问由请求处理方法、过滤器或拦截器创建的、预先存在于request作用域中的属性，将该属性转换到目标方法的参数@SessionAttribute：用于访问由请求处理方法、过滤器或拦截器创建的、预先存在于session作用域中的属性，将该属性转换到目标方法的参数@SessionAttributes：允许有选择地指定Model中的哪些属性转存到HttpSession对象当中@ModelAttribute：用于将请求参数绑定到对象@RequestBody：用来处理Content-Type@ResponseBody：用于将Controller的请求处理方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区@RestController：该类中所有使用@RequestMapping注解的方法都默认使用了@ResponseBody注解@ResponseStatus：处理异常，将异常信息返回给客户端，提高可读性@ExceptionHandle：指定异常类（用处最强大）@ControllerAdvice：将以上两个注解的方法应用到所有的请求处理方法上]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring+mybatis简单实例]]></title>
    <url>%2F2018%2F10%2F06%2Fspring%2Bmybatis%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[一、搭建开发环境 JDK8 Eclipse Tomcat8 jar包 二、环境配置1. 数据库语句（图片自行命名）12345678910111213141516171819202122232425262728293031323334353637383940 create database mybatis; use mybatis; drop table if exists tb_user; CREATE TABLE tb_book ( id INT (11) PRIMARY KEY AUTO_INCREMENT, name VARCHAR (54), author VARCHAR (54), publicationdate DATE , publication VARCHAR (150), price DOUBLE , image VARCHAR (54), remark VARCHAR (600)); CREATE TABLE tb_user( id INT PRIMARY KEY AUTO_INCREMENT, loginname VARCHAR(50) UNIQUE, PASSWORD VARCHAR(18), username VARCHAR(18), phone VARCHAR(18), address VARCHAR(255) );insert into tb_user values(&apos;1&apos;,&apos;jack&apos;,&apos;123456&apos;,&apos;杰克&apos;,&apos;13920001234&apos;,&apos;广州市天河区&apos;);insert into tb_book values(&apos;1&apos;,&apos;疯狂Java讲义&apos;,&apos;李刚 编著&apos;,&apos;2008-10-01&apos;,&apos;电子出版社&apos;,&apos;74.2&apos;,&apos;java.jpg&apos;,&apos;crazy&apos;);insert into tb_book values(&apos;2&apos;,&apos;疯狂Java讲义&apos;,&apos;李刚 编著&apos;,&apos;2008-10-01&apos;,&apos;电子出版社&apos;,&apos;32.2&apos;,&apos;ee.jpg&apos;,&apos;crazy&apos;);insert into tb_book values(&apos;3&apos;,&apos;疯狂Java讲义&apos;,&apos;李刚 编著&apos;,&apos;2008-10-01&apos;,&apos;电子出版社&apos;,&apos;72.2&apos;,&apos;android.jpg&apos;,&apos;crazy&apos;);insert into tb_book values(&apos;4&apos;,&apos;疯狂Java讲义&apos;,&apos;李刚 编著&apos;,&apos;2008-10-01&apos;,&apos;电子出版社&apos;,&apos;74.9&apos;,&apos;ajax.jpg&apos;,&apos;crazy&apos;);insert into tb_book values(&apos;5&apos;,&apos;疯狂Java讲义&apos;,&apos;李刚 编著&apos;,&apos;2008-10-01&apos;,&apos;电子出版社&apos;,&apos;72.2&apos;,&apos;java.jpg&apos;,&apos;crazy&apos;);insert into tb_book values(&apos;6&apos;,&apos;疯狂Java讲义&apos;,&apos;李刚 编著&apos;,&apos;2008-10-01&apos;,&apos;电子出版社&apos;,&apos;74.2&apos;,&apos;java.jpg&apos;,&apos;crazy&apos;); 由于数据库编码可能出现以下错误时 1ERROR 1366 (HY000): Incorrect string value: &apos;\xD6\xD0\xCE\xC4&apos; for column XXX at row 1 可以修改配置文件my.ini，自行百度哈。如果只是单纯修改一个表的编码，可以用下列sql语句，高效 1ALTER TABLE OLD_TABLE CONVERT TO CHARACTER SET charset_name [COLLATE collation_name] 2. 配置文件 db.properties 12345678dataSource.driverClass=com.mysql.jdbc.DriverdataSource.jdbcUrl=jdbc:mysql://127.0.0.1:3306/mybatisdataSource.user=rootdataSource.password=admindataSource.maxPoolSize=20dataSource.maxIdleTime = 1000dataSource.minPoolSize=6dataSource.initialPoolSize=5 applicationContext.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd &quot;&gt; &lt;!-- mybatis:scan会将org.fkit.mapper包里的所有接口当作mapper配置，之后可以自动引入mapper类--&gt; &lt;mybatis:scan base-package=&quot;org.fkit.mapper&quot;/&gt; &lt;!-- 扫描org.fkit包下面的java文件，有Spring的相关注解的类，则把这些类注册为Spring的bean --&gt; &lt;context:component-scan base-package=&quot;org.fkit&quot;/&gt; &lt;!-- 使用PropertyOverrideConfigurer后处理器加载数据源参数 --&gt; &lt;context:property-override location=&quot;classpath:db.properties&quot;/&gt; &lt;!-- 配置c3p0数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;/&gt; &lt;!-- 配置SqlSessionFactory，org.mybatis.spring.SqlSessionFactoryBean是Mybatis社区开发用于整合Spring的bean --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; p:dataSource-ref=&quot;dataSource&quot;/&gt; &lt;!-- JDBC事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; p:dataSource-ref=&quot;dataSource&quot;/&gt; &lt;!-- 启用支持annotation注解方式事务管理 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;/beans&gt; springmvc-config.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 自动扫描该包，SpringMVC会将包下用了@controller注解的类注册为Spring的controller --&gt; &lt;context:component-scan base-package=&quot;org.fkit.controller&quot;/&gt; &lt;!-- 设置默认配置方案 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 使用默认的Servlet来响应静态文件 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 视图解析器 p:prefix属性表示前缀 p:suffix 表示后缀 --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; p:prefix=&quot;/WEB-INF/content/&quot; p:suffix=&quot;.jsp&quot;/&gt; &lt;/beans&gt; web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;!-- 配置spring核心监听器，默认会以 /WEB-INF/applicationContext.xml作为配置文件 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- contextConfigLocation参数用来指定Spring的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 定义Spring MVC的前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 让Spring MVC的前端控制器拦截所有请求 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; log4j.xml[选用] 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt; &lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%5p [%t] %m%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;org.fkit.mapper&quot;&gt; &lt;level value=&quot;DEBUG&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;ERROR&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt; &lt;/log4j:configuration&gt; 3.JavaBean和Mapper(持久层) User.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package org.fkit.domain;import java.io.Serializable;public class User implements Serializable&#123; private static final long serialVersionUID = 1L; private Integer id; // id private String loginname; // 登录名 private String password; // 密码 private String username; // 用户名 private String phone; // 电话 private String address; // 地址 public User() &#123; super(); // TODO Auto-generated constructor stub &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLoginname() &#123; return loginname; &#125; public void setLoginname(String loginname) &#123; this.loginname = loginname; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return &quot;User [id=&quot; + id + &quot;, loginname=&quot; + loginname + &quot;, password=&quot; + password + &quot;, username=&quot; + username + &quot;, phone=&quot; + phone + &quot;, address=&quot; + address + &quot;]&quot;; &#125; &#125; Book.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package org.fkit.domain;import java.io.Serializable;import java.util.Date;public class Book implements Serializable&#123; private static final long serialVersionUID = 1L; private Integer id; // id private String name; // 书名 private String author; // 作者 private String publication; // 出版社 private Date publicationdate; // 出版日期 private Double price; // 价格 private String image; // 封面图片 private String remark; // 详细描述 public Book() &#123; super(); // TODO Auto-generated constructor stub &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public String getPublication() &#123; return publication; &#125; public void setPublication(String publication) &#123; this.publication = publication; &#125; public Date getPublicationdate() &#123; return publicationdate; &#125; public void setPublicationdate(Date publicationdate) &#123; this.publicationdate = publicationdate; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125; public String getImage() &#123; return image; &#125; public void setImage(String image) &#123; this.image = image; &#125; public String getRemark() &#123; return remark; &#125; public void setRemark(String remark) &#123; this.remark = remark; &#125; @Override public String toString() &#123; return &quot;Book [id=&quot; + id + &quot;, name=&quot; + name + &quot;, author=&quot; + author + &quot;, publication=&quot; + publication + &quot;, publicationdate=&quot; + publicationdate + &quot;, price=&quot; + price + &quot;, image=&quot; + image + &quot;, remark=&quot; + remark + &quot;]&quot;; &#125; &#125; UserMapper.java 12345678910111213package org.fkit.mapper;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;import org.fkit.domain.User;public interface UserMapper &#123; @Select(&quot;select * from tb_user where loginname = #&#123;loginname&#125; and password = #&#123;password&#125;&quot;) User findWithLoginnameAndPassword(@Param(&quot;loginname&quot;)String loginname, @Param(&quot;password&quot;) String password);&#125; BookMapper.java 123456789101112package org.fkit.mapper;import java.util.List;import org.apache.ibatis.annotations.Select;import org.fkit.domain.Book;public interface BookMapper &#123; @Select(&quot; select * from tb_book &quot;) List&lt;Book&gt; findAll(); &#125; 4. Service接口及实现类（服务层） UserService.java 12345678package org.fkit.service;import org.fkit.domain.User;public interface UserService &#123; User login(String loginname,String password);&#125; UserServiceImpl.java 12345678910package org.fkit.service;import java.util.List;import org.fkit.domain.Book;public interface BookService &#123; List&lt;Book&gt; getAll();&#125; BookService.java 12345678910111213141516171819202122232425package org.fkit.service.impl;import org.fkit.domain.User;import org.fkit.mapper.UserMapper;import org.fkit.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;@Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT)@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Transactional(readOnly=true) @Override public User login(String loginname, String password) &#123; return userMapper.findWithLoginnameAndPassword(loginname, password); &#125;&#125; BookServiceImpl.java 123456789101112131415161718192021222324252627package org.fkit.service.impl;import java.util.List;import org.fkit.domain.Book;import org.fkit.mapper.BookMapper;import org.fkit.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;@Transactional(propagation=Propagation.REQUIRED,isolation=Isolation.DEFAULT)@Service(&quot;bookService&quot;)public class BookServiceImpl implements BookService &#123; @Autowired private BookMapper bookMapper; @Transactional(readOnly=true) @Override public List&lt;Book&gt; getAll() &#123; return bookMapper.findAll(); &#125;&#125; 5. 开发Controller(控制层) FormController.java 123456789101112131415package org.fkit.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class FormController&#123; @RequestMapping(value=&quot;/loginForm&quot;) public String loginForm()&#123; // 跳转页面 return &quot;loginForm&quot;; &#125;&#125; UserController.java 1234567891011121314151617181920212223242526272829303132333435363738394041package org.fkit.controller;import javax.servlet.http.HttpSession;import org.fkit.domain.User;import org.fkit.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.view.RedirectView;@Controllerpublic class UserController &#123; @Autowired @Qualifier(&quot;userService&quot;) private UserService userService; @PostMapping(value=&quot;/login&quot;) public ModelAndView login( String loginname,String password, ModelAndView mv, HttpSession session)&#123; // 根据登录名和密码查找用户，判断用户登录 User user = userService.login(loginname, password); if(user != null)&#123; // 登录成功，将user对象设置到HttpSession作用范围域 session.setAttribute(&quot;user&quot;, user); // 转发到main请求 mv.setView(new RedirectView(&quot;/fkbookapp/main&quot;)); &#125;else&#123; // 登录失败，设置失败提示信息，并跳转到登录页面 mv.addObject(&quot;message&quot;, &quot;登录名或密码错误，请重新输入!&quot;); mv.setViewName(&quot;loginForm&quot;); &#125; return mv; &#125; &#125; BookController.java 1234567891011121314151617181920212223242526272829package org.fkit.controller;import java.util.List;import org.fkit.domain.Book;import org.fkit.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class BookController &#123; @Autowired @Qualifier(&quot;bookService&quot;) private BookService bookService; @RequestMapping(value = &quot;/main&quot;) public String main(Model model) &#123; // 获得所有图书集合 List&lt;Book&gt; book_list = bookService.getAll(); // 将图书集合添加到model当中 model.addAttribute(&quot;book_list&quot;, book_list); // 跳转到main页面 return &quot;main&quot;; &#125;&#125; 6. 前端JSP页面 loginForm.jsp 12345678910111213141516171819202122232425262728&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;登录页面&lt;/h3&gt;&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt; &lt;font color=&quot;red&quot;&gt;$&#123;requestScope.message &#125;&lt;/font&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;登录名: &lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;loginname&quot; name=&quot;loginname&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;密码: &lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; main.jsp 1234567891011121314151617181920212223242526272829303132&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;首页&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; table&#123;border-collapse:collapse;border-spacing:0;border-left:1px solid #888;border-top:1px solid #888;background:#efefef;&#125; th,td&#123;border-right:1px solid #888;border-bottom:1px solid #888;padding:5px 15px;&#125; th&#123;font-weight:bold;background:#ccc;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;欢迎[$&#123;sessionScope.user.username &#125;]访问&lt;br&gt;&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;封面&lt;/th&gt;&lt;th&gt;书名&lt;/th&gt;&lt;th&gt;作者&lt;/th&gt;&lt;th&gt;价格&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;requestScope.book_list &#125;&quot; var=&quot;book&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=&quot;images/$&#123;book.image &#125;&quot; height=&quot;60&quot;&gt;&lt;/td&gt; &lt;td&gt;$&#123;book.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;book.author &#125;&lt;/td&gt; &lt;td&gt;$&#123;book.price &#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 三、调试输入以下url：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://localhost:8080/fkbookapp/loginForm [略][略][略]]]></content>
      <categories>
        <category>实践操作</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F10%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定其具体的类 适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作 桥梁模式：将抽象部分与其实现部分分离，使它们都可以独立地变化 建造模式：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示 责任链模式：为解除请求的发送者和接收者之间耦合而使多个对象都有机会处理这个请求，将一个请求，将这些对象连成一条链并沿着这条链传递该请求 命令模式：将一个请求封装为一个对象，从而可用不同请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作 合成模式：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户使用单个对象和复合对象具有一致性 装饰模式：动态地为一个对象添加一些额外的职责，就扩展功能而言，它比生成子类方式更为灵活 外观模式：为子系统中的一组接口提供一个一致的界面，该模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 工厂方法模式：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。该模式使一个类的实例化延迟到其子类 享元模式：运用共享技术有效地支持大量细粒度对象 解释器模式：给定一个语言，定义其文法的一种表示。并定义一个解释器，该解释器使用定义的表示来解释语言中的句子 迭代模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示 调停者模式：用一个中介对象来封装一系列的对象交互，中介使各对象不需要显示地相互引用。从而使其耦合松散，而且可以独立地改变它们之间的交互 备忘录模式：在不破坏封装性的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到保存的状态 观察者模式：定义对象间的一种一对多的依赖关系，以在一个对象的状态发生改变时所有依赖于它的对象都得到通知并自动刷新 原型模式：用原型实例指定创建对象的种类，并且通过复制这个原型来创建新的对象 代理模式：为其他对象提供一个代理以控制对这个对象的访问 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点 状态模式：允许一个对象在其内部状态改变时改变其行为，对象看起来似乎修改了它所属的类 策略模式：定义一系列的算法将其逐个封装起来，并且使它们可相互替换。 模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 访问者模式：表示一个作用于某对象结构中的各元素的操作使得在不改变各元素的类的前提下定义作用于这些元素的新操作]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试汇总帖-4]]></title>
    <url>%2F2018%2F10%2F04%2F%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93%E5%B8%96-4%2F</url>
    <content type="text"><![CDATA[&gt; 记在本子上忘记是哪些公司的笔试了誒..将就吧有些没找到答案 1、使用DOM解析XML使用DOM方式进行xml文档的写入和解析的方法 DOM解析XML文档时会遍历整个XML文档，在内存中建立一个树的数据结构。 与JavaScript中DOM方法类似，可以通过getElementsByTagName方法获取到特定的标签对象 当同样的标签很多的话使用List来存储返回的多个标签对象 通过DOM写XML文档 创建了节点之后依次连接到父节点上 后通过Transformer把驻留在内存中建立好的DOM树通过io流写入到特定文本 2、数据仓库粒度的具体划分将直接影响数据仓库中的数据量以及查询质量(true)3、哪种方法创建对象时不会调用类的构造函数Java创建对象的方式 用new语句创建对象，这是最常见的创建对象的方法 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法 调用对象的clone()方法 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法 4、stringbuffer/stringbuilder区别主要是在运行速度和线程安全 StringBuffer 与 StringBuilder 中的方法和功能完全是等价的 StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低。 5、B类地址 B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址。另外第1个字节的前两位固定为10。 一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，即第一段数字范围为128～191。 每个B类地址可连接65534(256*256-2, 因为主机号的各位不能同时为0,1)台主机，Internet有16383(2^14)个B类地址 6、开销最大的缓存替换算法（FIFO）缓存算法是指令的一个明细表，用于决定缓存系统中哪些数据应该被删去。 最不经常使用算法（LFU）：使用一个计数器来记录条目被访问的频率。通过使用LFU缓存算法，最低访问数的条目首先被移除。这个方法并不经常使用，因为它无法对一个拥有最初高访问率之后长时间没有被访问的条目缓存负责。 最近最少使用算法（LRU）：将最近使用的条目存放到靠近缓存顶部的位置。当一个新条目被访问时，LRU将它放置到缓存的顶部。当缓存达到极限时，较早之前访问的条目将从缓存底部开始被移除。这里会使用到昂贵的算法，而且它需要记录“年龄位”来精确显示条目是何时被访问的。此外，当一个LRU缓存算法删除某个条目后，“年龄位”将随其他条目发生改变。 自适应缓存替换算法(ARC)：在IBM Almaden研究中心开发，这个缓存算法同时跟踪记录LFU和LRU，以及驱逐缓存条目，来获得可用缓存的最佳使用。 先进先出算法（FIFO）：FIFO是英文First In First Out 的缩写，是一种先进先出的数据缓存器，他与普通存储器的区别是没有外部读写地址线，这样使用起来非常简单，但缺点就是只能顺序写入数据，顺序的读出数据，其数据地址由内部读写指针自动加1完成，不能像普通存储器那样可以由地址线决定读取或写入某个指定的地址。 最近最常使用算法（MRU）：这个缓存算法最先移除最近最常使用的条目。一个MRU算法擅长处理一个条目越久，越容易被访问的情况。 7、指令流水线为提高处理器执行指令的效率，把一条指令的操作分成多个细小的步骤，每个步骤由专门的电路完成的方式。 8、在地址栏输入“…jsp”，直到浏览器渲染网页完毕为止，期间发生的所有事件 浏览器（客户端）进行地址解析。 将解析出的域名进行dns解析。 通过ip寻址和arp，找到目标（服务器）地址。 进行tcp三次握手，建立tcp连接。 浏览器发送数据，等待服务器响应。 服务器处理请求，并对请求做出响应。 浏览器收到服务器响应，得到html代码。 渲染页面。9、如何判断单向链表是否存在环（找出环入口） 12345678910111213141516171819public class Solution &#123; ListNode EntryNodeOfLoop(ListNode h)&#123; if(h == null || h.next == null) return null; ListNode slow = h; ListNode fast = h; while(fast != null &amp;&amp; fast.next != null )&#123; slow = slow.next; fast = fast.next.next; if(slow == fast)&#123; ListNode p=h; ListNode q=slow;//相当于让q指向了m1 while(p != q)&#123; p = p.next; q = q.next; &#125; if(p == q) return q; &#125; &#125; return null; &#125; 10、关键字 finial修饰局部变量，transient方法？private顶层类？volatile构造类？ static 静态修饰关键字，可以修饰 变量，程序块，类的方法； final 只能赋值一次；修饰变量、方法及类 transient 类型修饰符，只能用来修饰字段 volatile变量修饰符，只能用来修饰变量。 11、代理类 （动态代理类与静态代理类必须由开发人员编写源代码并编译成.class文件）（Proxy类提供了创建动态代理类方法）（代理类与被代理类有相同的接口） 代理类，是类的代理，将类给代理，不直接调用类的方法，而通过代理来调用。 Proxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。 构造方法： 1234567private Proxy() &#123; &#125;protected Proxy(InvocationHandler h) &#123; this.h = h;&#125; 12、IO reader字符？inputstream字节？objectinputstream不支持序列化对象/reader支持序列 ObjectInputStream 类和 ObjectInputStream 类不支持序列化的对象 用Reader 和Writer可以把对象用字符的形式序列化 13、多态 体现面向对象多态基本特征：方法重载/方法重写/匿名类/内部类 子类重写父类的方法 父类引用指向子类对象 接口匿名对象实现多态 14、ArrayList和vector Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。 15、数组比线性表速度更快：返回中间节点/选择随机节点/原地逆序 访问中间节点，数组可以通过array[length/2]访问，链表需要依次查找到中间节点。 数组是顺序存储的线性表，相对于链表而言主要的优点就是可以通过下标随机访问数组中的任意元素 数组可以头尾交换，相当于处理n/2个数据，而链表至少得完整遍历一遍 16、堆排序在最坏情况下的时间复杂度（O(nlogn)）堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了 17、哈希冲突 线性表{15,38,31,20,28,14,37,50,22,25}，散列h(k)=k%11，采用平方探测再散列处理冲突 18、分支限界法 0-1背包问题，容量为10，重量为{4,7,5,3}，价值为{40,42,25,12}，得到上下界为 19、递归 递归算法包括终止条件和迭代（递归）、递归过程转换为非递归过程用队列（栈）模拟 20、快速排序算法 哪种轴值选择效率最高（取第一个记录，中间记录和最后一个记录三者中值居中的作为轴值） 21、SCAN寻道SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。 22、平衡二叉树寻找23、赫尔曼编码 根据使用频率为4个字符设计的赫尔曼编码可能是（00,01,10,11） 步骤： 将各种节点并排排列，最好按照权重从小到大； 找权重最小的两个节点，构成一个新二叉树；树根权重= 左子数权重+右子树权重； 重复上述步骤，知道只剩下最后一颗数为止； 24、平衡二叉树深度对于一棵平衡树，如果以Nh表示深度为h时含有的最少结点数。有如下的规律： N0=0,N1=1,N2=2; Nh=Nh−1+Nh−2+1 25、若串s=“facetime”，其子串个数为（37） 字串： n（n+1）/2 + 1 非空子串：n（n+1）/2 非空真子串：n（n+1）/2 - 1 26、String方法 设s=“abcaabcaaabc”，s1=“opq”，concat(substring(5,4,5),51)为（abcaopq） concat（）方法首先获取拼接字符串的长度，判断这个字符串长度是否为0（判断这个用来拼接的字符串是不是空串），如果是就返回原来的字符串（等于没有拼接）；否则就获取源字符串的长度 substring()是根据索引截取字符串 27、MySQL存储过程优点优点： 存储过程允许标准组件式编程，提高了SQL语句的重用性、共享性和可移植性。 存储过程可以被作为一种安全机制来利用。 存储过程能够实现较快的执行速度，能够减少网络流量。 缺点： 存储过程的编写比单句SQL语句复杂。 在编写存储过程时，需要创建这些数据库对象的权限。 28、第一个体现结构化思想编程语言Pascal 29、运行Test.class: java Test.class 编译程序：javac Hello.java 形成Hello.class 对生成的Hello.class在JVM上执行，输入java Hello 30、HTML5标签(略)31、IP协议属于（网络层协议）32、CSMA/CD协议特点：可抢占性/全双工 CSMA/CD的基本原理是：每个节点都共享网络传输信道，在每个站要发送数据之前，都会检测信道是否空闲，如果空闲则发送，否则就等待；在发送出信息后，则对冲突进行检测，当发现冲突时，则取消发送。 全双工模式接收和发送数据分开，不会产生冲撞域 33、已知先序ADCEFGHB，中序CDFEGHAB，后序CFHGEDBA（true）34、sql用于将事务处理写到数据库35、运算符优先顺序：赋值&lt;与&lt;关系&lt;算术36、二分查找 18有序元素、A[19]，第一个放A[1]，查找A[3]下标依次为（9,5,2,3） 37、正则表达式 实现一个验证密码强度的正则表达式，要求最少6位，一大一小一数一符 38、指针Java语言不允许使用（指针）访问内存，更不允许（指针数组）访问内存 39、XSS攻击/SQL注入攻击/CSRF攻击 XSS全称cross-site scripting（跨站点脚本），是当前 web 应用中最危险和最普遍的漏洞之一。攻击者向网页中注入恶意脚本，当用户浏览网页时，脚本就会执行，进而影响用户，比如关不完的网站、盗取用户的 cookie 信息从而伪装成用户去操作，携带木马等等。 反射型XSS（非持久性跨站攻击） 存储型XSS（持久性跨站攻击） DOM Based XSS（基于 dom 的跨站点脚本攻击） SQL注入，顾名思义就是通过注入SQL命令来进行攻击，更确切地说攻击者把SQL命令插入到web表单或请求参数的查询字符串里面提交给服务器，从而让服务器执行执行的该SQL。 CSRF攻击，全程Cross Site Request Forgery（跨站请求伪造），攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，从而进行操作。 40、for和while的区别 如果一个需求明确循环的次数,那么使用for循环(开发中使用for循环的几率大于while循环) 如果一个需求,不知道循环了多少次,使用while循环 41、暗黑 把ABC归为一组，总有六种情况，遍历子串，count++，(n-z)-count，查找含ABC…若ABC/BAC..六种情况为纯洁。给出n个，求暗黑个数 42、在保护模式下，通过调用门，可以实现不同特权级之间的代码转移（true）通过调用门，在不同特权级别的代码段之间进行转移 43、使用队列做辅助存储空间：广度优先搜索图 深度优先搜索要借助栈 广度优先搜索要借助队列 44、属于mysql流程控制（case when） CASE 语句 IF 语句 IFNULL NULLIF 45、Java Set中对象特点特点：无序，不可重复 46、原型模式的本质本质:对象的拷贝 47、折半查找条件 存储在数组中（例如一维数组） 数组元素为有序（例如升序） 48、DAG/DFS 有向无环图DAG，指任意一条边有方向，且不存在环路的图。如果有一个非有向无环图，且A点出发向B经C可回到A，形成一个环。将从C到A的边方向改为从A到C，则变成有向无环图。有向无环图的生成树个数等于入度非零的节点的入度积。 深度优先遍历（DFS）； 访问指定的起始顶点； 若当前访问的顶点的邻接顶点有未被访问的，则任选一个访问之；反之，退回到最近访问过的顶点；直到与起始顶点相通的全部顶点都访问完毕； 若此时图中尚有顶点未被访问，则再选其中一个顶点作为起始顶点并访问之，转 2； 反之，遍历结束。 49、简述java web 中getAttribute()和getParameter() 根本上的差异，getAttribute得到的是对象，而getParameter得到的是字符串。 Parameter一般用于常规的http通信，如表单提交，url参数等，此时如果使用getAttribute则得不到任何结果 Attribute专门适用于java web容器内部各组件之间的交流，因为可以放下一整个对象，则可以传递更为丰富的信息，且getAttribute() 得到的数据对应的是得用setAttribute()来取出来。 50、返回第一次匹配字符串位置indexOf()方法可返某个指定的子字符串值在字符串中首次出现的位置 51、100，随机10组，每组10个，数字1和数字2分到同一组概率1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#define R (abs(rand())%100)int group[100],i,j,k,p;int member[10][10],members[10];int main()&#123; for(i=0;i&lt;100;i++)group[i]=i; srand(time(NULL)); for(j = R + 100;j--;) &#123; i=R;k=R; p=group[i]; group[i] = group[k]; group[k] = p; &#125; for(i=0;i&lt;100;i++) &#123; member[group[i]/10][members[group[i]/10]] = i; members[group[i]/10]++; &#125; for(i=0;i&lt;10;i++) &#123; printf(&quot;第 %02d 组 : &quot;,i+1); for(j=0;j&lt;10;j++) &#123; printf(&quot;%03d%c&quot;,member[i][j]+1,j==9?10:32); &#125; &#125;&#125; 52、链表法解决冲突将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。 53、TTL字段TTL（生存时间值）：Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4包头的一个8 bit字段。 54、输入正整数n，d，n为字符串，n的子串被d整除的个数55、可被多个线程共享（data section/file fd）线程共享的内容 进程代码段 进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、 进程打开的文件描述符、 信号的处理器、 进程的当前目录和 进程用户ID与进程组ID 线程独有的内容包括 线程ID 寄存器组的值 线程的堆栈 错误返回码 线程的信号屏蔽码 56、小顶堆的中序遍历57、稳定的排序算法 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法 冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法 58、结构型设计模式结构型模式共七种： 适配器模式（Adapter） 外观模式（Facade） 桥接模式（Bridge） 装饰器模式（Decorator） 代理模式（Proxy） 享元模式（Flyweight） 组合模式（Composite） 其中又分为 接口适配：适配器、外观、桥接模式 行为扩展：装饰 性能与对象访问：代理、享元模式 抽象集合：组合模式 59、ICMP协议功能Internet Control Message Protocol 侦测远端主机是否存在 建立及维护路由资料 重导数据传送路径 数据流量控制 60、不引起进程阻塞进程阻塞的原因 等待I/O 进程sleep 等待解锁 61、稳定且平均时间复杂度最优算法(归并排序)62、二分查找（顺序）63、地址传递 值传递：传递的只是一份副本。 特点：调用者可以保护自己空间值不被修改。【保护】 缺点：因为每次调用都会传递一份副本，因此内存消耗很大，工程中不建议使用。 地址传递：传递的门牌号 特点：调用者让被调者修改自己的空间值。【修改】 用处： 调用者让被调者修改自己的空间值 连续空间的传递 优点：不用拷贝副本，可以节约空间。 64、Linux改变文件所有者命令：chown65、byte b=0x175十六进制数不能赋给byte类型的数据，数据有误 66、逻辑短路运算符在Java中短路运算符指的是”&amp;&amp;”(与) 和”||”(或) ,非短路运算符指的是”&amp;” 和”|”. 如果 “&amp;&amp;” 运算符的第一个表达式为false,则第二个表达式就不会执行 如果 “||” 运算符的第一个表达式为true,则第二个表达式就不会执行 67、Map的value可以是list或Map（true）68、js变量默认值：undefined undefined：是所有没有赋值变量的默认值，自动赋值 null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址 69、jdk核心源码：src目录（true）70、分支覆盖测试用例判定覆盖也被成为分支覆盖(Branch Coverage)，也就是说设计的测试用例要保证让被测试程序中的每一个分支都至少执行一次 71、冒烟测试冒烟测试的对象是每一个新编译的需要正式测试的软件版本，目的是确认软件基本功能正常，可以进行后续的正式测试工作 72、HTTP服务器端错误 400 非法请求(Bad Request)：如果请求的语法不对，服务器将无法理解。客户端在对该请求做出更改之前，不应再次向服务器重复发送该请求。 401 未授权(Unauthorized)：请求需要用户授权。客户端应使用合适的授权标题域来重复该请求。如果请求中已经包括了授权信任信息，那回应的401表示此授权被拒绝。如果用户代理在多次尝试之后，回应一样还是返回401状态代码，用户应当察看一下回应的实体，因为在实体中会包括一些相关的动态信息。 403 禁止(Forbidden)：服务器理解请求，但是拒绝实现该请求。授权对此没有帮助，客户端应当停止重复发送此请求。如果不是用HEAD请求方法，而且服务器端愿意公布请求未被实现原因的前提下，服务器会将拒绝原因写在回应实体中。该状态码一般用于服务器端不想公布请求被拒绝的细节或没有其它的回应可用。 404 没有找到(Not Found)：服务器没有找到与请求URI相符的资源。404状态码并不指明状况是临时性的还是永久性的。如果服务器不希望为客户端提供这方面的信息，还回应403(禁止)状态码。 服务器错误(Server Error )5xx：回应代码以‘5’开头的状态码表示服务器端发现自己出现错误，不能继续执行请求。如果客户端在收到5xx状态码时，请求尚未完成，它应当立即停止向服务器发送数据。除了回应HEAD请求外，服务器应当在其回应实体中包括对错误情况的解释、并指明是临时性的还是永久性的。 73、Linux强制删除非空目录rm -rf 目录名字 -r 向下递归，不管有多少级目录，一并删除 -f 直接强行删除，不作任何提示的意思 1、删除/var/log/httpd/access目录以及其下所有文件、文件夹 1rm -rf /var/log/httpd/access 2、强制删除/var/log/httpd/access.log这个文件 1rm -f /var/log/httpd/access.log 74、TCP拥塞控制方法 慢开始( slow-start ) 拥塞避免( congestion avoidance ) 快重传( fast retransmit ) 快恢复( fast recovery ) 75、二分查找and二叉排序树（对于有序序列，非递归时度&lt;递归）76、sleep()/wait() 由于sleep()方法是Thread类的方法，因此它不能改变对象的机锁。所以当在一个Synchronized方法中调用sleep（）时，线程虽然休眠了，但是对象的机锁没有被释放，其他线程仍然无法访问这个对象。而wait()方法则会在线程休眠的同时释放掉机锁，其他线程可以访问该对象。 Thread.sleep(long)可以不在synchronized的块下调用，而且使用Thread.sleep()不会丢失当前线程对任何对象的同步锁(monitor); object.wait(long)必须在synchronized的块下来使用，调用了之后失去对object的monitor, 这样做的好处是它不影响其它的线程对object进行操作。utm_source=copy 77、防止死锁发生 破坏互斥条件 破坏请求并保持条件 破坏不可剥夺条件 破坏循环等待条件 78、Python类、操作、属性（_add）如果用dir(list)查看list的属性，能看到一个属性是add() 79、shell脚本输出 $echo hello world $echo ‘hello world’ $echo “hello world” 80、不能用来修饰interface接口可以使用public和默认的进行修饰 81、分时操作系统，进程调度采用“时间片轮转”(true)82、ROM中存放的信息在计算机断电后内容（不会丢失） rom是只读储存器，不可以写入，也不会丢失 ram是电记忆的读写储存器，掉电后数据丢失 83、in interval(0,11)84、处理外部中断时，应该由操作系统保存（程序计数器PC）外部中断处理过程首先要保护现场，使得中断处理完之后能够恢复程序的执行状态继续执行。保护现场有两个含义 由中断隐指令保存程序的断点（程序计数器） 由中断服务程序保存通用寄存器和状态寄存器的内容，中断服务程序是操作系统的一部分。 85、在jsp可以操作cookie/jsp在浏览器的执行是单线程的86、微型计算机的cache是（高速缓冲存储器）87、最速下降法 给定初始点x0=(1,1),用最速下降法求函数f(x)=4x1+6x2-2x1^2-2x1x2-2x2^2的极大值，则迭代一次后x1的值（-1、1/2、-1/2、2，1）？ 88、发货功能测试用例89、双向链表定义双向链表，每个数据结点中都有两个结点，分别指向其直接前驱和直接后继。所以我们从双向链表的任意一个结点开始都可以很方便的访问其前驱元素和后继元素。 90、词法分析阶段错误词法分析，将字符序列转换为单词（Token）序列的过程 91、序列安全（银行家算法）92、？？ p=q=r=(char)malloc(sizeof(char)20);strcpy(p,”attaboy,welcome!”,p[11],q[3],r[4])cta/lta/lab/cab 93、变量在内存中的存储位置12345678910int a=0;class someClass&#123; int b; static int c;&#125;;int main()&#123; int d=0; someClass *p=new someClass(); return 0;&#125; java中变量的存储位置 寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制. 栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。） 堆：存放所有new出来的对象。 静态域：存放静态成员（static定义的） 常量池：存放字符串常量和基本类型常量（public static final）。 非RAM存储：硬盘等永久存储空间 94、进程通信/进程同步进程通信方式 信号 管道 消息队列 共享内存 进程同步的四种方法 临界区（Critical Section）:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 互斥量（Mutex）:为协调共同对一个共享资源的单独访问而设计的。 信号量（Semaphore）:为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。 事件（Event）: 用来通知线程有一些事件已发生，从而启动后继任务的开始。 95、网络服务接口，Linux $/sbin/ifconfig 查看所有活动网络接口信息，其中包括一个lo环回端口。 $/sbin/ifconfig &lt;网络接口名称&gt; 查看指定接口信息。 $/sbin/ifconfig –a 查看所有接口信息，包括非活动状态接口。 #/route：显示当前linux主机中的路由表信息。 $ping 目的主机地址：使用ping命令测试与其它主机的网络链接。ctrl+C终止。 $traceroute &lt;目的主机地址&gt;：traceroute命令显示当前主机与目的主机之间经过的所，有网络节点的地址，以及当前主机到每个中间结点的连接状态。 $Hostname 查看当前的主机名。 $Nslookup：使用dns服务器查询域名 $Dhclient 使用dhclient命令可以从DHCP服务器中申请新的网络配置应用到当前主机。 Ip地址配置命令：Ifconfig &lt;网络接口名称&gt; network &lt;子网掩码&gt; $Route del default gw &lt;默认网关地址&gt;删除默认网关路由 $Route add default gw &lt;默认网关地址&gt;：添加默认网关路由 #hostname 123：主机名称配置命令 #/etc/rc.d/init.d/network start 启动network #/etc/rc.d/init.d/network stop 停止network #/etc/rc.d/init.d/network restart 重启network /etc/sysconfig/network-scripts/ifconfg-*：网络接口配置文件 #ifconfig eth0 down 停止eth0接口 #ifconfig eth0 up 开启eth0接口 96、匹配输出log文件中第5行的数字并由小到大排序linux 如何显示一个文件的某几行(中间几行) 从第3000行开始，显示1000行。即显示3000~3999行cat filename | tail -n +3000 | head -n 1000 显示1000行到3000行cat filename| head -n 3000 | tail -n +1000 tail -n 1000：显示最后1000行 tail -n +1000：从1000行开始显示，显示1000行以后的 head -n 1000：显示前面1000行 用sed命令sed -n ‘5,10p’ filename ，查看文件的第5行到第10行。]]></content>
      <categories>
        <category>笔经面经</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试汇总帖-1]]></title>
    <url>%2F2018%2F10%2F04%2F%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB%E5%B8%96-1%2F</url>
    <content type="text"><![CDATA[鉴于本人比较菜鸡，技术面只有两次，谈天谈地的吹水就不计入了.. 9.21：平安银行（线下）1.java访问控制权限，范围 public：共有的，对所有类可见。 protected：受保护的，对同一包内的类和所有子类可见。 private：私有的，在同一类内可见。 默认的：在同一包内可见。默认不使用任何修饰符。 2.抽象类和接口区别抽象类： 可以有默认的方法实现 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 抽象类可以有构造器 除了不能实例化抽象类之外，它和普通Java类没有任何区别 抽象方法可以有public、protected和default这些修饰符 抽象方法可以有main方法并且可以运行它 抽象方法可以继承一个类和实现多个接口 比接口速度要快 如果往抽象类中添加新的方法，可以给它提供默认的实现。因此不需要改变现在的代码。 接口: 完全是抽象的,根本不存在方法的实现 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 接口不能有构造器 接口是完全不同的类型 接口方法默认修饰符是public。你不可以使用其它修饰符。 接口没有main方法，因此不能运行它。 接口只可以继承一个或多个其它接口 接口速度有点慢，需要时间去寻找在类中实现的方法。 如果往接口中添加方法，那么必须改变实现该接口的类。 3.数据库事务4.ssm买入卖出（主要问项目）5.前端是怎么获取后台数据（常问）6.controller主要写什么7.mybatis逆向工具生成javabean和mapper8.final的值9.建表建索引10.内存泄露11.@session9.30：奇迹智慧（电话面）1、二叉树是什么 在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2k-1个节点，至多有2k-1个节点。 2、排序二叉树二叉排序树或者是一棵空树，或者是具有下列性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于它的根结点的值； 左、右子树也分别为二叉排序树； 没有键值相等的节点。 3、平衡二叉树 可用于Java的哪个类（数据结构转换成【应用场景】 单向链接单向链表适用于只从一端单向访问的场合，这种场合一般来说： 删除时，只适合删除第一个元素； 添加时，只直接添加到最后一个元素的后面或者添加到第一个元素的前面； 属于单向迭代器，只能从一个方向走到头（只支持前进或后退，取决于实现），查找效率极差。不适合大量查询的场合。这种典型的应用场合是各类缓冲池和栈的实现。 双向链表双向链表相比单向链表，拥有前向和后向两个指针地址，所以适合以下场合： 删除时，可以删除任意元素，而只需要极小的开销； 添加时，当知道它的前一个或后一个位置的元素时，只需要极小的开销。 属于双向迭代器，可以从头走到尾或从尾走到头，但同样查找时需要遍历，效率与单向链表无改善，不适合大量查询的场合。这种典型的应用场景是各种不需要排序的数据列表管理。 数组（含Delphi中动态数组）、列表（Delphi/C++ Builder中的TList）向量（C++中std::vector）这种数据结构使用一段连续的空间来存贮元素，所以可以直接通过索引来获取到某个元素，而且可以通过对元素的内容进行排序，然后使用二分法查找，从而提供查找效率。其适合的场合主要是： 不会频繁增删元素的场合，因为增删元素都牵涉到元素空间的重新分配，频繁的内存分配操作会大幅降低操作效率。但添加操作时，可以通过预分配足够的空间来优化添加时的效率。 属于随机迭代器，可以随机访问任意元素。对于已排序的元素查找起来效率较高。 二叉树（含红黑树、平衡二叉树等）这个数据结构类似于双向链表，任意插入元素时都会自动排序，红黑树和平衡二叉树都使二叉树尽量平衡，从而使查询时和二分法类似。它适合的场合主要是： 需要时刻保证列表元素的有序排列； 需要频繁的增删和查询操作； 属于双向迭代器，不能随机访问任意元素； 哈希桶这个数据结构使用数组和链表来管理元素，在好的桶尺寸和哈希算法支持下，理想上可以达到接近数组的随机访问效率。其适合的场合主要是： 不需要保证元素的顺序（因为它是按哈希值决定插入到那个桶里，与原始数据内容无关）； 需要频繁的增删和查询操作； 属于单向或双向迭代器（取决于具体实现），不能随机访问任意元素。 4、红黑树红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求: 性质1. 节点是红色或黑色。 性质2. 根节点是黑色。 性质3 每个叶节点（NIL节点，空节点）是黑色的。 性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。要知道为什么这些特性确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点不包含数据。用这种范例表示红黑树是可能的，但是这会改变一些属性并使算法复杂。为此，本文中我们使用 “nil 叶子” 或”空(null)叶子”，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好象同上述原则相矛盾，而实际上不是这样。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。 5、ArrayList和Linkedlist，继承哪个类，哪个接口List 源代码如下： 1public interface List&lt;E&gt; extends Collection&lt;E&gt;【接口】 一个 List 是一个元素有序的、可以重复、可以为 null 的集合（有时候我们也叫它“序列”）。Java 集合框架中最常使用的几种 List 实现类是 ArrayList，LinkedList 和 Vector。在各种 List 中，最好的做法是以 ArrayList 作为默认选择。 6、hash表是怎么存放以关键字Key为自变量，通过一定的函数关系（散列函数或哈希函数），计算出对应的函数值（哈希地址），以这个值作为数据元素的地址，并将数据元素存入到相应地址的存储单元中。 7、数据库事务隔离级别，MySQL5.5默认级别 READ UNCOMMITTED（读未提交数据）：允许事务读取未被其他事务提交的变更数据，会出现脏读、不可重复读和幻读问题。 READ COMMITTED（读已提交数据）：只允许事务读取已经被其他事务提交的变更数据，可避免脏读，仍会出现不可重复读和幻读问题。 REPEATABLE READ（可重复读）：确保事务可以多次从一个字段中读取相同的值，在此事务持续期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读，仍会出现幻读问题。 SERIALIZABLE（序列化）：确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，可避免所有并发问题，但性能非常低。 REPEATABLE READ为默认事务隔离级别。 8、项目 事务(穷举，捕获异常)9、Java基本特征：封装、继承、多态、（没有面向对象） 10、多态 方法重载、方法重写多态 多态，意味着一个对象有着多重特征，可以在特定的情况下，表现不同的状态，从而对应着不同的属性和方法。 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。 多态，允许方法重名 参数或返回值可以是父类型传入或返回。 区别 重载是多态的一种形式，是一个类的内部，方法多个参数，根据入参的个数不同，返回不同的结果。 多态指的是多种形态，比如说同一个变量可以是数组，字符、串整型。 重写，是子类继承父类，重写父类的方法。 重载重写 父类和子类同名方法，参数也是父类和子类的方法，不不构成重写，是重载。 实参的子类对象，赋值给形参父类引用，也是父类引用指向子类对象 判断多态，一定需要判断一下，是否子类重写了父类方法 父类引用，调用不了子类对象特有的方法。只能调用子类对象继承的方法和多态重写的方法 构造函数不能重写 @Override 在编译阶段判断父类有没有此方法，是不是重写 返回值不同，不是重载，因为根本不知道要调用哪个函数，编译报错 重载： 方法名相同 参数列表不同（参数类型，个数，顺序） 重写： 方法名相同 参数列表完全相同（参数类型，个数，顺序） 11、Java数据类型拆箱装箱 装箱：自动将基本数据类型转换为包装器类型 拆箱：自动将包装器类型转换为基本数据类型 12、线程方法线程的常用方法 start() ： 线程调用该方法将启动线程，使之从新建状态进入就绪队列排队，一旦轮到它来享用CPU资源时，就可以脱离创建它的线程独立开始自己的生命周期了。 run(): Thread类的run()方法与Runnable接口中的run()方法的功能和作用相同，都用来定义线程对象被调度之后所执行的操作，都是系统自动调用而用户程序不得引用的方法。 sleep(int millsecond): 优先级高的线程可以在它的run()方法中调用sleep方法来使自己放弃CPU资源，休眠一段时间。 isAlive(): 线程处于“新建”状态时，线程调用isAlive()方法返回false。在线程的run()方法结束之前，即没有进入死亡状态之前，线程调用isAlive()方法返回true. currentThread():该方法是Thread类中的类方法，可以用类名调用，该方法返回当前正在使用CPU资源的线程。 interrupt() ：一个占有CPU资源的线程可以让休眠的线程调用interrupt()方法“吵醒”自己，即导致休眠的线程发生InterruptedException异常，从而结束休眠，重新排队等待CPU资源。 线程的额外用法 线程名称:在Thread类中可以通过getName()方法取得线程名称，通过setName()设置线程名称。 当前线程:CurrentThread() 程序可以通过currentThread()方法取得当前正在运行的线程对象 判断线程是否在执行：isAlive 线程强制运行：join()，可以通过join()方法使得一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后，才可以继续运行。 线程的休眠：在线程中允许一个线程进行暂时的休眠，直接使用Thread.sleep()方法即可。 线程的中断：一个线程可以被另一个线程中断其操作的状态，使用 interrupt（）方法完成。 后台线程：在Java中，只要一个线程没有执行完（一个线程在运行），则整个Java的进程不会消失，所以此时可以设置一个后台线程，这样即使java线程结束了，则后台线程依旧会继续执行。要想实现这个操作，要使用setDaemon()方法完成。 线程的优先级:获取优先级的方法：getPriority(); 优先级分为最低，最高，普通三个（Thread.MIN_PRIORITY，Thread.MAX_PRIORITY，Thread.NORM_PRIORITY） 线程的礼让 yield()方法实现线程的礼让。 13、start()和run()区别实现并启动线程有两种方法： 写一个类继承自Thread类，重写run方法。用start方法启动线程 写一个类实现Runnable接口，实现run方法。用new Thread(Runnable target).start()方法来启动 区别 start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。 run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。 14、有什么想问的吗15、object类的方法有哪些Object类成员方法 构造函数 hashCode和equale函数用来判断对象是否相同, wait(),wait(long),wait(long,int),notify(),notifyAll() toString()和getClass, clone() finalize()用于在垃圾回收 具体用法 clone()函数的用途是用来另存一个当前存在的对象。 hashCode()和equal() equal()用于确认两个对象是否相同。 hashCode()用于获取对象的哈希值，这个值的作用是检索，哈希值相同的对象不一定equal()，而equale()返回true的两个对象一定相同。 toString()和getClass() toString()返回一个String对象，用来标识自己 getClass()返回一个Class对象，如果打印出来会发现结果是class package.name.xxx 。因为返回的是一个class对象,后面可以跟class类的方法。用的是谁的构造函数，那么getClass返回的就是谁的类型。 getClass()经常用于java反射机制 wait(),wait(long),wait(long,int),notify(),notifyAll()，这几个函数体现的是Java的多线程机制，在使用的时候要求在synchronize语句中使用 wait()用于让当前线程失去操作权限，当前线程进入等待序列 notify()用于随机通知一个持有对象的锁的线程获取操作权限 notifyAll()用于通知所有持有对象的锁的线程获取操作权限 wait(long) 和wait(long,int)用于设定下一次获取锁的距离当前释放锁的时间间隔 finalize()：这个函数在进行垃圾回收的时候会用到，匿名对象回收之前会调用到]]></content>
      <categories>
        <category>笔经面经</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构常用命令]]></title>
    <url>%2F2018%2F10%2F04%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[flushdb：清空当前Redis服务器所有存储内容的命令 字符串 set key value：设置键值对 get key：通过键获取值 del key：通过key删除键值对 strlen key：求key指向字符串的长度 getset key value：修改原来key的对应值，并将旧值返回 getrange key start end：获取子串 append key value：将新的字符串value，加入到原来key指向的字符串末 简单运算 incr key：在原字段上+1 incrby key increment：在原字段上加上整数 decr key：在原字段上减1 decrby key decrement：在原字段上减去整数 incrbyfloat keyincrement：在原字段上加上浮点数 哈希 hdel key field1[field2..]：删除hash结构的某个字段 hexists key field：判断hash结构中是否存在field字段hgetall key：获取所有hash结构中的键值 hincrby key field increment：指定给hash结构中的某一字段加上一个整数 hincrbyfloat key field increment：指定给hash结构中的某一字段加上一个浮点数 hkeys key：返回hash中所有的键 hlen key：返回hash中键值对的数量 hmget key field1[field2..]：返回hash中指定的键的值，可以是多个 hmset key field1 value1 [field2 field2..]：hash结构设置多个键值对 hset key filed value：在hash结构中设置键值对hsetnx key fieldvalue：当hash结构中不存在对应的键，才设置值hvals key：获取hash结构中所有的值 链表 lpush key node1 [node2..]：把结点node1加入到链表的最左边rpush k ey node1[node2..]：把结点node1加入到链表的最右边 lindex key index：读取下标为index的节点 llen key：求链表的长度 lpop key：删除左边第一个节点，并将其返回 rpop key：删除右边第一个节点，并将其返回 linsert key before|after pivotnode：插入一个节点node，并且可以指定在值为pivot的节点的前面或后面 lpushx list node：如果存在key为list的链表，则插入节点node，并且作为从左到右的第一个节点 rpushx list node：如果存在key为list的链表，则插入节点node，并且作为从左到右的最后一个节点 lrange list start end：获取链表list从start下标到end下标的节点值 lrem list countvalue：若count为0，删除所有值为value的节点。否则取绝对值，从左到右删除不大于abs个等于value的节点 lset key index node：设置列表下标为index的节点的值为node ltrim key startstop：修剪链表，只保留从start到stop的区间的节点，其余的都删除掉 链表阻塞 blpop key timeout：移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 brpop key timeout：移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 rpoplpush key src dest：按从左到右的顺序，将一个链表的最后一个元素移除，并插入到目标链表的最左边 brpoplpush key src dest timeout：按从左到右的顺序，将一个链表的最后一个元素移除，并插入到目标链表的最左边，并可以设置超时时间 集合 sadd key member1 [member2..]：给键为key的集合增加成员 scard key：统计键为key的集合成员数 sdiff key1[key2]：找出两个集合的差集 sdiffstore des key1[key2]：先按sdiiff命令的规则，找出key1和key2两个集合的差集，然后将其保存到des集合中 sinter key1[key2]：求key1和key2两个集合的交集 sinterstore des key1 key2：先按sinter命令的规则，找出key1和key2两个集合的交集，然后保存到des中 sismember key member：判断member是否键为key的集合的成员 smembers key：返回集合所有成员 smove src des member：将成员member从集合src迁移到集合des中 spop key：随机弹出集合的一个元素 srandmember key[count]：随机返回集合中一个或者多个元素，count为限制返回总数 srem key member1 [member2..]：移除集合中的元素，可以是多个元素 sunion key1[key2]：求两个集合的并集 sunionstore des key1 key2：先执行sunion命令求出并集，然后保存到键为des的集合中 有序集合 zadd key score1 value1 [score2 value2…]：向有序集合的key，增加一个或者多个成员 zcard key：获取有序集合的成员数 zcount key min max：根据分数返回对应的成员列表 zincrby key increment member：给有序集合成员值为member的分数增加increment zinterstore desKey numkeys key1[key2 key2..]：求多个集合的交集，并且将结果保存到desKey中 zlexcount key min max：求有序集合key成员值在min和max的范围 zrange key start stop[withscores]：按照分值的大小（从小到大）返回成员，加入start和stop参数可以截取某一段返回 zrank key member：按从小到大求有序集合的排行 zrangebylex key min max [limit offset count]：根据值的大小，从小到大排序，返回对应成员 zrangebyscore key min max [withscores] [limit offset count]：根据分数大小，从小到大求取范围 zremrangebyscore key start stop：根据分数区间进行删除 zremrangebyrank key start stop：按照分数排行从小到大的排序删除，从0开始计算 zremrangebylex key min max：按照值的分布进行删除 zremrange key start stop [withscores]：从大到小的按分数排序 zrevrangebyscore key max min [withscores]：从大到小的按分数排序 zrevrank key member：按从大到小的顺序，求元素的排行 zscore key member：返回成员的分数值 zunionstore desKey numKeys key1[key2…]：求多个有序集合的并集，其中numKeys是有序集合的个数 基数 pfadd key element：添加指定元素到HyperLogLog中 pfcount key：返回HyperLogLog的基数值 pfmerge desKey key1[key2 key3….]：合并多个HyperLogLog，并将其保存在desKey中 事务有关操作 multi：在Redis中开启事务 exec：执行事务 discard：回滚事务 watch：决定事务是执行还是回滚 在执行事务命令时，在命令入队时，redis就会检测事务的命令是否正确 超时命令 persist key：持久化key，取消超时时间 ttl key：查看key的超时时间 expire key seconds：设置超时时间戳 expireat key timestamp：设置超时时间点 pptl key milliseconds：查看key的超时时间戳 pexpire key：设置键值超时的时间 pexpreat key stamptimes：设置超时时间点 主次架构 在多台数据服务器中，只有一台主服务器，而主服务器只负责写入数据，不负责让外部程序读取数据 存在多台从服务器，从服务器不写入数据，只负责同步主服务器的数据，并让外部程序读取数据 主服务器在写入数据后，即可将写入数据的命令发送给从服务器，从而使得主从数据同步 应用程序可以随机读取某一台从服务器的数据 当从服务器不能工作的时候，整个系统将不受影响；当主服务器不能工作的时候，可以方便地从服务器中选举一台来当主服务器 负载均衡器： 对业务请求做初步的分析 提供路由算法 限流 悲观锁：一种利用数据库内部机制提供的锁的方法，对更新的数据加锁。在并发期间一旦有一个事务持有了数据库记录的锁，其他的线程将不能再对数据进行更新了 对于悲观锁来说，当一条线程抢占了资源后，其他的线程将得不到资源，那么这个时候，CPU就会将这些得不到资源的线程挂起，挂起的线程也会消耗CPU的资源，尤其是在高并发的请求中 悲观锁，独占锁，只有一个线程可以独占这个资源，阻塞锁，造成其他线程的阻塞。无论如何都会造成并发能力的下降，从而导致CPU频繁切换线程上下文，造成性能低下 乐观锁：一种不会阻塞其他线程并发的机制，它不会使用数据库的锁进行实现。可重入锁，非阻塞锁 CAS原理：在线程开始阶段就读入线程共享数据，保存为旧值。当处理完逻辑，需要更新数据的时候，会进行一次比较，即比较各个线程当前共享的数据是否和旧值保持一致。如果一致就更新数据。如果不就不再更新，可以考虑重试或者放弃。 ABA问题：因为业务逻辑存在回退的可能性，用版本号消除 版本号规定：只要修改变量的数据，强制版本号只能递增而不会回退 乐观锁的重入机制 按时间戳的重入 按次数的重入]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm+redis全注解（高并发抢红包）]]></title>
    <url>%2F2018%2F10%2F04%2Fssm%2Bredis%E5%85%A8%E6%B3%A8%E8%A7%A3%EF%BC%88%E9%AB%98%E5%B9%B6%E5%8F%91%E6%8A%A2%E7%BA%A2%E5%8C%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、配置redis1、https://github.com/ServiceStack/redis-windows/blob/master/downloads/ 下载前两个文件，解压到同一目录，新建startup.cmd，用记事本编辑redis-server redis.windows.conf 保存后双击，点开redis-cli.exe（Redis自带客户端），完成 2、https://mvnrepository.com/artifact/redis.clients/jedis 在Java使用Redis工具需下载jedis.jar包，目前是2.9.0版本 3、测试代码：Java连接Redis（伪代码） 123456789101112131415161718Jedis jedis =new Jedis(“localhost”,6379); //jedis.auth(“password”);//如果需要密码 int i=0;//记录操作次数try&#123; long start=System.currentTimeMillis();//开始毫秒数 while(true)&#123; long end=System.currentTimeMillis(); if(end-start&gt;=1000)&#123;//当大于等于1000毫秒（相当于1秒）时，结束操作 break; &#125; i++; jedis.set(&quot;test&quot;+i,i+&quot;&quot;); &#125; &#125;finally&#123;//关闭连接 jedis.close(); &#125; System.out.println(&quot;redis每秒操作&quot;+i+&quot;次&quot;);//打印1秒内对Redis的操作次数&#125; 二、Java环境1、sql语句（mysql.sql）123456789101112131415161718192021222324252627282930313233343536373839404142create database redPacket;use redPacket;/*==============================================================*//* Table: 红包表 *//*==============================================================*/create table T_RED_PACKET( id int(12) not null auto_increment, user_id int(12) not null, amount decimal(16,2) not null, send_date timestamp not null, total int(12) not null, unit_amount decimal(12) not null, stock int(12) not null, version int(12) default 0 not null, note varchar(256) null, primary key clustered (id));/*==============================================================*//* Table: 用户抢红包表 *//*==============================================================*/create table T_USER_RED_PACKET ( id int(12) not null auto_increment, red_packet_id int(12) not null, user_id int(12) not null, amount decimal(16,2) not null, grab_time timestamp not null, note varchar(256) null, primary key clustered (id));/*** 插入一个20万元金额，2万个小红包，每个10元的红包数据*/insert into T_RED_PACKET(user_id, amount, send_date, total, unit_amount, stock, note) values(1, 200000.00, now(), 20000, 10.00, 20000,&apos;20万元金额，2万个小红包，每个10元&apos;); 2、建POJO RedPacket.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.ssm.pojo;import java.io.Serializable;import java.sql.Timestamp;public class RedPacket implements Serializable &#123; private Long id; private Long userId; private Double amount; private Timestamp sendDate; private Integer total; private Double unitAmount; private Integer stock; private Integer version; private String note; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public Long getUserId() &#123; return userId; &#125; public void setUserId(Long userId) &#123; this.userId = userId; &#125; public Double getAmount() &#123; return amount; &#125; public void setAmount(Double amount) &#123; this.amount = amount; &#125; public Timestamp getSendDate() &#123; return sendDate; &#125; public void setSendDate(Timestamp sendDate) &#123; this.sendDate = sendDate; &#125; public Integer getTotal() &#123; return total; &#125; public void setTotal(Integer total) &#123; this.total = total; &#125; public Double getUnitAmount() &#123; return unitAmount; &#125; public void setUnitAmount(Double unitAmount) &#123; this.unitAmount = unitAmount; &#125; public Integer getStock() &#123; return stock; &#125; public void setStock(Integer stock) &#123; this.stock = stock; &#125; public Integer getVersion() &#123; return version; &#125; public void setVersion(Integer version) &#123; this.version = version; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125; private static final long serialVersionUID = 1049397724701962381L;&#125; UserRedPacket.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.ssm.pojo;import java.io.Serializable;import java.sql.Timestamp;public class UserRedPacket implements Serializable &#123; private Long id; private Long redPacketId; private Long userId; private Double amount; private Timestamp grabTime; private String note; private static final long serialVersionUID = -5617482065991830143L; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public Long getRedPacketId() &#123; return redPacketId; &#125; public void setRedPacketId(Long redPacketId) &#123; this.redPacketId = redPacketId; &#125; public Long getUserId() &#123; return userId; &#125; public void setUserId(Long userId) &#123; this.userId = userId; &#125; public Double getAmount() &#123; return amount; &#125; public void setAmount(Double amount) &#123; this.amount = amount; &#125; public Timestamp getGrabTime() &#123; return grabTime; &#125; public void setGrabTime(Timestamp grabTime) &#123; this.grabTime = grabTime; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125; &#125; 3、导入jar包4、定义Dao对象和相应的mapper RedPacketDao.java 12345678910111213141516171819202122232425262728293031323334package com.ssm.dao;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import com.ssm.pojo.RedPacket;@Repositorypublic interface RedPacketDao &#123; /** * 获取红包信息. * @param id --红包id * @return 红包具体信息 */ public RedPacket getRedPacket(Long id); /** * 扣减抢红包数. * @param id -- 红包id * @return 更新记录条数 */ public int decreaseRedPacket(Long id); /*** * 使用for update语句加锁. * @param id ——红包id * @return 红包信息 */ public RedPacket getRedPacketForUpdate(Long id); public int decreaseRedPacketForVersion(@Param(&quot;id&quot;) Long id, @Param(&quot;version&quot;) Integer version); &#125; RedPacket.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ssm.dao.RedPacketDao&quot;&gt; &lt;!-- 查询红包具体信息 --&gt; &lt;select id=&quot;getRedPacket&quot; parameterType=&quot;long&quot; resultType=&quot;com.ssm.pojo.RedPacket&quot;&gt; select id, user_id as userId, amount, send_date as sendDate, total, unit_amount as unitAmount, stock, version, note from T_RED_PACKET where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 扣减抢红包库存 --&gt; &lt;update id=&quot;decreaseRedPacket&quot;&gt; update T_RED_PACKET set stock = stock - 1 where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 查询红包具体信息 --&gt; &lt;select id=&quot;getRedPacketForUpdate&quot; parameterType=&quot;long&quot; resultType=&quot;com.ssm.pojo.RedPacket&quot;&gt; select id, user_id as userId, amount, send_date as sendDate, total, unit_amount as unitAmount, stock, version, note from T_RED_PACKET where id = #&#123;id&#125; for update &lt;/select&gt; &lt;!-- 通过版本号扣减抢红包 每更新一次，版本增1， 其次增加对版本号的判断 --&gt; &lt;update id=&quot;decreaseRedPacketForVersion&quot;&gt; update T_RED_PACKET set stock = stock - 1, version = version + 1 where id = #&#123;id&#125; and version = #&#123;version&#125; &lt;/update&gt;&lt;/mapper&gt; UserRedPacketDao.java 123456789101112131415package com.ssm.dao;import org.springframework.stereotype.Repository;import com.ssm.pojo.UserRedPacket;@Repositorypublic interface UserRedPacketDao &#123; /** * 插入抢红包信息. * @param userRedPacket ——抢红包信息 * @return 影响记录数. */ public int grapRedPacket(UserRedPacket userRedPacket);&#125; UserRedPacket.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ssm.dao.UserRedPacketDao&quot;&gt; &lt;!-- 插入抢红包信息 --&gt; &lt;insert id=&quot;grapRedPacket&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; parameterType=&quot;com.ssm.pojo.UserRedPacket&quot;&gt; insert into T_USER_RED_PACKET( red_packet_id, user_id, amount, grab_time, note) values (#&#123;redPacketId&#125;, #&#123;userId&#125;, #&#123;amount&#125;, now(), #&#123;note&#125;) &lt;/insert&gt;&lt;/mapper&gt; 5、定义Service接口和其实现类 RedPacketService.java 123456789101112131415161718192021package com.ssm.service;import com.ssm.pojo.RedPacket;public interface RedPacketService &#123; /** * 获取红包 * @param id ——编号 * @return 红包信息 */ public RedPacket getRedPacket(Long id); /** * 扣减红包 * @param id——编号 * @return 影响条数. */ public int decreaseRedPacket(Long id); &#125; UserRedPacketService.java 123456789101112131415161718192021222324252627package com.ssm.service;public interface UserRedPacketService &#123; /** * 保存抢红包信息. * @param redPacketId 红包编号 * @param userId 抢红包用户编号 * @return 影响记录数. */ public int grapRedPacket(Long redPacketId, Long userId); public int grapRedPacketForVersion(Long redPacketId, Long userId); /** * 通过Redis实现抢红包 * @param redPacketId --红包编号 * @param userId -- 用户编号 * @return * 0-没有库存，失败 * 1--成功，且不是最后一个红包 * 2--成功，且是最后一个红包 */ public Long grapRedPacketByRedis(Long redPacketId, Long userId); &#125; RedPacketServiceImpl.java 配置了事务注解@Transactional，调用该方法时，没有事务会创建事务，如果有事务则沿用当前事务 12345678910111213141516171819202122232425262728293031package com.ssm.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import com.ssm.dao.RedPacketDao;import com.ssm.pojo.RedPacket;import com.ssm.service.RedPacketService;@Servicepublic class RedPacketServiceImpl implements RedPacketService &#123; @Autowired private RedPacketDao redPacketDao = null; @Override @Transactional(isolation=Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED) public RedPacket getRedPacket(Long id) &#123; return redPacketDao.getRedPacket(id); &#125; @Override @Transactional(isolation=Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED) public int decreaseRedPacket(Long id) &#123; return redPacketDao.decreaseRedPacket(id); &#125;&#125; UserRedPacketServiceImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211package com.ssm.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import com.ssm.dao.RedPacketDao;import com.ssm.dao.UserRedPacketDao;import com.ssm.pojo.RedPacket;import com.ssm.pojo.UserRedPacket;import com.ssm.service.RedisRedPacketService;import com.ssm.service.UserRedPacketService;import redis.clients.jedis.Jedis;@Servicepublic class UserRedPacketServiceImpl implements UserRedPacketService &#123; @Autowired private UserRedPacketDao userRedPacketDao = null; @Autowired private RedPacketDao redPacketDao = null; // 失败 private static final int FAILED = 0; @Override @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED) public int grapRedPacket(Long redPacketId, Long userId) &#123; // 获取红包信息 // RedPacket redPacket = redPacketDao.getRedPacket(redPacketId); // 悲观锁 RedPacket redPacket = redPacketDao.getRedPacketForUpdate(redPacketId); // 当前小红包库存大于0 if (redPacket.getStock() &gt; 0) &#123; redPacketDao.decreaseRedPacket(redPacketId); // 生成抢红包信息 UserRedPacket userRedPacket = new UserRedPacket(); userRedPacket.setRedPacketId(redPacketId); userRedPacket.setUserId(userId); userRedPacket.setAmount(redPacket.getUnitAmount()); userRedPacket.setNote(&quot;抢红包 &quot; + redPacketId); // 插入抢红包信息 int result = userRedPacketDao.grapRedPacket(userRedPacket); return result; &#125; // 失败返回 return FAILED; &#125; // 乐观锁，无重入 @Override @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED) public int grapRedPacketForVersion(Long redPacketId, Long userId) &#123; // 获取红包信息,注意version值 RedPacket redPacket = redPacketDao.getRedPacket(redPacketId); // 当前小红包库存大于0 if (redPacket.getStock() &gt; 0) &#123; // 再次传入线程保存的version旧值给SQL判断，是否有其他线程修改过数据 int update = redPacketDao.decreaseRedPacketForVersion(redPacketId, redPacket.getVersion()); // 如果没有数据更新，则说明其他线程已经修改过数据，本次抢红包失败 if (update == 0) &#123; return FAILED; &#125; // 生成抢红包信息 UserRedPacket userRedPacket = new UserRedPacket(); userRedPacket.setRedPacketId(redPacketId); userRedPacket.setUserId(userId); userRedPacket.setAmount(redPacket.getUnitAmount()); userRedPacket.setNote(&quot;抢红包 &quot; + redPacketId); // 插入抢红包信息 int result = userRedPacketDao.grapRedPacket(userRedPacket); return result; &#125; // 失败返回 return FAILED; &#125; // 乐观锁，按时间戳重入 // @Override // @Transactional(isolation = Isolation.READ_COMMITTED, propagation = // Propagation.REQUIRED) // public int grapRedPacketForVersion(Long redPacketId, Long userId) &#123; // // 记录开始时间 // long start = System.currentTimeMillis(); // // 无限循环，等待成功或者时间满100毫秒退出 // while (true) &#123; // // 获取循环当前时间 // long end = System.currentTimeMillis(); // // 当前时间已经超过100毫秒，返回失败 // if (end - start &gt; 100) &#123; // return FAILED; // &#125; // // 获取红包信息,注意version值 // RedPacket redPacket = redPacketDao.getRedPacket(redPacketId); // // 当前小红包库存大于0 // if (redPacket.getStock() &gt; 0) &#123; // // 再次传入线程保存的version旧值给SQL判断，是否有其他线程修改过数据 // int update = redPacketDao.decreaseRedPacketForVersion(redPacketId, // redPacket.getVersion()); // // 如果没有数据更新，则说明其他线程已经修改过数据，则重新抢夺 // if (update == 0) &#123; // continue; // &#125; // // 生成抢红包信息 // UserRedPacket userRedPacket = new UserRedPacket(); // userRedPacket.setRedPacketId(redPacketId); // userRedPacket.setUserId(userId); // userRedPacket.setAmount(redPacket.getUnitAmount()); // userRedPacket.setNote(&quot;抢红包 &quot; + redPacketId); // // 插入抢红包信息 // int result = userRedPacketDao.grapRedPacket(userRedPacket); // return result; // &#125; else &#123; // // 一旦没有库存，则马上返回 // return FAILED; // &#125; // &#125; // &#125; // 乐观锁，按次数重入 // @Override // @Transactional(isolation = Isolation.READ_COMMITTED, propagation = // Propagation.REQUIRED) // public int grapRedPacketForVersion(Long redPacketId, Long userId) &#123; // for (int i = 0; i &lt; 3; i++) &#123; // // 获取红包信息，注意version值 // RedPacket redPacket = redPacketDao.getRedPacket(redPacketId); // // 当前小红包库存大于0 // if (redPacket.getStock() &gt; 0) &#123; // // 再次传入线程保存的version旧值给SQL判断，是否有其他线程修改过数据 // int update = redPacketDao.decreaseRedPacketForVersion(redPacketId, // redPacket.getVersion()); // // 如果没有数据更新，则说明其他线程已经修改过数据，则重新抢夺 // if (update == 0) &#123; // continue; // &#125; // // 生成抢红包信息 // UserRedPacket userRedPacket = new UserRedPacket(); // userRedPacket.setRedPacketId(redPacketId); // userRedPacket.setUserId(userId); // userRedPacket.setAmount(redPacket.getUnitAmount()); // userRedPacket.setNote(&quot;抢红包 &quot; + redPacketId); // // 插入抢红包信息 // int result = userRedPacketDao.grapRedPacket(userRedPacket); // return result; // &#125; else &#123; // // 一旦没有库存，则马上返回 // return FAILED; // &#125; // &#125; // return FAILED; // &#125; @Autowired private RedisTemplate redisTemplate = null; @Autowired private RedisRedPacketService redisRedPacketService = null; // Lua脚本 String script = &quot;local listKey = &apos;red_packet_list_&apos;..KEYS[1] \n&quot; + &quot;local redPacket = &apos;red_packet_&apos;..KEYS[1] \n&quot; + &quot;local stock = tonumber(redis.call(&apos;hget&apos;, redPacket, &apos;stock&apos;)) \n&quot; + &quot;if stock &lt;= 0 then return 0 end \n&quot; + &quot;stock = stock -1 \n&quot; + &quot;redis.call(&apos;hset&apos;, redPacket, &apos;stock&apos;, tostring(stock)) \n&quot; + &quot;redis.call(&apos;rpush&apos;, listKey, ARGV[1]) \n&quot; + &quot;if stock == 0 then return 2 end \n&quot; + &quot;return 1 \n&quot;; // 在缓存LUA脚本后，使用该变量保存Redis返回的32位的SHA1编码，使用它去执行缓存的LUA脚本[加入这句话] String sha1 = null; @Override public Long grapRedPacketByRedis(Long redPacketId, Long userId) &#123; // 当前抢红包用户和日期信息 String args = userId + &quot;-&quot; + System.currentTimeMillis(); Long result = null; // 获取底层Redis操作对象 Jedis jedis = (Jedis) redisTemplate.getConnectionFactory().getConnection().getNativeConnection(); try &#123; // 如果脚本没有加载过，那么进行加载，这样就会返回一个sha1编码 if (sha1 == null) &#123; sha1 = jedis.scriptLoad(script); &#125; // 执行脚本，返回结果 Object res = jedis.evalsha(sha1, 1, redPacketId + &quot;&quot;, args); result = (Long) res; // 返回2时为最后一个红包，此时将抢红包信息通过异步保存到数据库中 if (result == 2) &#123; // 获取单个小红包金额 String unitAmountStr = jedis.hget(&quot;red_packet_&quot; + redPacketId, &quot;unit_amount&quot;); // 触发保存数据库操作 Double unitAmount = Double.parseDouble(unitAmountStr); System.err.println(&quot;thread_name = &quot; + Thread.currentThread().getName()); redisRedPacketService.saveUserRedPacketByRedis(redPacketId, unitAmount); &#125; &#125; finally &#123; // 确保jedis顺利关闭 if (jedis != null &amp;&amp; jedis.isConnected()) &#123; jedis.close(); &#125; &#125; return result; &#125;&#125; 三、搭建全注解SSM开发环境1、配置tomcat服务器2、配置类 WebAppInitializer.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.ssm.config;import javax.servlet.MultipartConfigElement;import javax.servlet.ServletRegistration.Dynamic;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; // Spring IoC环境配置 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; // 配置Spring IoC资源 return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;; &#125; // DispatcherServlet环境配置 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; // 加载Java配置类 return new Class&lt;?&gt;[] &#123; WebConfig.class &#125;; &#125; // DispatchServlet拦截请求配置 @Override protected String[] getServletMappings() &#123; return new String[] &#123; &quot;*.do&quot; &#125;; &#125; /** * @param dynamic * Servlet上传文件配置. */ @Override protected void customizeRegistration(Dynamic dynamic) &#123; // 配置上传文件路径 String filepath = &quot;e:/mvc/uploads&quot;; // 5MB Long singleMax = (long) (5 * Math.pow(2, 20)); // 10MB Long totalMax = (long) (10 * Math.pow(2, 20)); // 设置上传文件配置 dynamic.setMultipartConfig(new MultipartConfigElement(filepath, singleMax, totalMax, 0)); &#125;&#125; RootConfig.java—-Spring IoC上下文配置 注解@EnableTransactionManagement，实现注解式事务，可以通过注解@Transactional配置数据库事务 修改本地数据库用户密码，连接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package com.ssm.config;import java.util.Properties;import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSourceFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.mapper.MapperScannerConfigurer;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.ComponentScan.Filter;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.Resource;import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.stereotype.Repository;import org.springframework.stereotype.Service;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.annotation.TransactionManagementConfigurer;import redis.clients.jedis.JedisPoolConfig;@Configuration//定义Spring 扫描的包@ComponentScan(value= &quot;com.*&quot;, includeFilters= &#123;@Filter(type = FilterType.ANNOTATION, value =&#123;Service.class&#125;)&#125;)//使用事务驱动管理器@EnableTransactionManagement//实现接口TransactionManagementConfigurer，这样可以配置注解驱动事务public class RootConfig implements TransactionManagementConfigurer &#123; private DataSource dataSource = null; /** * 配置数据库. * @return 数据连接池 */ @Bean(name = &quot;dataSource&quot;) public DataSource initDataSource() &#123; if (dataSource != null) &#123; return dataSource; &#125; Properties props = new Properties(); props.setProperty(&quot;driverClassName&quot;, &quot;com.mysql.jdbc.Driver&quot;); props.setProperty(&quot;url&quot;, &quot;jdbc:mysql://localhost:3306/redPacket&quot;); props.setProperty(&quot;username&quot;, &quot;root&quot;); props.setProperty(&quot;password&quot;, &quot;admin&quot;); props.setProperty(&quot;maxActive&quot;, &quot;200&quot;); props.setProperty(&quot;maxIdle&quot;, &quot;20&quot;); props.setProperty(&quot;maxWait&quot;, &quot;30000&quot;); try &#123; dataSource = BasicDataSourceFactory.createDataSource(props); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return dataSource; &#125; /*** * 配置SqlSessionFactoryBean * @return SqlSessionFactoryBean */ @Bean(name=&quot;sqlSessionFactory&quot;) public SqlSessionFactoryBean initSqlSessionFactory() &#123; SqlSessionFactoryBean sqlSessionFactory = new SqlSessionFactoryBean(); sqlSessionFactory.setDataSource(initDataSource()); //配置MyBatis配置文件 Resource resource = new ClassPathResource(&quot;mybatis/mybatis-config.xml&quot;); sqlSessionFactory.setConfigLocation(resource); return sqlSessionFactory; &#125; /*** * 通过自动扫描，发现MyBatis Mapper接口 * @return Mapper扫描器 */ @Bean public MapperScannerConfigurer initMapperScannerConfigurer() &#123; MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(&quot;com.*&quot;); msc.setSqlSessionFactoryBeanName(&quot;sqlSessionFactory&quot;); msc.setAnnotationClass(Repository.class); return msc; &#125; /** * 实现接口方法，注册注解事务，当@Transactional 使用的时候产生数据库事务 */ @Override @Bean(name=&quot;annotationDrivenTransactionManager&quot;) public PlatformTransactionManager annotationDrivenTransactionManager() &#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(initDataSource()); return transactionManager; &#125; @Bean(name = &quot;redisTemplate&quot;) public RedisTemplate initRedisTemplate() &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); //最大空闲数 poolConfig.setMaxIdle(50); //最大连接数 poolConfig.setMaxTotal(100); //最大等待毫秒数 poolConfig.setMaxWaitMillis(20000); //创建Jedis链接工厂 JedisConnectionFactory connectionFactory = new JedisConnectionFactory(poolConfig); connectionFactory.setHostName(&quot;localhost&quot;); connectionFactory.setPort(6379); //调用后初始化方法，没有它将抛出异常 connectionFactory.afterPropertiesSet(); //自定Redis序列化器 RedisSerializer jdkSerializationRedisSerializer = new JdkSerializationRedisSerializer(); RedisSerializer stringRedisSerializer = new StringRedisSerializer(); //定义RedisTemplate，并设置连接工程[修改为：工厂] RedisTemplate redisTemplate = new RedisTemplate(); redisTemplate.setConnectionFactory(connectionFactory); //设置序列化器 redisTemplate.setDefaultSerializer(stringRedisSerializer); redisTemplate.setKeySerializer(stringRedisSerializer); redisTemplate.setValueSerializer(stringRedisSerializer); redisTemplate.setHashKeySerializer(stringRedisSerializer); redisTemplate.setHashValueSerializer(stringRedisSerializer); return redisTemplate; &#125; &#125; WebConfig—配置DispatcherServlet上下文 对象和JSON的转换消息类MappingJackson2HttpMessageConverter 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.ssm.config;import java.util.ArrayList;import java.util.List;import java.util.concurrent.Executor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.ComponentScan.Filter;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.http.MediaType;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import org.springframework.scheduling.annotation.AsyncConfigurerSupport;import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;import org.springframework.stereotype.Controller;import org.springframework.web.servlet.HandlerAdapter;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;import org.springframework.web.servlet.view.InternalResourceViewResolver;@Configuration//定义Spring MVC扫描的包@ComponentScan(value=&quot;com.*&quot;, includeFilters= &#123;@Filter(type = FilterType.ANNOTATION, value = Controller.class)&#125;)//启动Spring MVC配置@EnableWebMvcpublic class WebConfig extends AsyncConfigurerSupport &#123; /*** * 通过注解 @Bean 初始化视图解析器 * @return ViewResolver 视图解析器 */ @Bean(name=&quot;internalResourceViewResolver&quot;) public ViewResolver initViewResolver() &#123; InternalResourceViewResolver viewResolver =new InternalResourceViewResolver(); viewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;); viewResolver.setSuffix(&quot;.jsp&quot;); return viewResolver; &#125; /** * 初始化RequestMappingHandlerAdapter，并加载Http的Json转换器 * @return RequestMappingHandlerAdapter 对象 */ @Bean(name=&quot;requestMappingHandlerAdapter&quot;) public HandlerAdapter initRequestMappingHandlerAdapter() &#123; //创建RequestMappingHandlerAdapter适配器 RequestMappingHandlerAdapter rmhd = new RequestMappingHandlerAdapter(); //HTTP JSON转换器 MappingJackson2HttpMessageConverter jsonConverter = new MappingJackson2HttpMessageConverter(); //MappingJackson2HttpMessageConverter接收JSON类型消息的转换 MediaType mediaType = MediaType.APPLICATION_JSON_UTF8; List&lt;MediaType&gt; mediaTypes = new ArrayList&lt;MediaType&gt;(); mediaTypes.add(mediaType); //加入转换器的支持类型 jsonConverter.setSupportedMediaTypes(mediaTypes); //往适配器加入json转换器 rmhd.getMessageConverters().add(jsonConverter); return rmhd; &#125; @Override public Executor getAsyncExecutor() &#123; ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); taskExecutor.setCorePoolSize(5); taskExecutor.setMaxPoolSize(10); taskExecutor.setQueueCapacity(200); taskExecutor.initialize(); return taskExecutor; &#125;&#125; 3、mybatis配置 mybatis-config.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/ssm/mapper/UserRedPacket.xml&quot;/&gt; &lt;mapper resource=&quot;com/ssm/mapper/RedPacket.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; log4j.properties 12345log4j.rootLogger=INFO , stdoutlog4j.logger.org.mybatis=INFOlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p %d %C: %m%n 4、开发控制器UserRedPacketController.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.ssm.controller;import java.util.HashMap;import java.util.Map;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.ssm.service.UserRedPacketService;@Controller@RequestMapping(&quot;/userRedPacket&quot;)public class UserRedPacketController &#123; @Autowired private UserRedPacketService userRedPacketService = null; @RequestMapping(value = &quot;/grapRedPacket&quot;) @ResponseBody public Map&lt;String, Object&gt; grapRedPacket(Long redPacketId, Long userId) &#123; // 抢红包 int result = userRedPacketService.grapRedPacket(redPacketId, userId); Map&lt;String, Object&gt; retMap = new HashMap&lt;String, Object&gt;(); boolean flag = result &gt; 0; retMap.put(&quot;success&quot;, flag); retMap.put(&quot;message&quot;, flag ? &quot;抢红包成功&quot; : &quot;抢红包失败&quot;); return retMap; &#125; //乐观锁请求，使用时修改javascript的请求路径 @RequestMapping(value = &quot;/grapRedPacketForVersion&quot;) @ResponseBody public Map&lt;String, Object&gt; grapRedPacketForVersion(Long redPacketId, Long userId) &#123; // 抢红包 int result = userRedPacketService.grapRedPacketForVersion(redPacketId, userId); Map&lt;String, Object&gt; retMap = new HashMap&lt;String, Object&gt;(); boolean flag = result &gt; 0; retMap.put(&quot;success&quot;, flag); retMap.put(&quot;message&quot;, flag ? &quot;抢红包成功&quot; : &quot;抢红包失败&quot;); return retMap; &#125; @RequestMapping(value = &quot;/grapRedPacketByRedis&quot;) @ResponseBody public Map&lt;String, Object&gt; grapRedPacketByRedis(Long redPacketId, Long userId) &#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); Long result = userRedPacketService.grapRedPacketByRedis(redPacketId, userId); boolean flag = result &gt; 0; resultMap.put(&quot;result&quot;, flag); resultMap.put(&quot;message&quot;, flag ? &quot;抢红包成功&quot;: &quot;抢红包失败&quot;); return resultMap; &#125;&#125; 5、Redis接口和实现类1.RedisRedPacketService.java 1234567891011package com.ssm.service;public interface RedisRedPacketService &#123; /** * 保存redis抢红包列表 * @param redPacketId --抢红包编号 * @param unitAmount -- 红包金额 */ public void saveUserRedPacketByRedis(Long redPacketId, Double unitAmount);&#125; 2.RedisRedPacketServiceImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.ssm.service;import java.sql.Connection;import java.sql.SQLException;import java.sql.Statement;import java.sql.Timestamp;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.List;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.BoundListOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;import com.ssm.pojo.UserRedPacket;import com.ssm.service.RedisRedPacketService;@Servicepublic class RedisRedPacketServiceImpl implements RedisRedPacketService &#123; private static final String PREFIX = &quot;red_packet_list_&quot;; // 每次取出1000条，避免一次取出消耗太多内存 private static final int TIME_SIZE = 1000; @Autowired private RedisTemplate redisTemplate = null; // RedisTemplate @Autowired private DataSource dataSource = null; // 数据源 @Override // 开启新线程运行 @Async public void saveUserRedPacketByRedis(Long redPacketId, Double unitAmount) &#123; System.err.println(&quot;开始保存数据&quot;); Long start = System.currentTimeMillis(); // 获取列表操作对象 BoundListOperations ops = redisTemplate.boundListOps(PREFIX + redPacketId); Long size = ops.size(); Long times = size % TIME_SIZE == 0 ? size / TIME_SIZE : size / TIME_SIZE + 1; int count = 0; List&lt;UserRedPacket&gt; userRedPacketList = new ArrayList&lt;UserRedPacket&gt;(TIME_SIZE); for (int i = 0; i &lt; times; i++) &#123; // 获取至多TIME_SIZE个抢红包信息 List userIdList = null; if (i == 0) &#123; userIdList = ops.range(i * TIME_SIZE, (i + 1) * TIME_SIZE); &#125; else &#123; userIdList = ops.range(i * TIME_SIZE + 1, (i + 1) * TIME_SIZE); &#125; userRedPacketList.clear(); // 保存红包信息 for (int j = 0; j &lt; userIdList.size(); j++) &#123; String args = userIdList.get(j).toString(); String[] arr = args.split(&quot;-&quot;); String userIdStr = arr[0]; String timeStr = arr[1]; Long userId = Long.parseLong(userIdStr); Long time = Long.parseLong(timeStr); // 生成抢红包信息 UserRedPacket userRedPacket = new UserRedPacket(); userRedPacket.setRedPacketId(redPacketId); userRedPacket.setUserId(userId); userRedPacket.setAmount(unitAmount); userRedPacket.setGrabTime(new Timestamp(time)); userRedPacket.setNote(&quot;抢红包 &quot; + redPacketId); userRedPacketList.add(userRedPacket); &#125; // 插入抢红包信息 count += executeBatch(userRedPacketList); &#125; // 删除Redis列表 redisTemplate.delete(PREFIX + redPacketId); Long end = System.currentTimeMillis(); System.err.println(&quot;保存数据结束，耗时&quot; + (end - start) + &quot;毫秒，共&quot; + count + &quot;条记录被保存。&quot;); &#125; /** * 使用JDBC批量处理Redis缓存数据. * * @param userRedPacketList * -- 抢红包列表 * @return 抢红包插入数量. */ private int executeBatch(List&lt;UserRedPacket&gt; userRedPacketList) &#123; Connection conn = null; Statement stmt = null; int[] count = null; try &#123; conn = dataSource.getConnection(); conn.setAutoCommit(false); stmt = conn.createStatement(); for (UserRedPacket userRedPacket : userRedPacketList) &#123; String sql1 = &quot;update T_RED_PACKET set stock = stock-1 where id=&quot; + userRedPacket.getRedPacketId(); DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String sql2 = &quot;insert into T_USER_RED_PACKET(red_packet_id, user_id, &quot; + &quot;amount, grab_time, note)&quot; + &quot; values (&quot; + userRedPacket.getRedPacketId() + &quot;, &quot; + userRedPacket.getUserId() + &quot;, &quot; + userRedPacket.getAmount() + &quot;,&quot; + &quot;&apos;&quot; + df.format(userRedPacket.getGrabTime()) + &quot;&apos;,&quot; + &quot;&apos;&quot; + userRedPacket.getNote() + &quot;&apos;)&quot;; stmt.addBatch(sql1); stmt.addBatch(sql2); &#125; // 执行批量 count = stmt.executeBatch(); // 提交事务 conn.commit(); &#125; catch (SQLException e) &#123; /********* 错误处理逻辑 ********/ throw new RuntimeException(&quot;抢红包批量执行程序错误&quot;); &#125; finally &#123; try &#123; if (conn != null &amp;&amp; !conn.isClosed()) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 返回插入抢红包数据记录 return count.length / 2; &#125;&#125; 三、调试输入以下url：http://localhost:8080/redPacket/userRedPacket/grapRedPacketForVersion.do?redPacketId=1&amp;userId=1 注：userId可随意，发现后台数据变动]]></content>
      <categories>
        <category>实践操作</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试汇总帖-3]]></title>
    <url>%2F2018%2F10%2F03%2F%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93%E5%B8%96-3%2F</url>
    <content type="text"><![CDATA[CVTE笔试1、IPV4定义IPv4（Internet Protocol Version 4）协议族是TCP/IP协议族中最为核心的协议族。它工作在TCP/IP协议栈的网络层，该层与OSI参考模型的网络层相对应。网络层提供了无连接数据传输服务，即网络在发送分组时不需要先建立连接，每一个分组（也就是IP数据报文）独立发送，与前后的分组无关。 目的网络层的IPv4协议族为数据链路层和传输层实现互通提供了保障。IPv4协议族可以屏蔽各链路层的差异，为传输层提供统一的网络层传输标准。 IPv4协议族 地址解析协议ARP（Address Resolution Protocol） 逆地址解析协议RARP（Reverse Address Resolution Protocol） 互联网控制消息协议ICMP（Internet Control Message Protocol） 传输控制协议TCP（Transmission Contronl Protocol） 用户数据报协议UDP（User Datagram Protocol）等 IPv4地址组成 网络号码字段（Net-id）。IP地址的网络号码字段用来标识一个网络，网络号码字段的前几位用来区分IP地址的类型。 主机号码字段（Host-id）。主机号码字段用来区分一个网络内的不同主机。对于网络号相同的设备，无论实际所处的物理位置如何，它们都是处在同一个网络中。 2、JVM垃圾回收，年老代堆空间、年轻代堆空间 在基于分代的内存回收策略中，堆空间通常都被划分为3个代，年轻代，年老代（或者tenured代），永久代。在年轻代中又被划分了三个小的区域，分别为：Eden（伊甸）区，S0区(survivor 0)，S1区(survivor 1) 新的对象总被分配到年经代中，当年轻代空间被填满时，这时需要执行一次垃圾回收，即执行 minor GC，回收不再被引用的对象，并同时提升幸存的对象其年龄，年经代中的幸存对象都有年龄标识字段，一旦其达到一定的阈值，则仍然幸存的对象将被提升到老年代空间中。 老年代的空间用于存放长时间幸存的对象，即生命周期较长的对象，一旦年轻代空间的幸存对象达到一定的年龄阈值后，将被自动提升到年老代，当年老代空间被对象填满时，这时执行一次Major GC。相较于minor GC, Major GC的执行次数要比minor GC要少很多，同时，Major Gc 执行的时间较Minor Gc要长。因为其涉及到更多的对象扫描。这种分代的思想，也是基于在实践中，对于新分配的对象具有更短的生命周期，年老的对象具有更长的生命周期所作出的较佳的选择。 与此同时，Minor Gc 和 Major Gc 在执行垃圾收集时，采取的是stop the world event ，即终止正在运行的线程，等GC执行完毕在恢复所有的线程。 对于永久代的内存，主要是用来存放元数据的相关信息，类及其方法的信息。当一个类不再使用时将会被回收，当执行Full GC时，将会扫描永久代内存，对其进行垃圾回收。 3、网卡是完成（数据链路层和物理层）功能网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。 主要功能 数据的封装与解封，发送时将上一层交下来的数据加上首部和尾部，成为以太网的帧。接收时将以太网的帧剥去首部和尾部，然后送交上一层。 链路管理，主要是CSMA/CD（Carrier Sense Multiple Access with Collision Detection ，带冲突检测的载波监听多路访问）协议的实现。 编码与译码，即曼彻斯特编码与译码。 4、多列索引/聚簇索引/索引选择性多列索引 一个多列索引可以认为是包含通过合并(concatenate)索引列值创建的值的一个排序数组 多列建索引比对每个列分别建索引更有优势，因为索引建立得越多就越占磁盘空间，在更新数据的时候速度会更慢。 建立多列索引时，需要注意顺序，应该将严格的索引放在前面，这样筛选的力度会更大，效率更高。 聚簇索引聚集索引是根据数据行的键值在表中排序存储数据行。索引定义中包含聚集索引列。每个表只能有一个聚集索引。只有当表包含聚集索引时，表中的数据行才按排序顺序存储。如果表具有聚集索引，则该表称为聚集表。集索引决定了表数据的存储顺序,如果表没有聚集索引，则其数据行存储在一个称为堆的无序结构中。 索引的选择性 索引的选择性是指索引列中不同值的数目与表中记录数的比。 确定索引的选择性的方法 手工测量索引的选择性 自动测量索引的选择性 5、Java泛型 List list=new ArrayList()不合法 List list=new ArrayList()合法 非泛型允许有泛型方法 泛型，即“参数化类型”，将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 通过List，直接限定了list集合中只能含有String类型的元素，无须再进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。 在List中，String是类型实参，相应的List接口中肯定含有类型形参。且get()方法的返回结果也直接是此形参类型（也就是对应的传入的类型实参）。 在List接口中采用泛型化定义之后，中的E表示类型形参，可以接收具体的类型实参，并且此接口定义中，凡是出现E的地方均表示相同的接受自外部的类型实参。 6、Java集合类 集合类存放于 java.util 包中，是一个用来存放对象的容器。 集合只能存放对象。 集合存放的是多个对象的引用，对象本身还是放在堆内存中。 集合可以存放不同类型，不限数量的数据类型。 集合详解 Iterator:迭代器，它是Java集合的顶层接口（不包括 map 系列的集合，Map接口 是 map 系列集合的顶层接口） Collection:List 接口和 Set 接口的父接口 List :有序，可以重复的集合。 Set：典型实现 HashSet()是一个无序，不可重复的集合 Map：key-value 的键值对，key 不允许重复，value 可以 Map 和 Set 集合的关系 有几个类型的集合 HashMap 和 HashSet ，都采用哈希表算法； TreeMap 和 TreeSet 都采用 红-黑树算法； LinkedHashMap 和 LinkedHashSet 都采用哈希表算法和红-黑树算法。 分析 Set 的底层源码，我们可以看到，Set 集合 就是 由 Map 集合的 Key 组成。 7、排序 当输入序列有序或元素个数较小时，最佳的排序方法（冒泡排序） 当用于排序的辅助空间较小（堆排序&lt;快速排序&lt;归并排序） 从平均时间性能而言，快速排序最佳，其所需时间最少，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。当序列中的记录基本有序或元素个数较少时，冒泡排序和简单选择排序为最佳排序方法。由于堆排序空间复杂度为O(1)，快速排序空间复杂度在最坏情况下为O(n)，平均为O(log2n、)，归并排序空间复杂度为O(n) 8、GC与强引用、软引用、弱引用、虚引用之间的关系Java 引用的类别 强引用：只要程序通过 new 关键字创建了对象，那么垃圾回收期永远不会进行对对象的回收，除非是系统内存不够，即便如此，JVM也就只是抛出OutOfMemory（）异常，当然如果对象的引用被释放后。这个对象将会被释放掉。 软引用：非必须引用，当内存资源不够即将溢出时，这个时候GC将会对对象的内存空间进行回收，从而避免内存溢出错误的发生。 12345678910111213//实现软引用Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null ;sf.get(); /* 这个时候sf是obj对象的一个软引用， * 通过get（）方法可以获取到这个对象 * 当内存不足的时候可能返回 null ；*/ /* 使用场景：当用户需要实现类似缓存的功能， * 在内存足够的情况下直接通过软引用取值， * 无需从繁忙的真实来源查询数据，提升速度； * 当内存不足时，自动删除部分缓存数据， * 从真正的来源查询相关数据。*/ 3 、弱引用：第二次垃圾回收时回收，不管当前内存资源是否充足 123456789//如何实现弱引用：Object obj = new Object （）；WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;（）；// 创建弱引用对象obj = null ;wf.get（）; // 有的时候回返回nullwf.isEnQueued（）; // 返回是否被垃圾回收器标记为即将回收的装状态/* 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾， * 可以通过弱引用的isEnqueued方法返回对象是否被垃圾回收器标记。*/ 4、虚引用（幽灵引用）：虚引用主要用于检测对象是否已经从内存删除。虚引用是话语权级别最低的引用，只要垃圾回收开始工作，那么虚引用就会被回收。 1234//实现方式Object obj = new Object （）；PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj)；pf.get();//永远返回null 9、一个SQL查询中group by的字段必须包含在select字段中 分组查询中，select后的字段必须是group by中包含的字段 10、反射 getMethod(String)方法的作用是根据方法名获取方法public Method[] getMethods()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。 利用反射不但可以访问类的私有属性、方法，还可以重新设置私有属性的值，调用私有方法。 反射可以获取类中私有的属性和方法 反射…….class文件 反射可以直接设置私有属性的值 11、二叉树计算 在一棵二叉树中，双分支结点数为15，单分支结点数为30，则叶子结点为（16） 假设ni表示二叉树中度为i的结点数，已有n2 = 15，n1 = 30。根据二叉树的性质，有n0 = n2 + 1，故n0 = 16，即该二叉树中叶子结点数为16个。 12、HTTP协议（基于TCP、属于应用层协议） HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）的请求应答协议。 HTTP协议被封装在TCP包中，使用端口号80，因此HTTP协议属于传输层之上，即应用层。 13、StringBuilder线程安全、StringBuffer非线程安全 StringBuffer 字符串变量（线程安全） StringBuilder 字符串变量（非线程安全） 14、JDK1.8用const修饰常量const和goto是Java的保留字，没有被使用实现。 15、StringBuffer StringBuffer不可变对象，可存储操作字符串StringBuffer类的对象能被多次修改，并不产生新的未使用对象 StringBuffer 对一串字符进行操作，可变类/对象，进行修改的时候不会重新建立对象。 Java提供的有特殊的语法，而通常情况下一般使用构造方法进行初始化。 1234//初始化出的StringBuffer对象是一个空的对象StringBuffer s = new StringBuffer();//创建带有内容的StringBuffer对象StringBuffer s = new StringBuffer(“abc”); StringBuffer类中的方法主要偏重于对于字符串的变化，例如追加、插入和删除等 16、分数运算 输入：”1/3+1/4”， 输出：“7/12” 17、数组arr，随机抽走一张 输入：{0,1,2,4,5}，输出：3 同程艺龙笔试1、创建对象时，jvm会找到对应的.java文件，通过.java文件创建对象？（false）对象的创建过程： 所有的类都是在第一次被使用时，动态加载到JVM中。当首次创建类型为Dog的对象时，或者Dog类的静态方法首次被调用时，或者静态属性域首次被访问时，java解释器查找classPath，定位到Dog.class文件。 载入Dog.class文件，生成一个Class类型对象，所有有关的静态初始化动作都会执行：如静态代码块，静态成员属性。 并且这种初始化动作只在Class对象首次加载时候进行一次。 当用new Dog()创建对象时，首先JVM在堆heap上为Dog对象分配足够的存储空间。 存储空间清空，自动将Dog对象中的所有基本类型数据都设置成了默认值，对象引用被设置为null。 执行所有在字段定义处的一些初始化操作。 调用构造器方法。（没有继承） 2、重写的方法不能比被重写的方法抛出（throws声明的）更多种类的异常？（false） 在java 中，当我们子类要重写父类中的方法，如果父类的方法有异常声明，那么子类重写这个方法时候，所要声明的异常不应该比父类的大。只能是小等，或者可以没有。 子类重写父类的方法时候不能声明抛出比父类大的异常 3、byte类型所占存储空间为1个字节，取值范围0~255？（false）byte的取值范围为-128~127，占用1个字节（-2的7次方到2的7次方-1） 4、java中可以通过this关键字解决成员变量与局部变量名称冲突问题？（true）this关键字常见用法 通过this关键字可以明确地去访问一个类的成员变量，解决与局部变量名称冲突的问题。 this关键字调用成员方法。 this关键字调用构造方法 this表示当前对象 5、集合中元素类型必须是相同的？（false） 不同类型的元素，根本上都继承于Object类，本质上还是同一类型的元素。 声明集合时，不声明它的泛型类型时，默认Object泛型，跟List效果一样。 12345List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();list.add(&quot;abc&quot;);list.add(123);list.add(new HashMap&lt;Integer,String&gt;());List list = new ArrayList(); 6、当类被加载时，静态代码块会执行，并且只会执行一次？（true）静态代码块和非静态代码块的区别 静态代码块,在虚拟机加载类的时候就会加载执行,而且只执行一次 非静态代码块,在创建对象的时候(即new一个对象的时候)执行,每次创建对象都会执行一次 7、在不同的操作系统中可以使用同一个JDK？（false）8、两个对象的内容和类型是否相同，通过“==”操作符进行判定？（false） 值类型是存储在内存中的堆栈（以后简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。 ==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。 equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。 ==比较的是2个对象的地址，而equals比较的是2个对象的内容。 1、OSI：物、数、网、传、会、表、应2、ServerSocketChannel可能发生哪个事件？ selection.OP_ACCEPT：接收连接就绪事件selection.OP_CONNECT：连接就绪事件selection.OP_WRITE：写就绪事件selection.OP_READ：读就绪事件 ServerSocketChannel类(用于阻塞或非阻塞式侦听连接)，主要是绑定socket地址，监听Socket连接。 ServerSocketChannel open()：创建未绑定的ServerSocketChannel. ServerSocket socket()：返回此ServerSocketChannel的serversocket. SocketChannel accept()：侦听连接请求，阻塞模式下会一直等待直到出现请求，非阻塞模式下如果没有请求就直接返回null. int validOps()：返回ServerSocketChannel可能产生的事件，即SelectionKey.OP_ACCEPT(有连接请求)。 3、构造函数的返回类型只能是void型（false）构造函数的名字与类的名字相同，并且不能指定返回类型。 4、object object o=new String(“a”);Strings=o;//编译错误 Object 是所有类的超类，Object类型的变量可以引用任何类型的对象 5、list list是一个ArrayList对象，哪个方法可以在iterator遍历过程中正确并安全的删除一个list中保存的对象？//Iterator it=list.iterator()（it.remove(),list.remove(obj),list.remove(index),list.remove(it.next())） 123456789101112131415161718public class Main &#123;public static void main(String[] args) throws Exception &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) list.add(i); // list &#123;0, 1, 2, 3, 4&#125; Iterator&lt;Integer&gt; it = list.iterator(); while (it.hasNext()) &#123; // index and number int num = it.next(); System.out.print(num); if (num % 2 == 0) &#123; it.remove(); System.out.print(&quot; delete&quot;); &#125; System.out.println(); &#125;&#125; 6、线程 当线程在IO出堵塞时，线程（转换成等待状态/没有线程可完成IO操作） 阻塞情况 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 7、哪一个关键字表示线程放弃对象锁（wait）wait 是 Object 类的方法,对此对象调用 wait 方法导致本线程放弃对象锁 8、哪些会导致String字符串被改变（toUpperCase、replace、concat）没有改变字符串的方法可以调用 9、int型数据的正确取值范围 在C语言中，int型数据所占的字节和具体的编译器有关，32位编译器int占4个字节，16位编译器int占2个字节 当int型数据占两个字节时，int型数据取值范围为-32768 ~ 32767 10、线程 当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面（false/后面） 使用start方法可以使一个线程立即开始运行（false） 11、char a=’a’，int/String ‘a’重载char型不能为字符串，只能为字符，int重载 12、DatagramPacketDatagramPacket表示存放数据的数据报 13、post用户提交的表单数据位于http请求的（请求体）HTTP POST格式: 1234&lt;request line&gt;&lt;request header&gt;&lt;blank line&gt;&lt;request body&gt; 14、Error/Exception类区别 Error（错误）是系统中的错误，程序员是不能改变的和处理的，是在程序编译时出现的错误，只能通过修改程序才能修正。一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。 Exception（异常）表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。 Exception类型 CheckedException：（编译时异常） 需要用try——catch显示的捕获，对于可恢复的异常使用CheckedException。 UnCheckedException（RuntimeException）：（运行时异常）不需要捕获，对于程序错误（不可恢复）的异常使用RuntimeException。 腾讯笔试1、修改/home下xx目录以及目录下所有文件，所有人可读可写 chmod 777/home/xx -R 2、最佳置换OPT 置换以后不再被访问，或者在将来最迟才会被访问的页面，缺页中断率最低。 3、字符“tencent”的二进制编码位数（未解）4、递归算法 递归名次解释：程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。递归定义：在运行的过程中调用自己。 构成递归需具备的条件： 子问题须与原始问题为同样的事，且更为简单； 不能无限制地调用本身，须有个出口，化简为非递归状况处理。 尾递归名次解释：如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。 尾递归原理：当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。 用栈实现递归与非递归的转换（略） 5、由数组变为链表，什么排序算法的时间复杂度会增加 （不利于随机存取） 6、B-树、B+树 B+树比B树更适合实际应用中操作系统的文件索引和数据库索引 B树只适合随机检索，B+树同时支持随机检索和顺序检索； B-树、B+树是平衡多路树 7、静态链接只是对相对地址修改 静态链接就是在装入内存之前把进程相关的所有目标程序都链接起来，产生装入模块。需要地址和数据两个问题，分别是对相对地址进行修改，变换外部调用符号。 动态链接可实现多个程序对同一模块共享（静态链接） 8、传输层提供建立、维护和拆端到端的连接 网络层将数据封装为数据报后发送到链路层 传输层提供了流量控制功能 数据链路层的服务访问点是MAC地址 9、MapReduce 面向大数据并行处理的计算模型、框架和平台 MapReduce是一个基于集群的高性能并行计算平台（Cluster Infrastructure）。它允许用市 场上普通的商用服务器构成一个包含数十、数百至数千个节点的分布和并行计算集群。 MapReduce是一个并行计算与运行软件框架（Software Framework）。它提供了一个庞大但设计精良的并行计算软件框架，能自动完成计算任务的并行化处理，自动划分计算数据和计算任务，在集群节点上自动分配和执行任务以及收集计算结果，将数据分布存储、数据通信、容错处理等并行计算涉及到的很多系统底层的复杂细节交由系统负责处理，大大减少了软件开发人员的负担。 MapReduce是一个并行程序设计模型与方法（Programming Model &amp; Methodology）。它借助于函数式程序设计语言Lisp的设计思想，提供了一种简便的并行程序设计方法，用Map和Reduce两个函数编程实现基本的并行计算任务，提供了抽象的操作和并行编程接口，以简单方便地完成大规模数据的编程和计算处理 10、快速排序快速排序基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序的算法： 设置两个变量i、j，排序开始的时候：i=0，j=N-1； 以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； 从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； 重复第3、4步，直到i=j； 3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束。 11、入栈队列5,4,6,7,10,9，出栈队列为a1,a2,a3,a4,a5,a6,若a2=6，则a3取值可能有多少个12、TCP通信时，拥塞窗口cwmd=1，慢开始门限ssthresh=24发送方每收到一个确认就把窗口cwmd加1，但确认多个数据报的时候就加相应的数值，即一次传输轮次之后拥塞窗口就加倍 当cwnd&lt;ssthresh时，使用慢开始算法。 当cwnd&gt;ssthresh时，改用拥塞避免算法。 当cwnd=ssthresh时，慢开始与拥塞避免算法任意。 13、JVM性能调优工具：jmap、jps、jstack、jstat jps主要用来输出JVM中运行的进程状态信息(jps [options] [hostid]) jstack主要用来查看某个Java进程内的线程堆栈信息( jstack [option] pid ) jmap用来查看堆内存使用状况，一般结合jhat使用。 jmap -heap pid查看进程堆内存使用情况，包括GC算法、堆配置参数和各代中堆内存使用情况。 jmap -histo[:live] pid查看堆内存中的对象数目、大小统计直方图 jstat利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对进程的classloader，compiler，gc情况 14、允许远程主机访问本机的8080端口的防火墙策略4399笔试1、进程主要组成部分 程序。作用：描述进程要完成的功能。 数据。作用：程序在执行时所需要的数据和工作区。 PCB。作用：包含进程的描述信息和控制信息。它是进程存在的唯一标志。 2、与初始排序无关的是 元素的移动次数与关键字的初始排列次序无关的是：基数排序 元素的比较次数与初始序列无关是：选择排序 算法的时间复杂度与初始序列无关的是：直接选择排序 3、在MySQL中，char和varchar的类型区别在于 用来存储字符串，只是保存方式不一样。 char有固定的长度，而varchar属于可变长的字符类型。 小米笔试1、图 假设一个无向图包含12个顶点，其中5个顶点有5个段，7个顶点有7个度，那么这个图有（12）条边 2、为避免运算过程中整型溢出可以考虑的方法一般在计算时，使用long来执行，在计算的因子中显式地标准数字类型。 3、队列，两端入队，一端出队4、TCP是面向数据报的传输，UDP是面向字节流的传输（false）TCP是面向字节流的传输，UDP是面向数据报的传输 5、线程的粒度小于进程（true）线程的划分尺度小于进程，使得多线程程序的并发性高。 6、(strcmp,sprintf,strcpy,strncat)那些函数容易造成缓冲区溢出警惕缓冲区溢出（不安全的库函数） 字符串处理函数 strcpy() strcat() sprintf()、vsprintf() 字符读取函数 gets() getchar()、fgetc()、getc()、read() scanf()系列 getenv() 百信银行笔试1、属于应用层的网络协议 域名系统（Domain Name System，DNS）：用于实现网络设备名字到IP地址映射的网络 服务。 文件传输协议（File Transfer Protocol，FTP）：用于实现交互式文件传输功能。 简单邮件传送协议（Simple Mail Transfer Protocol， SMTP）：用于实现电子邮箱传送功能 超文本传输协议（HyperText Transfer Protocol，HTTP）：用于实现WWW服务。 简单网络管理协议（simple Network Management Protocol，SNMP）用于管理与监视网络设备 远程登录协议（Telnet）：用于实现远程登录功能。 2、抽象abstract方法是否可同时是静态的static，是否可同时被synchronized修饰 抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。 synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 3、迭代查询 本地域名服务器在域名解析过程中，可能发出DNS查询的最多次数（3？） 最少情况下：当本机DNS高速缓存中存有该域名的DNS信息时，则不需要查询任何域名服务器，这样最少发出0次DNS查询。 最多情况下：因为均采用迭代查询的方式，在最坏的情况下，需要依次迭代地向本地域名服务器、根域名服务器（.com）、顶级域名服务器（xyz.com）、权限域名服务器（abc.xyz.com）发出DNS查询请求，因此最多发出4次DNS查询。 4、5条直线最多可将一个圆切成（13-16）份n条直线最多可以把一个圆分成s份,公式s=1+n(n+1)/2,把5带入就可得,s=16份,既最多可分16份 5、Hive中内部外部表的区别未被external修饰的是内部表，被external修饰的为外部表； 区别： 内部表数据由Hive自身管理，外部表数据由HDFS管理； 内部表数据存储的位置是hive.metastore.warehouse.dir（默认：/user/hive/warehouse），外部表数据的存储位置由自己制定； 删除内部表会直接删除元数据（metadata）及存储数据；删除外部表仅仅会删除元数据，HDFS上的文件并不会被删除； 对内部表的修改会将修改直接同步给元数据，而对外部表的表结构和分区进行修改，则需要修复（MSCK REPAIR TABLE table_name;） 6、Java数组复制效率最高的方法 clone、for循环逐一复制、Array.copyOf、System.arraycopy for循环最慢，约为clone方法的2倍，约为System.arraycopy的4~5倍；System.arraycopy最快。 System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环 7、基于TCP协议TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK ，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。 TCP三次握手的过程： 客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。 服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。 客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。 TCP/UDP协议族： HTTP(HyperText Transfer Protocol，超文本传输协议）运行于TCP协议上。 TELNET (Teletype over the Network, 网络电传) ，通过一个终端(terminal)登陆到网络(运行在TCP协议上)。 FTP (File Transfer Protocol, 文件传输协议) ，由名知义 SMTP (Simple Mail Transfer Protocol，简单邮件传输协议) ，用来发送电子邮件(运行在TCP协议上) 。 DNS (Domain Name Service，域名服务) ，用于完成地址查找，邮件转发等工作(运行在TCP和UDP协议上) 。 ECHO (Echo Protocol, 回绕协议) ，用于查错及测量应答时间(运行在TCP和UDP协议上) 。 NTP (Network Time Protocol，网络时间协议) ，用于网络同步(运行在UDP协议上) 。 SNMP (Simple Network Management Protocol, 简单网络管理协议) ，用于网络信息的收集和网络管理。(运行于UDP协议上） BOOTP (Boot Protocol，启动协议) ，应用于无盘设备(运行在UDP协议上)。 8、a=”#”,b=”##”,s=”########”，用a与b来表示，有21/36/28/34种表示方式9、若字符串s=“aibank”，则s中的互异的非平凡子串（非空且不同于s本身）的个数为（20） 算第一个字母开头的， 有n个 （其中包括s本身） 第二次字母开头的， n-1个 一直到1个，得n + (n-1) + …. + 1 = n(n+1) / 2 然后 减去一个 s本身，得(n²/2)+(n/2)-1=20 10、后退N帧 GSN协议讲到gbn，首先要讲到累积确认。累积确认：接收方不必对收到的分组逐个发送确认，而是可以在收到几个分组后，对按序到达的最后一个分组加以确认。 比如，发送方发送0~7个帧，接收方对第0,2,3,7个帧发送确认，就是分别对第0个帧的确认，对第1,2个帧的确认，对第3个帧的确认，对第4,5,6,7个帧的确认。 假如接收方只发送了第3个帧的确认，就说明前面0,1,2,3号帧都被接收方正常接收了，但是后面的四个帧虽然也已经发送了，但是却需要重传，这就称作Go-back-N，也就是gbn（后退N帧）协议。 在这里实际上是回退4帧。 11、用户代理只能发送不能接受电子邮件，则可能是（POP3）地址错误 用户代理使用POP3协议接收邮件。通常用户在配置电子邮件用户代理时需要设置邮件服务器的。2. POP3地址(如pop3.gmail.com)，如果这个地址设置错误，就会导致用户无法接收邮件。用户代理中的SMTP地址错误的话会导致无法发送邮件。收件人E-mail地址错误的话，可能会发错人，也可能会导致投递失败(不存在的地址)。 12、与数据库表有关的约束not null数据库中表的常见七大约束 空属性not null：not null 此列属性不允许为空，必须做数据插入 默认值：某一种数据会经常性的出现某个具体的值，可以在一开始就指定好，在需要真实数据的时候，用户可以选 择性的使用默认值。 列描述 comment：comment描述仅作为列的作用，没有实际含义 自动填充0 （zerofill） 主键约束（primary key）：主键用于唯一约束字段数据，使用主键约束的字段，不能为空，不能重复，主键所在的列为整数类型，一张表有且只能有一个主键 自增长（auto_increment） 唯一键（unique） 13、n=4有多少种出栈序列1234f(1) = 1 //即 1f(2) = 2 //即 12、21f(3) = 5 //即 123、132、213、321、231f(4) = f(3) + f(2) * f(1) + f(1) * f(2) + f(3) 14、 www.aibank.com 域名使用https的原因：防止流量劫持SSL协议提供了对服务器的身份认证，所以DNS劫持导致连接错误服务器的情况将会被发现进而终止连接，最终导致DNS挟持攻击无法实现。此外SSL协议还提供数据的加密和完整性校验，这就解决了关键信息被嗅探以及数据内容被修改的可能。 15、gcc工具不可用于Java构建（Maven、Gradle、Ant）16、JVM内存：Java方法、程序计数器、方法===线程隔离 程序计数器是一个比较小的内存区域，指示当前线程所执行的字节码执行到了第几行，是线程隔离的 Java方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的 方法区用于存储JVM加载的类信息、常量、静态变量、编译器编译后的代码等数据，是线程共享的 原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的 17、Hadoop的调度器有哪些 默认的调度器FIFO 计算能力调度器Capacity Scheduler 公平调度器Fair Scheduler 适用于异构集群的调度器LATE 适用于实时作业的调度器Deadline Scheduler和Constraint-based Scheduler 珍爱网笔试（线下）1、书写最简单的单例模式 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 何时使用当系统需要某个类只有一个实例的时候 优点单例模式的类唯一实例由其本身控制，可以很好的控制用户何时访问它。 代码123456789public class SimpleSingleton &#123;private static SimpleSingleton instance;private SimpleSingleton()&#123;&#125;public static SimpleSingleton getIntance()&#123;if(instance == null)instance = new SimpleSingleton();return instance;&#125;&#125; 一点资讯笔试1、这个等式在哪种进制下成立，24*18=396（8进制）2、PCI总线PCI总线是一种树型结构，并且独立于CPU总线，可以和CPU总线并行操作。PCI总线上可以挂接PCI设备和PCI桥片，PCI总线上只允许有一个PCI主设备，其他的均为PCI 从设备，而且读写操作只能在主从设备之间进行，从设备之间的数据交换需要通过主设备中转 3、TCP通过（IP地址+端口号）来区分不同的连接4、内存1GB，机械磁盘80GB，10亿条索引数据，每条32B，哪种索引方式5、修改文件或目录的权限的命令是chmod chmod [who] [+ | - | =] [mode] 文件名 把index.html 文件修改为可写可读可执行:chmod 777 index.html 要修改目录下所有文件属性可写可读可执行:chmod 777 . 6、修改某个文件或目录的所有者和所属的组（chgrp）使用chown命令更改文件拥有者 12chown [-R] 账号名称 文件或目录chown [-R] 账号名称:用户组名称 文件或目录 使用chgrp命令更改文件所属用户组 1chgrp [-R] 用户组名称 dirname/filename ... 7、2018个结点完全二叉树，叶子结点1009，高度为11 排成完全二叉树时叶子节点最多 高度为11的满二叉树有2^11-1=2047个节点，高度为10的满二叉树有2^10-1=1023个节点 由2018-1023=995，可以得出第11层有995个叶子节点 然后第10层有512-995/2=16个叶子节点，所以总的叶子节点数为995+14=1009个 8、Linux 压缩的日志文件“youzan.log.gz”中查找关键字“exception”并统计出现次数0 zgrep “start” ./xxx.gz 9、有19球，分为4堆，至少3球，多少种同花顺笔试1、int m=10;int n=11;交换m,n,不使用临时变量，至少两种方法123456789101112131415161718192021//交换a、b的值，不使用临时变量public class change &#123; public static void main(String[] args) &#123; int a = 11; int b = 22; //交换a、b的值（加减法） a = a + b; b = a - b; a = a - b; //交换a、b的值（乘除法） a = a * b; b = a / b; a = a / b; //交换a、b的值（异或法） a ^= b;//a=a^b b ^= a;//b=b^(a^b)=b^a^b=b^b^a=0^a=a a ^= b;//a=(a^b)^a=a^b^a=a^a^b=0^b=b &#125;&#125; 2、进程间通信方式，以及各自的特点和应用场景 （有名）管道：单向的，先进先出，提供了简单的流控制，进程读空管道或者写满管道，都将造成进程阻塞管道包括无名管道和有名管道，前者用于父子间进程通信，后者用于任意两个进程间通信 信号：因按键、硬件异常、进程调用kill函数将信号发送给另一个进程、用户调用kill命令将信号发送给其他进程，传递的消息比较少，主要是通知消息 消息队列：一个消息链表，可以把消息看作一个记录，具有特定的格式，进程可以向队列中添加消息或者读走消息，有缓冲区 共享内存：映射一段可以被其他进程访问的内存，这段共享物理内存由一个进程创建，但是多个进程都可以访问，共享内存是进程间共享数据的一种最快的方法 信号量：用于保护临界资源，进程可以根据它来判断是否能够访问某些公共资源，除了用于反复问控制外，还可以用于进程同步，相当于计数器 套接字：可以用于不同进程间的通信。 流式套接字：提供可靠的，面向连接的通讯流 数据包套接字：定义一种无连接的服务，通过相互独立的报文进行传输，是无序的 原始套接字：用于新的网络协议的测试 3、进程 描述一个进程在内存中的布局和具体的作用/一个进程能使用的内存地址空间有多大？如果超过这个限制，程序会报什么错误？/如何访问（读、写）另外一个进程的内存 代码区Code segment：存放程序的二进制代码, 常量区Constant segment：所有常量均存放在常量区。程序结束后由OS释放 全局数据区Global data segment：全局变量和静态数据,即使是函数内部的静态局部变量,均存放于全局数据区。程序结束后由Os释放 堆区Heap segment：由程序员分配和释放,若程序员不释放,程序结束时可能由OS释放。该区存放由new, malloc产生的动态数据, 栈区Stack segment：由编译器自动分配和释放。存放: 函数内部的自动变量,即局部变量, 函数的参数值, 内存溢出 堆区最多开2G - 1大小空间 栈区能开1G多，当接近2G就会报错 内存共享，消息传递，或者产生CopyDataStruct缓冲区 4、正整数和负整数在内存中的存储有什么区别？（补码）整数在内存中是以补码的形式存放，其中正整数的源码反码补码形式相同；负整数的原码反码补码形式不同 5、Linux上从另一台服务器上拷贝文件到本机应该执行什么指令将远程linux主机上/remote/path的文件copy到本主机的/local/path目录 1scp user@remote.machine:/remote/path /local/path 将本主机的/local/path目录copy到远程linux主机上/remote/path的文件 1scp /local/path user@remote.machine:/remote/path 6、编程实现二分查找算法12345678910111213/* 数组实现 */ int *bsearch(int *t, int n, int x) &#123; int lo = 0, hi = n; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if (x &lt; t[mid]) hi = mid; else if (x &gt; t[mid]) lo = mid + 1; else return t + mid; &#125; return NULL; &#125; 7、TCP的三次握手，TIME_WAIT和CLOSE_WAIT状态是什么 TIME_WAIT ：主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。 由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接 CLOSE_WAIT：被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。 8、编写代码。判断CPU是大端还是小端存储顺序12345678910111213#include &quot;stdio.h&quot;int main()&#123; union w&#123; int a; //4 bytes char b; //1 byte &#125; c; c.a=1; if (c.b==1) printf(&quot;It is Little_endian!\n&quot;); else printf(&quot;It is Big_endian!\n&quot;); return 1;&#125; 9、编程 一个整数数组中的元素有正有负，在该数组中找出一个连续子数组，要求该子数组中各元素的和最大（即最大子数组） 10、观察者模式伪代码123456789101112131415161718192021//即时通信客户端伪代码public class ClientObservable extends java.util.Observable&#123; private static ClientObservable instance = new ClientObservable(); public static ClientObservable getInstance()&#123; return instance; &#125; public void addListener( RevcListener listener )&#123; this.addObserver( listener ); &#125; public void fire( RevcMessage message )&#123; this.setChanged(); this.notifyObservers( message ); &#125; public static abstract class RevcListener implements java.util.Observer&#123; @Override public void update( Observable o, Object arg )&#123; this.onRevc( ( RevcMessage ) arg ); &#125; public abstract void onRevc( RevcMessage message ); &#125;&#125; 12345678//在客户端显示界面调用ClientObservable.getInstance().addListener( new RevcListener()&#123; @Override public void onRevc( RevcMessage message )&#123; //TODO MyPane.this.t.setText( &quot;1111111111111111&quot; );&#125; &#125; ); 11、对非对称加密的理解，什么时候使用非对称加密 非对称加密在加密的过程中使用一对密钥。一对密钥中一个用于加密，另一个用来解密。如用A加密，则用B解密；如果用B加密，则要用A解密。在这对密钥中一个密钥用来公用，另一个作为私有的密钥；用来向外公布的叫做公钥，另一半需要安全保护的是私钥。 非对称加密安全性更好：非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。 非对称加密缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 12、爬台阶12345678910111213141516171819202122232425262728293031323334353637383940public class ClimbStairs&#123;/*** 使用朴素递归的方法和动态规划的方法实现求爬楼梯的方法数*/ public static void main(String[] args)&#123; long start1, start2;//用于记录两个子函数开始运行的时间 Scanner str = new Scanner(System.in); int number = str.nextInt();//获得台阶数目 long count[] = new long[number + 1];//用于记录动态规划中子问题的解 count[0] = 1L; count[1] = 1L; start1 = System.currentTimeMillis();//记录函数1的开始时间 System.out.println(&quot;There are &quot; + fun1(number) + &quot; methods.&quot;); System.out.println(&quot;Cost &quot; + (System.currentTimeMillis() - start1) + &quot; ms.&quot;);//获得函数1的执行时间 start2 = System.currentTimeMillis();//记录函数2的开始时间 System.out.println(&quot;There are &quot; + fun2(count, number) + &quot; methods.&quot;); System.out.println(&quot;Cost &quot; + (System.currentTimeMillis() - start2) + &quot; ms.&quot;);//获得函数2的运行时间 &#125; //定义朴素递归调用方法 public static long fun1(int num)&#123; if (num == 1)//基础情况 return 1L; else if (num == 2)//基础情况 return 2L; else return fun1(num - 1) + fun1(num - 2);//递归调用 &#125; //定义动态规划方法 public static long fun2(long count[], int num)&#123; if (num == 1)//基础情况 return 1L; else&#123; for (int i = 2; i &lt;= num; i++)&#123; count[i] = count[i - 1] + count[i - 2]; //这里并没有调用原函数计算，而是直接使用子问题的结果 &#125; &#125; return count[num]; &#125;&#125; 13、什么是深拷贝？什么是浅拷贝？ 浅拷贝是对指针的拷贝，拷贝后两个指针指向同一个内存空间， 深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。 14、利用sort()排序整个vector容器里元素的时间复杂度是多少15、写一个分割字符串的函数，它可以将一个用某分隔符分割的字符串解析成分割后的结果集16、什么是死锁？如何确保N个线程可以访问N个资源同时又不导致死锁？ 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 指定锁的顺序，并强制线程按照指定的顺序获取锁。因此所有的线程都是以同样的加锁和释放锁，就不会出现死锁了 多线程产生死锁的四个必要条件： 互斥条件：一个资源每次只能被一个进程使用。 保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。 不可剥夺调教：进程已获得资源，在未使用完成前，不能被剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 17、IP:188.188.0.111，IP:188.188.5.222，子网掩码设为255.255.252.0，在同一网段吗？为什么两个ip不在一个网段 188.188.0.111 的网络号是 188.188.0.0 188.188.5.222 的网络号是 188.188.4.0 18、一个使用GBK的中文文本文件，按照CP936读取，不产生乱码19、编程 假如有一个包含2017年所有日期的数组，数组中每个元素都是“月日”格式的字符串，且日期是按照从小到大排列的，类似这样：{“0101”，“0102”，“0103”，…}请编写程序，该程序可以传入一个”月日”格式的日期，并返回该日期是数组中的第几个元素，比如传入”0101”,则返回1；传入“0103”，则返回3 猪八戒笔试1、RuntimeException/Exception 抛出 RuntimeException，调用方法的程序员不需要知道会出这个异常 抛出Exception的方法，调用者需要明确知道这个方法里会出现什么异常，并提示调用者要去处理这个可能得异常。 2、java.util.List不能存整数/数组/加入重复的数据List一般允许重复的元素存在 3、命令行中改变当前目录/文件夹的Linux/Window命令是（cd）cd: change directory 切换目录 4、1是Long还是Objectlong型可以表示的整型数字范围为-2^32 ~ 2^32-1。 5、java.util.Map不能存整数/数组map是key-value的形式存放的 6、计算机缺了（硬盘/显示器/内存）部件，不可能工作7、将int转换为String的正确方法 String s = String.valueOf(i); String s = Integer.toString(i); String s = “” + i; 8、and是SQL关键字？（true）9、多表关联查询，用关联条件的字段建立索引，可以提高SQL语句效率SQL以order by的字段建立索引，可以改变SQL语句效率 10、protected 子类、父类 protected：本包可以访问，子类可以继承。 某类的protected 方法和属性在包外是不能通过该类对象进行访问的 在该类包外的子类中能“看到“的只是子类自己继承来的protected 方法和属性，它是不能“看到“它的父类对象的protected方法和属性的。 11、long.MAX_VALUE/0（运行时异常）12、队列可以基于java.util.Set实现（false） Queue接口与List、Set同一级别，都是继承了Collection接口。 LinkedList实现了Queue接口。 Queue接口窄化了对LinkedList的方法的访问权限，即在方法中的参数类型如果是Queue时，就完全只能访问Queue接口所定义的方法 了，而不能直接访问 LinkedList的非Queue的方法，以使得只有恰当的方法才可以使用。 BlockingQueue 继承了Queue接口。 13、Integer.MAX_VALUE+1==?（运行时异常） Integer.MAX_VALUE+1=Integer.MIN_VALUE Integer.MAX_VALUE的二进制是0111 1111 1111 1111 1111 1111 1111 1111 Integer.MIN_VALUE的二进制是 1000 0000 0000 0000 0000 0000 0000 0000 14、如果不使用native实现，java程序不可能发生内存泄露内存泄漏发生的原因和解决方法。 全局集合 在大型应用程序中存在各种各样的全局数据仓库是很普遍的，在这些情况下，必须注意管理储存库的大小。必须有某种机制从储存库中移除不再需要的数据。 解决形式 一种周期运行的清除作业，验证仓库中的数据然后清除一切不需要的数据。 使用反向链接(referrer)计数，集合负责统计集合中每个入口的反向链接的数目，要求反向链接告诉集合何时会退出入口。当反向链接数目为零时，该元素就可以从集合中移除了。 缓存 缓存一种用来快速查找已经执行过的操作结果的数据结构，把常用的输入数据的操作结果进行缓存，以便在下次调用该操作时使用缓存的数据。通常以动态方式实现，如果缓存设置不正确而大量使用缓存的话则会出现内存溢出的后果，因此需要将所使用的内存容量与检索数据的速度加以平衡。 解决途径是使用java.lang.ref.SoftReference类坚持将对象放入缓存。这个方法可以保证当虚拟机用完内存或者需要更多堆的时候，可以释放这些对象的引用。 类装载器 Java类装载器的使用为内存泄漏提供了许多可乘之机。一般来说类装载器都具有复杂结构，因为类装载器不仅仅是只与”常规”对象引用有关，同时也和对象内部的引用有关。比如数据变量，方法和各种类。这意味着只要存在对数据变量，方法，各种类和对象的类装载器，那么类装载器将驻留在JVM中。既然类装载器可以同很多的类关联，同时也可以和静态数据变量关联，那么相当多的内存就可能发生泄漏。 从JVM获得内存系统信息的方法基本上有两种： ava虚拟机工具接口(Java Virtual Machine Tools Interface，JVMTI)及其前身Java虚拟机监视程序接口(Java Virtual Machine Profiling Interface，JVMPI)是外部工具与JVM通信并从JVM收集信息的标准化接口。 字节码技术是指使用探测器处理字节码以获得工具所需的信息的技术。 15、select * from A left join B on 1=2on：与取得结果集同步进行数据刷选及过滤 16、JDK不能安装到服务器上（false）17、索引可能加快select/update/delete的速度（true）索引除了提高查询速度外，也能提高DML操作的速度 18、(0xF&lt;&lt;8)&amp;&amp;0xF结果（1）~在C语言中是按位取反的意思，~(0xf)则要看一起运算的变量或者赋值的变量类型。 如果是unsigned char（8位），unsigned char i = ~(0xf); 那么 ~(0Xf)=11110000（2进制）=0xF0=240（10进制无符号数） 如果是char（8位），char i = ~(0xf); 那么 ~(0Xf)=11110000（2进制）=0xF0=-16（10进制有符号数） 如果是unsigned short（16位），unsigned short i = ~(0xf); 那么 ~(0Xf)=1111111111110000（2进制）=0xFFF0=65520（10进制无符号数） 如果是short（16位），short i = ~(0xf); 那么 ~(0Xf)=1111111111110000（2进制）=0xFFF0=-16（10进制有符号数） 19、生产者消费者模式 生产者消费者模式中，如果生产者多线程，消费者单线程，不会有线程安全问题（false） 采用wait—notify实现生产者消费者模式 一生产者与一消费者： 一生产者与多消费者： 20、若要把变量声明为多个线程共用的变量，应使用修饰符（volatile）如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。即，用transient关键字标记的成员变量不参与序列化过程。 21、int x=’A’-‘a’;x的值（26）ASCII码运算]]></content>
      <categories>
        <category>笔经面经</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试汇总帖-2]]></title>
    <url>%2F2018%2F10%2F03%2F%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93%E5%B8%96-2%2F</url>
    <content type="text"><![CDATA[搜狐笔试1、JOIN、FULL JOIN join on 取到的只有左右两边都匹配上的记录数，即总记录数=左右都匹配上的记录数。 full join on 取到的除了左右两边都匹配上的记录数，对于左边表与右边表没有匹配的，用null补上作为右边表匹配的数据；右边表与左边表没有匹配的，用null补上作为左边表匹配的数据。总记录数=左边未匹配记录数+右边未匹配记录数+左右都匹配上的记录数。 因此，full join on 的记录数〉= join on的记录数 2、默认的MySQL隔离级别（Repeatable read）REPEATABLE READ为默认事务隔离级别。 READ UNCOMMITTED（读未提交数据）：允许事务读取未被其他事务提交的变更数据，会出现脏读、不可重复读和幻读问题。 READ COMMITTED（读已提交数据）：只允许事务读取已经被其他事务提交的变更数据，可避免脏读，仍会出现不可重复读和幻读问题。 REPEATABLE READ（可重复读）：确保事务可以多次从一个字段中读取相同的值，在此事务持续期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读，仍会出现幻读问题。 SERIALIZABLE（序列化）：确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，可避免所有并发问题，但性能非常低。 3、适合做数据库索引的数据结构（哈夫曼树）目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构 4、设置背景颜色给div元素设置背景色可以通过以下几种方式实现： 在div元素的style属性上设置background-color，此种只能一个一个的div设置，不能批量 使用css设置div元素的background-color，此种可以按ID设置一个div，也可以按class设置指定的多个div，也可以直接使用dom的div批量设置整个页面的div 使用Jquery设置div元素的background-color，同样可以按ID、class、div设置 5、启动类加载器由JVM实现不属于Java类/不同类加载器加载的同一个类在JVM属于不同的类 “命名空间”，是指jvm为每个类加载器维护的一个“表”,这个表记录了所有以此类加载器为“初始类加载器”（而不是定义类加载器，所以一个类可以存在于很多的命名空间中）加载的类的列表 一个类，由不同的类加载器实例加载的话，会在方法区产生两个不同的类，彼此不可见，并且在堆中生成不同Class实例。 6、Java的栈内存不是线程共享的在多线程环境下，每个线程拥有一个栈和一个程序计数器。栈和程序计数器用来保存线程的执行历史和线程的执行状态，是线程私有的资源。其他的资源（比如堆、地址空间、全局变量）是由同一个进程内的多个线程共享 7、打印文本文件file.txt中除掉“1”开头的行和空行的信息1#more /etc/file.txt | grep ^ [^1] 使用grep -v “^#” 来去掉注释行，其中：-v 就是取相反的 ^# 表示以#开头的行，可以使用“&gt;”来重写配置文件 1eg. grep -v &quot;^#&quot; /etc/vsftpd/vsftpd.conf 有时也会连同空行一起去掉，使用管道符来完成（^$表示空行 ） 1eg. grep -v &quot;^#&quot; httpd.conf | grep -v &quot;^$&quot; &gt;&gt; vsftpd.conf 上面用了 2次 grep 过滤命令 ，也就是把空行和注解行过滤掉，再把剩下的内容追加保存为原来的配置文件 vsftpd.conf 这个时候就文件里的内容就没有注解行和空行了。 备注：在更改配置文件时，建议先对配置文件做一下备份，对配置文件不熟悉的建议不要用这种方法，配置文件中的注解行还是有一定的帮助的。 shell储备知识： ^一行的开始 ^d以开头的 ^..1 第三个为1的字符 ^字符要放在匹配的字符前面 $一行的末尾 ^$ 表示空行 ^.$匹配一行一个字符的 $字符要放在匹配的字符后面 *匹配任意个字符 包括0个字符 ‘.’表示单个字符 \可以屏蔽一个特殊的字符 *.pas 这里的 是特殊字符，这样就表示 .pas这个文件 逗号可以分割不同的匹配字符如[S,s]表示S或者s都可以 -表示一个范围，[1-9],[a-z],[A-Z] [1-9 A-Z a-z]任意的字符或者数字 A{2}B 表示A出现了2次 AAB A{4,}B 表示A至少出现4次 AAAAB，AAAAAB A{2,4}B 表示A出现2－4次 AAB AAAB AAAAB [0-9]{3}.[0-9]{3}.[0-9]{3}.[0-9]{3} 0-999.0-999.0-999.0-999 8、Spring为简化Java开发采用策略为了降低Java开发的复杂性，Spring采取了以下关键策略： 基于POJO的轻量级和最小侵入性编程； 通过依赖注入和面向接口实现松耦合； 基于切面和惯例进行声明式编程； 通过切面和模板减少样板式代码。 9、Spring的切面是在目标对象生命周期的哪个阶段植入的 织入是把切面应用到目标对象并创建新的代理对象的过程。 切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入： 编译期：切面在目标类编译时被织入，这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。 类加载期：切面在目标类加载到jvm时被织入。这种方式 需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态的创建一个代理对象。Spring AOP就是以这种方式织入切面的。 10、DTD/XSDDTD(Documnet Type Definition)，文档类型定义一种XML约束模式语言，XML文件的验证机制,属于XML文件组成的一部分。 DTD 是一种保证XML文档格式正确的有效方法，可以通过比较XML文档和DTD文件来看文档是否符合规范，元素和标签使用是否正确。 一个 DTD文档包含：元素的定义规则，元素间关系的定义规则，元素可使用的属性，可使用的实体或符号规则。 DTD 是使用非 XML 语法编写的。 DTD 不可扩展,不支持命名空间,只提供非常有限的数据类型 . XSD(XML Schemas Definition)，描述了XML文档的结构。 可用一个指定的XML Schema来验证某个XML文档，以检查该XML文档是否符合其要求。文档设计者可以通过XML Schema指定一个XML文档所允许的结构和内容，并可据此检查一个XML文档是否是有效的。 XML Schema本身是一个XML文档，它符合XML语法结构。可以用通用的XML解析器解析它。 一个XML Schema包含：文档中出现的元素、文档中出现的属性、子元素、子元素的数量、子元素的顺序、元素是否为空、元素和属性的数据类型、元素或属性的默认 和固定值。 XSD是DTD替代者的原因 据将来的条件可扩展 XSD比DTD丰富和有用 用XML书写 支持数据类型 支持命名空间。 途牛笔试1、运算符优先级！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符 2、不属于jQuery的筛选（自动）：自动/过滤/查找/串联 属性筛选 内容筛选 层级筛选 方法筛选 3、Thread方法（getPriority）Thread类构造方法： Thread（）； Thread（String name）； Thread（Runable r）； Thread（Runable r, String name）； Thread类常用方法： start();//启动线程 getId();//获得线程ID getName();//获得线程名字 getPriority();//获得优先权 isAlive();//判断线程是否活动 isDaemon();//判断是否守护线程 getState();//获得线程状态 sleep(long mill);//休眠线程 join();//等待线程结束 yield();//放弃cpu使用权利 interrupt();//中断线程 currentThread();//获得正在执行的线程对象 4、null是object/string（string）object不能为null 5、IPV4和IPV6地址长度（32,128） IPv4地址的二进制形式长度为32 IPv6地址的二进制形式长度为128 6、支持HTML5的浏览器（Safari、Chrome、Firefox、Opera）主流浏览器对html5的支持情况 Chrome，Firefox：自动升级，支持最好。 Safari，Opera IE9及其更高版 Firefox（火狐浏览器） Safari Opera 傲游浏览器（Maxthon） 360浏览器 搜狗浏览器 QQ浏览器 猎豹浏览器等 7、浏览器的存储技术（cookie、localStorage）Cookiecookie是什么cookie是指存储在用户本地终端上的数据，同时它是与具体的web页面或者站点相关的。cookie数据会自动在web浏览器和web服务器之间传输，也就是说HTTP请求发送时，会把保存在该请求域名下的所有cookie值发送给web服务器，因此服务器端脚本是可以读、写存储在客户端的cookie的操作。 cookie的有效期cookie默认情况下的有效期是很短暂的，一旦用户关闭浏览器，cookie保存的数据就会丢失。如果想要延长cookie的有效期，可以通过设置HTTP头信息中的cache-control属性的max-age值，或者修改HTTP头信息中的expires属性的值来延长有效期。 cookie的作用域它是通过文档源和文档路径来确定的。该作用域通过cookie的path和domain属性也是可配置的。默认情况下，cookie和创建它的web页面有关，并对该页面以及和该页面同目录或者子目录的其他页面可见。有时候，你可能希望让整个网站都能够使用cookie的值，而不管是哪个页面创建它。要满足这样的需求可以设置cookie的路径(设置cookie的path属性)。cookie的作用域默认由文档源限制。但是，有的大型网站想要子域之间能够互相共享cookie。 cookie的数目和大小的限制每个web服务器(域名)保存的cookie数不能超过50个，每个cookie保存的数据不能超过4KB，如果超过了4KB（IE6大约只能存储2K），服务器会处理不了。 cookie的优点能用于和服务器端通信；当cookie快要过期时，可以重新设置而不是删除。 cookie的缺点它会随着http头信息一起发送，增加了网络流量（文档传输的负载）；它只能储存少量的数据；它只能储存字符串；有潜在的安全问题。 另外，自从有了Web Storage API(Local and Session Storage)，cookie就不被推荐用于存储数据了 2、LocalStoragelocalStorage是什么在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。 localStorage的优点 localStorage拓展了cookie的4K限制； localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的； localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 localStorage的缺点： 浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性； 目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换； localStorage在浏览器的隐私模式下面是不可读取的； localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡； localStorage不能被爬虫抓取到。 3、SessionStoragesessionStorage与localStorage的唯一一点区别就是localStorage属于永久性存储，而sessionStorage属于当会话结束的时候，sessionStorage中的键值对就会被清空。 4、UserData、GlobalStorage、Google Gear这三种的使用都有一定的局限性 userData是IE浏览器专属，它的容量可以达到640K，这种方案可靠，不需要安装额外插件，只不过它仅在IE下有效 globalStorage适用于Firefox 2+的浏览器，类似于IE的userData google gear是谷歌开发出的一种本地存储技术，需要安装Gear组件。 5、Flash ShareObject这种方式能能解决上面提到的cookie存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个Flash，当浏览器没有安装Flash控件时就不能用了。所幸的是，没有安装Flash的用户极少。 cookie,localStorage和sessionStorage的异同：共同点：都是保存在浏览器端，且同源的。区别： cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存； cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下； 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识；sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大； 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭； 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的； Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者；Web Storage 的 api 接口使用更方便。 8、A关闭与B的TCP连接所经历的状态（TIME_WAIT、FIN_WAIT_1、FIN_WAIT_2） 在服务端输入Ctrl+C终端服务端程序，再次输入netstat–ant命令，看到服务端进入了FIN_WAIT2状态，而客户端进入了CLOSE_WAIT状态。 FIN_WAIT2状态就是服务端在主动发起断开的连接请求时，发送FIN并收到客户端的ACK进入的等待客户端FIN的状态；而与FIN_WAIT2相对的FIN_WAIT1就是服务端发送完成FIN后还未接收到客户端返回的ACK时进入的状态，这个状态时长很短，在我本机上无法捕捉；这个CLOSE_WAIT状态是客户端接受到服务端的FIN并发送ACK后，等待用户手动关闭套接字的状态。 此时如果关闭客户端的套接字，直接在客户端输入Ctrl+C，服务端就会进入我们熟悉的TIME_WAIT状态：客户端也在断开连接后会进入Time-wait状态 从主机A主动发起断开连接请求的四次握手过程: 第一次握手：主机A发送FIN数据包，SEQ设置为5000，表示主机B在接收到数据后需要返回一个ACK为5001的数据包，否则主机A重新发送该数据包。 第二次握手：主机B发送ACK为5001的数据包表示成功接收主机A断开连接请求，同时SEQ为6000，但是这是断开连接的过程，主机B不会期望主机A返回ACK为6001的数据包。 第三次握手：主机B准备好了断开连接工作后，向主机A发送FIN数据包，表示请求断开与A的连接，同时SEQ设置为6001，ACK设置为5001。 第四次握手：主机A接收到主机B请求断开连接的数据包之后返回允许断开连接的数据包，SEQ设置为5001，同时ACK设置为6002表示已经成功接收主机B发送的数据包。 9、OLAP多维分析操作OLAP的基本多维分析操作有钻取、切片和切块、以及旋转等。 钻取：是改变维的层次，变换分析的粒度。它包括向下钻取（Drill-down）和向上钻取（Drill-up）/上卷(Roll-up)。Drill-up是在某一维上将低层次的细节数据概括到高层次的汇总数据，或者减少维数；而Drill-down则相反，它从汇总数据深入到细节数据进行观察或增加新维。 切片和切块：是在一部分维上选定值后，关心度量数据在剩余维上的分布。如果剩余的维只有两个，则是切片；如果有三个或以上，则是切块。 旋转：是变换维的方向，即在表格中重新安排维的放置（例如行列互换）。 10、对网站的文件和资源进行优化（文件合并、使用CDN托管、缓存、文件拆分） 文件合并（目的是减少http请求）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;减少HTTP请求的方案主要有合并JavaScript和CSS文件、CSS Sprites、图像映射 （Image Map）和使用Data URI来编码图片。目前大部分网页中的JavaScript和CSS文件数量和开发时一致，少量的网页会根据实际情况采取本地合 并，这些合并中相当多的是有选择地手动完成，每次新的合并都需要重新在本地完成并上传到服务器，比较的随意和繁琐，同样文件的压缩也有类似的情况。而利用 服务端的合并和压缩，可以按照开发的逻辑尽可能让文件的颗粒度变小，利用网页中URL的规则来自动实现文件的合并和压缩，这会相当的灵活和高效。 文件压缩：目的是直接减少文件下载的体积 使用 CDN （内容分发网络）来托管资源：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。 缓存的使用（并且多个域名来提供缓存） GZIP 压缩JS 和 CSS 文件 11、HTTP1.1版本支持的请求方法（GET/OPTION/DELETE/TRACE） POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 GET向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。 PUT向指定资源位置上传其最新内容 DELETE请求服务器删除Request-URI所标识的资源。 HEAD向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 OPTIONS返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。 TRACE回显服务器收到的请求，主要用于测试或诊断。 CONTENTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 12、类方法调用另一个类的私有方法（通过反射）实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.lang.reflect.Field;import java.lang.reflect.Method;/** * 通过反射调用类的private方法以及属性 * */public class ReflectByInvokePrivate &#123;/*** @param args*/public static void main(String[] args) throws Exception &#123; PrivateDemo pDemo=new PrivateDemo(); Class&lt;?&gt; classType=pDemo.getClass();//创建该对象的class对象 Method m=classType.getDeclaredMethod(&quot;sayHello&quot;, new Class[]&#123;String.class&#125;);//通过class对象获取需要调用的方法 m.setAccessible(true);//压制java检查机制 使得private可访问 String result= (String)m.invoke(pDemo, new Object[]&#123;&quot;dawson&quot;&#125;); System.out.println(result); System.out.println(&quot;-------------------华丽的分割线----------------------&quot;); Field feild=classType.getDeclaredField(&quot;userName&quot;);//获取对应的属性 feild.setAccessible(true);//压制java检查 feild.set(pDemo, &quot;李四&quot;);//设置该属性的值 Method m1=classType.getDeclaredMethod(&quot;getUserName&quot;, new Class[]&#123;&#125;); m1.setAccessible(true); result= (String)m1.invoke(pDemo, new Object[]&#123;&#125;); System.out.println(result); &#125;&#125;class PrivateDemo&#123; private String userName=&quot;张三&quot;; private String sayHello(String name)&#123; return &quot;Hello &quot;+name; &#125; public String getUserName()&#123; return userName; &#125;&#125; 13、重载的面向对象特性多态：多态是指允许不同类的对象对同一消息作出响应。多态包括参数化多态和包含多态。多态语言具有灵活、抽象、行为共享、代码共享等优势，很好地解决了应用程序函数的同名问题。 参数多态（parametric），采用参数化模板，通过给出不同的参数列表，使得一个结构有多种类型。 包含多态（InclusionPolymorphism）：同样的操作可用于一个类型及其子类型。包含多态一般需要进行运行时的类型检查。 14、firebug自动完成上一个属性的快捷键（Tab/调试JS）Firebug快捷键 打开Firebug窗口:F12 关闭Firebug窗口:F12 在新窗口打开Firebug:Ctrl+F12 往前切换标签:Ctrl+` 将光标移到命令行:Ctrl+Shift+L 将光标移到搜索框:Ctrl+Shift+K 进入Inspect模式:Ctrl+Shift+C 进行JavaScript性能测试:Ctrl+Shift+P 重新执行最后一条命令行命令:Ctrl+Shift+E HTML标签 编辑属性:单击属性名或值 编辑文本节点:单击文本 编辑Element:双击Element标记 移到路径里的下一个节点:Ctrl+. 移到路径里的上一个节点:Ctrl+, HTML编辑 完成编辑:Return 取消编辑:Esc 移到下一个区域:Tab 移到上一个区域:Shift+Tab HTML Inspect 模式 取消Inspect:Esc Inspect 父节点:Ctrl+Up Inspect 子节点:Ctrl+Down Script标签 继续运行:F5 或 Ctrl+/ 单步执行（Step Over）:F10 或 Ctrl+’ 单步执行（Step Into）:F11 或 Ctrl+; 退出函数（Step Out）:Shift+F11或 Ctrl+Shift+; 设置断点:单击行号 禁止断点:在行号上Shift+Click 编辑断点条件:在行号上Right-Click 运行到当前行:在行号上Middle-Click或 在行号上Ctrl+Click 移到堆栈中的下一个函数:Ctrl+. 移到堆栈中的上一个函数:Ctrl+, 将焦点切换到Scripts菜单:Ctrl+Space 将焦点切换到Watch编辑:Ctrl+Shift+N DOM 标签 编辑属性:双击在空白 移到路径中下一个对象:Ctrl+. 移到路径中上一个对象:Ctrl+, DOM 和Watch编辑 结束编辑:Return 取消编辑:Esc 自动完成下一个属性:Tab 自动完成上一个属性:Shift+Tab CSS标签 编辑属性:单击属性 插入新属性:双击空白处 移动焦点到Style Sheets菜单:Ctrl+Space CSS编辑 完成编辑:Return 取消编辑:Esc 移到下一个区域:Tab 移到上一个区域:Shift+Tab 按步长1增加数值:Up 按步长1减少数值:Down 按步长10增加数值:Page Up 按步长10减少数值:Page Down 自动完成下一个关键字:Up 自动完成上一个关键字:Down Layout标签 编辑值:单击值 Layout编辑 完成编辑:Return 取消编辑:Esc 移到下一个区域:Tab 移到上一个区域:Shift+Tab 按步长1增加数值:Up 按步长1减少数值:Down 按步长10增加数值:Page Up 按步长10减少数值:Page Down 自动完成下一个关键字:Up 自动完成上一个关键字:Down 命令行 (小) 自动完成上一个属性:Tab 自动完成下一个属性:Shift+Tab 执行:Return Inspect结果:Shift+Return 打开结果鼠标右键菜单:Ctrl+Return 执行:Ctrl+Return 15、-1,0,127的补码 -1的补码 ：11111111 0的补码 : 00000000 +127的补码：01111111 16、高内聚低耦合 高内聚指一个软件模块是由相关性很强的代码组成，只负责一项任务 低耦合指一个完整的系统，模块与模块之间，尽可能的使其独立存在。让每个模块尽可能的独立完成某个特定的子功能。模块与模块之间的接口，尽量的少而简单。如果某两个模块间的关系比较复杂的话，最好首先考虑进一步的模块划分。这样有利于修改和组合。 17、数据库联合索引联合索引使用结论: 查询条件中出现联合索引第一列,或者全部,则能利用联合索引. 条件列中只要条件相连在一起,以本文例子来说就是:last_name=’1′ and first_name=’1′与first_name=’1′ and last_name=’1′,无论前后,都会利用上联合索引. 查询条件中没有出现联合索引的第一列,而出现联合索引的第二列,或者第三列,都不会利用联合索引查询. 18、Spring能否注入null或空串（都允许）当对象声明为bean组件的时候，它是交给spring容器去管理的，容器会帮你进行初始化；但是如果使用new方法来调用对象时，会跳过spring容器生成新的对象，这时候就无法进行初始化，所以在调试的时候就会出现SparkSource对象为null，并且SparkSource对象里面以注入方式引用的对象也为null；被申明为bean对象的组件必须使用注入的方式进行调用。 19、代码输出（finally）首先只有抛出异常才会进入catch代码块，而finally语义为最后地，即无论如何都会执行finally代码块 20、进制运算（尾数） 用末尾位（个位)判断：乘法运算的个位相乘等于个位的值 进行代数运算 海康威视笔试（技术支持）1、网络层的功能网络层是OSI参考模型中的第三层，介于传输层和数据链路层之间，它在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，将数据设法从源端经过若干个中间节点传送到目的端，从而向运输层提供最基本的端到端的数据传送服务。主要内容 虚电路分组交换和数据报分组交换 路由选择算法 阻塞控制方法 X.25协议 综合业务数据网（ISDN） 异步传输模式（ATM）及网际互连原理与实现。 2、动态路由/静态路由静态路由 在路由器中设置的固定的路由表。除非网络管理员干预，否则静态路由不会发生变化。由于静态路由不能对网络的改变作出反映，一般用于网络规模不大、拓扑结构固定的网络中。静态路由的优点是简单、高效、可靠。在所有的路由中，静态路由优先级最高。当动态路由与静态路由发生冲突时，以静态路由为准 动态路由 网络中的路由器之间相互通信，传递路由信息，利用收到的路由信息更新路由器表的过程。它能实时地适应网络结构的变化。如果路由更新信息表明发生了网络变化，路由选择软件就会重新计算路由，并发出新的路由更新信息。这些信息通过各个网络，引起各路由器重新启动其路由算法，并更新各自的路由表以动态地反映网络拓扑变化。动态路由适用于网络规模大、网络拓扑复杂的网络。 动态路由机制的运作依赖路由器的两个基本功能 路由器之间适时地交换路由信息。动态路由之所以能根据网络的情况自动计算路由、选择转发路径，是由于当网络发生变化时，路由器之间彼此交换的路由信息会告知对方网络的这种变化，通过信息扩散使所有路由器都能得知网络变化。 路由器根据某种路由算法（不同的动态路由协议算法不同）把收集到的路由信息加工成路由表，供路由器在转发IP报文时查阅。在网络发生变化时，收集到最新的路由信息后，路由算法重新计算，从而可以得到最新的路由表。路由器之间的路由信息交换在不同的路由协议中的过程和原则是不同的。交换路由信息的最终目的在于通过路由表找到一条转发IP报文的“最佳”路径。每一种路由算法都有其衡量“最佳”的一套原则，大多是在综合多个特性的基础上进行计算，这些特性有：路径所包含的路由器结点数（hop count）、网络传输费用（cost）、带宽（bandwidth）、延迟（delay）、负载（load）、可靠性（reliability）和最大传输单元MTU（maximum transmission unit）。 动态路由特点 无需管理员手工维护，减轻了管理员的工作负担 占用了网络带宽 在路由器上运行路由协议，使路由器可以自动根据网络拓朴结构的变化调整路由条目 网络规模大、拓扑复杂的网络 3、子网划分技术是在自然分类IP地址上占用哪个部分实现的(主机号)假如需要子网划分，网络地址就需要向主机地址借位 4、二层以太网交换机，如果查找失败，交换机将…无论是单播、组播、广播帧,如果帧的目的MAC地址在MAC地址表中存在,且表项所关联的端口与接收到帧的端口相同时,则交换机对此帧进行过滤,即不转发此帧;对于未知的单播帧(即帧的MAc地址在交换机MAC地址表中无相应表项)、组播帧、广播帧,则除源端口外的其它端口转发出去。 5、在IP网络中，ping是基于（ICMP）协议开发的应用程序ICMP协议Internet Control Message Protocol（internet报文控制协议），TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。所以，ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。它是一个非常重要的协议，它对于网络安全具有极其重要的意义。 6、当网络出现环路，（数据包无休止地传递） 路由环路，就是数据包不断在这个网络传输，始终到达不了目的地，导致掉线或者网络瘫痪。 所有环路的形成都是由于目的路径不明确导致混乱而造成的 第二层环路：一个广播信息经过两个交换机的时候会不断恶性循环的产生广播，造成环路 第三层环路：原路由意外不能工作，造成路由通告错误，形成一个恶性循环 7、IP地址为10.10.10.48，子网掩码为255.255.255.254，子网广播地址（10.10.10.255）网络地址的两种算法 把主机地址和掩码分别转成2进制 相与的结果为网络地址 通过掩码判断网络大小 8、数据链路层标准 802.1–高层及其交互工作。提供高层标准的框架,包括端到端协议、网络互连、网络管理、路由选择、桥接和性能测量。 802.2-连接链路控制LLC,提供OSI数据链路层的高子层功能,提供LAN、MAC子层与高层协议间的一致接口。 802.3-以太网规范,定义CSMA/CD标准的媒体访问控制(MAC)子层和物理层规范。 802.4-令牌总线网。定义令牌传递总线的媒体访问控制(MAC)子层和物理层规范。 802.5-令牌环线网,定义令牌传递环的媒体访问控制(MAC)子层和物理层规范。 802.6-城域网MAN,定义城域网(MAN)的媒体访问控制(MAC)子层和物理层规范(DQDB分布队列双总线)。 9、物理层的主要功能 物理层Physical Layer，计算机网络OSI模型中最低的一层。物理层为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性。 简单的说，物理层确保原始的数据可在各种物理媒体上传输。局域网与广域网皆属第1、2层。 物理层是OSI的第一层，它虽然处于最底层，却是整个开放系统的基础。物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。 “信号和介质”。 10、DNS工作于（应用层） DNS(Domain Name System)域名系统主要负责记录互联网中主机名和该主机IP地址之间的映射关系 对应于某个应用的协议一般都是属于应用层的，应用层下直接基于传输层UDP协议 11、定码率4096kbps/s，每小时文件大小（14400MB）计算输出文件大小公式：（音频编码率（KBit为单位）/8 + 视频编码率（KBit为单位）/8）× 影片总长度（秒为单位）= 文件大小（MB为单位） 12、1080P高清宽屏画质分辨率（1920*1080） VGA(640x480) SVGA(800x600) XGA(1024x768) SXGA+(1400x1050) UXGA(1600x1200) QXGA(2048x1536) WVGA(800x480) WSVGA(1024x600) WXGA(1280x800) WXGA+(1440x900) WSXGA+(1680x1050) WUXGA(1920x1200) WQXGA(2560x1600) qHD(960 x 540) 720p(1280x720) WXGA(1366x768) 1080p(1920x1080) QHD(2560 x 1440) SXGA (1280x1024) 13、（DOS）不是图形化界面的OSDOS没有图形界面。 14、一个c语言的执行C语言的执行是从本程序的 main() { 开始，到 } 结束 15、c语言编译程序 编辑xx.c文件 预处理预处理过程实质上是处理“#”，将#include包含的头文件直接拷贝到hell.c当中；将#define定义的宏进行替换，同时将代码中没用的注释部分删除等 将所有的#define删除，并且展开所有的宏定义。说白了就是字符替换 处理所有的条件编译指令，#ifdef #ifndef #endif等，就是带#的那些 处理#include，将#include指向的文件插入到该行处 删除所有注释 添加行号和文件标示，这样的在调试和编译出错的时候才知道是是哪个文件的哪一行 保留#pragma编译器指令，因为编译器需要使用它们。 编译编译的过程实质上是把高级语言翻译成机器语言的过程，即从 高级语言-&gt;汇编语言-&gt;机器语言（二进制） 词法分析， 语法分析 语义分析 优化后生成相应的汇编代码 链接编译过程只是把源文件翻译成二进制，不能直接执行，需要将翻译成的二进制与需要用到库绑定在一块。 海康威视笔试（Java）1、hik两个线程并发执行，求hik取值范围 （【0,50】/【50,100】） for(int i=0;i&lt;50;i++) 2、配置一个servlet需要的参数，最好在（service）方法中加载配置servlet参数 servletconfig：称为servlet初始化变量，既在一个servlet初始化调用，用于servlet初始化。在init方法中调用。 servletcontext：上下文初始化参数，全局可用的，一个web应用只有一个，在容器启动时调用的。 3、Java关键字（goto、vo..） 由于goto关键字在java之前的语言中广泛使用，因此尽管现在在java中还没有使用该关键字，但是仍然设置为了保留字，一旦在开发环境中输入goto就会变色为关键字颜色。 volatile关键字，在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。 4、null是object类型/String类型(String)object类型转string类型 采用Object.toString() 采用(String)Object String.valueOf(Object) 5、ArrayList和linkedlist区别（数组/链表、线程安全/非线程安全）共同点：都是线程安全的。区别： ArrayList实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList优于LinkedList 对于新增和删除操作add和remove，LinedList比较占优势 6、java中的override和overload区别overload(重载）的特点 不能通过访问权限，返回类型，抛出的异常进行重载； 方法的异常类型和数目不会对重载造成影响； 对于继承来说，如果某一个方法在父类中的修饰符是private，那么就不能在子类对其进行重载了。如果要定义的话，也只是定义了一个新方法。 override(重写）的特点 覆盖的方法的返回值必须和被覆盖的方法返回一致； 覆盖的方法抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类。 被覆盖的方法不能被定义为private。否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 7、空间复杂度最高（归并排序On）归并排序：首先让数组中的每一个数单独成为长度为1的区间，然后两两一组有序合并，得到长度为2的有序区间，依次进行，直到合成整个区间。 12345678910111213141516171819202122232425262728293031323334353637383940////实现归并，并把数据都放在list1里面void merging(int *list1, int list1_size, int *list2, int list2_size) &#123; int i=0, j=0, k=0, m=0; int temp[MAXSIZE]; while(i &lt; list1_size &amp;&amp; j &lt; list2_size) &#123; if(list1[i]&lt;list2[j]) &#123; temp[k++] = list1[i++]; &#125; else &#123; temp[k++] = list2[j++]; &#125; &#125; while(i&lt;list1_size) &#123; temp[k++] = list1[i++]; &#125; while(j&lt;list2_size) &#123; temp[k++] = list2[j++]; &#125; for(m=0; m &lt; (list1_size+list2_size); m++) &#123; list1[m]=temp[m]; &#125; &#125; //如果有剩下的，那么说明就是它是比前面的数组都大的，直接加入就可以了void mergeSort(int array[], int n) &#123; if(n&gt;1) &#123; int *list1 = array; int list1_size = n/2; int *list2 = array + n/2; int list2_size = n-list1_size; mergeSort(list1, list1_size); mergeSort(list2, list2_size); merging(list1, list1_size, list2, list2_size); &#125; &#125; //归并排序复杂度分析：一趟归并需要将待排序列中的所有记录 //扫描一遍，因此耗费时间为O(n)//而由完全二叉树的深度可知//整个归并排序需要进行[log2n],因此，总的时间复杂度为O(nlogn)//而且这是归并排序算法中平均的时间性能 //空间复杂度：由于归并过程中需要与原始记录序列同样数量级的//存储空间去存放归并结果及递归深度为log2N的栈空间//因此空间 复杂度为O(n+logN)//也就是说，归并排序是一种比较占内存，但却效率高且稳定的算法 时间复杂度记忆 冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O（n2）（一遍找元素O(n)，一遍找位置O(n)） 快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)） 稳定性记忆-“快希选堆”（快牺牲稳定性）排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。 8、synchronized 同时刻单线程执行，修饰静态方法/非静态方法/代码块、锁对象/Java基本数据类型 Synchronized，Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。 Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。 Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。注意：一个是对象锁 一个是Class类锁 在多线程中最好不要直接对基本数据类型对象进行加锁来实现线程同步，对于static全局变量，最好的方式是对类（不是类对象）进项加锁。 9、forword和redirectForward和Redirect代表了两种请求转发方式：直接转发和间接转发。 直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。 间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。 举个通俗的例子： 直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”； 间接转发就相当于：”A找B借钱，B说没有，让A去找C借”。 间接转发：间接转发方式，有时也叫重定向，它一般用于避免用户的非正常访问。例如：用户在没有登录的情况下访问后台资源，Servlet可以将该HTTP请求重定向到登录页面，让用户登录以后再访问。在Servlet中，通过调用response对象的SendRedirect()方法，告诉浏览器重定向访问指定的URL 间接转发请求过程浏览器向Servlet1发出访问请求；Servlet1调用sendRedirect()方法，将浏览器重定向到Servlet2；浏览器向servlet2发出请求；最终由Servlet2做出响应。 请求转发直接转发方式，请求转发。Web应用程序大多会有一个控制器。由控制器来控制请求应该转发给那个信息资源。然后由这些信息资源处理请求，处理完以后还可能转发给另外的信息资源来返回给用户，这个过程就是经典的MVC模式。javax.serlvet.RequestDispatcher接口是请求转发器必须实现的接口，由Web容器为Servlet提供实现该接口的对象，通过调用该接口的forward()方法到达请求转发的目的 直接转发请求过程：浏览器向Servlet1发出访问请求；Servlet1调用forward()方法，在服务器端将请求转发给Servlet2；最终由Servlet2做出响应。 10、新建流对象（D）1234（bufferw...(new filew..(txt))objecti...(new filei...(dat))gzipout....(new fileout....(zip))bufferedr....(new filei.....(dat))） Reader只能用FileReader进行实例化 11、集合描述（Hashmap是线程安全的/set） Collection、ArrayList、HashMap、HashSet都是非同步的，线程不安全的 Vector 和 HashTable 线程安全，各自核心方法添加上了synchronized 关键字。 小马智行1、计算机操作的最小单位时间段时钟周期 2、ARP协议实现的功能 域名地址到IP地址的解析 ARP协议其主要作用是将IP地址翻译为以太网的MAC地址 3、因特网中完成域名和IP地址转换的系统 DNS(Domain Name Service) 域名服务 4、设某散列表的长度为200，散列函数H(k)=k%p。则P通常情况下最好选择（91） 97即是质数也是合数 5、设某哈夫曼树有155个结点，则该哈夫曼树中有（77）个叶子节点 哈夫曼树的叶子结点总比内结点多一个 6、排列组合题 仅由3,5,7三个数字构成的八位数中，所有相邻的数字均不相同的八位数总共有（128）个 7、段页式存储管理系统的页表数 每个进程多个/一个、每个系统多个/一个 段页式存储管理中，地址映射表是每个进程一张段表，每个段一张页表，每个进程多个 8、操作系统 处理执行程序时，用（内存）来存放程序和程序处理的数据 9、IP地址为140.131.0.0的B类网络，若要分割为9个子网，子网掩码设为255.255.128.0默认B类地址的子网掩码是/16，也就是255.255.0.0。切割成9个子网的话，就得向主机位借2的四次方=16＞9，即向主机位借4位。所以子网掩码要设置成/20，也就是255.255.240.0 10、快速排序在最坏情况下时间复杂度为（O(nlog2n)） 在最优的情况下,快速排序算法的时间复杂度为O(nlogn) 平均情况下时间复杂度为O(nlog2n) 最坏情况下时间复杂度为O(n*n) 11、TCP/UDP报头需包含哪项信息 源和目的/流量控制/定量/确认 源端口和目标端口 12、Linux Linux系统中，（虚拟存储器）是对处理器、主存和I/O设备的抽象表示 13、分辨率 分辨率为1920*1080/16位色的位图，存储图像信息所需的空间为（4050KB） 记录每个16色的像素需要4位(2^4)所占用空间为1920 1080 4/8B/1024=1012.5KB 14、如果根的高度为1，具有59个节点的完全二叉树的高度为（5）如果根的层次为1, 其高度k应为6, 最大结点数为2的k次方后再减1, 如题应为2的6次方后减5为59, 即高度为6 15、“存储程序” 最早提出这个概念的是（冯`诺依曼） 冯・诺依曼最早提出“存储程序”的概念。 16、连通图与树 设G是有n个结点，n条边（n&lt;=m）的连通图，必须删去G的（m-n+1）条边才能使G变成一棵树 树的边数=点数-1=n-1,所以要删掉m-(n-1)=m-n+1条边 17、数量级 c语言将一个1G字节的字符数组从头到尾全部设置为‘a’，在当代PC需要花费的CPU时间数量级最接近（100s） 1秒这个数量级。首先，典型的当代PC的CPU的主频的数量级是Ghz。那么就是相当于一秒钟可以执行G这个数量级的指令周期。而给每一个内存字节设置一个值’A’,那么这个单个字节设置值一个指令周期就可以完成，’A’存寄存器，每设置一个一个内存字节只需要把寄存器的值传到内存单元中就完事。所以，完成1GB字节的设置的时间数量级就是1秒 18、（外存）数据不能直接被CPU存取 外部存储器上的数据无法被CPU直接处理 19、古典概型 在所有两位数中任取一两位数，被3/5整除的概率是（7/15） 试验发生所包含的所有事件是99-10+1=90个，满足条件的事件是这个数能被3或5整除，能被3整除的数，共有30个，能被5整除的有18个，能被3或5整除的数共有48个，扣掉6个三和五的公倍数 20、TCP第二次握手假设现有客户端A和服务器B 第一次握手：客户端A向服务器B发送连接请求报文段，同步位SYN=1，序列号seq=x，并进入SYNSEND状态； 第二次握手：服务器B接到客户端的请求之后，返回一个确认报文，同部位SYN=1，确认位ACK=1，序列号seq=y,确认号ack=x+1（表示x和x之前的字节流都已收到），并进入SYNRCVD状态； 第三次握手：客户端A在收到服务器B的确认后还要继续返回一个确认报文，确认位ACK=1，seq=x+1，ack=y+1(注意第三次握手的SYN=0)。 21、IPV6地址（128） IPv6地址有128位长 深信服笔试1、下列哪种数据结构最适合医疗设备中的大数据量插入、查找？（红黑树/哈希表） map数据的插入，查找，删除操作都比较快，基于红黑树，时间复杂度在nlogn左右 vector和list都有自己的不足。 HashTable是所有的数据结构中插入，查找，删除操作综合起来最快的 2、能用二分法进行查找的是（顺序存储的有序线性表） 二分法只适用于有序表 有序线性链表不可以，因为链表的对结点的操作只能通过p-&gt;next的方式，对下标的操作不适合 3、通过（pstree -a）命令可以看到进程详细的树状结构图 pstree：以树状图显示进程，只显示进程的名字，且相同进程合并显示。 pstree -p：以树状图显示进程，还显示进程PID。 pstree 、pstree -p ：以树状图显示进程PID为的进程以及子孙进程，如果有-p参数则同时显示每个进程的PID。 pstree -a：以树状图显示进程，相同名称的进程不合并显示，并且会显示命令行参数，如果有-p参数则同时显示每个进程的PID。 4、家用小路由（路由转换）家用无线路由器 家用无线路由器是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器来完成。 工作原理:现假设网络A中一个用户A1要向C网络中的C3用户发送一个请求信号时 用户A1将目的用户C3的地址C3，连同数据信息发送给同一网络中的所有节点，当路由器A5端口侦听到这个地址后，分析得知所发目的节点不是本网段的，需要路由转发，就把数据帧接收下来。 路由器A5端口接收到用户A1的数据帧后，先从报头中取出目的用户C3的IP地址，并根据路由表计算出发往用户C3的最佳路径。因为从分析得知由路由器的A5端口直接发向路由器的C5端口应是信号传递的最佳途经。 路由器的C5端口再次取出目的用户C3的IP地址，找出C3的主机ID号，如果在网络中有交换机则可先发给交换机，再根据MAC地址表找出具体的网络节点位置;如果没有则根据其IP地址中的主机ID直接把数据帧发送给用户C3，这样一个完整的数据通信转发过程也完成了。 5、GET http://www.hack.com/hack.php?cmd=nc%2058.86 GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 特性 后退按钮/刷新：无害 书签：可收藏为书签 缓存：能被缓存 编码类型：application/x-www-form-urlencoded 历史：参数保留在浏览器历史中。 对数据长度的限制：当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 对数据类型的限制：只允许 ASCII 字符。安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET 可见性：数据在 URL 中对所有人都是可见的。 6、设有8个结点的无向图，该图至少8条边才能确保是一个连通图，最多28 对于无向图的话，至少需要n-1条边可以使得图是连通的； 对于有向图的话，至少需要n条边才可以使得图是连通的。 最大的不连通的情况，就是其中7个点完全连通而均不与最后一个点连通。 此时边的数目为7+6+5+4+3+2+1=28. 7、window，路由跟踪命令（netstat） linux路由跟踪指令traceroute windows路由跟踪命令tracert 8、Linux，测试DNS服务器是否能够正确解析域名的客户端命令（nslookup）nslookup可以指定查询的类型，可以查到DNS记录的生存时间，还可以指定使用哪个DNS服务器进行解释。在已安装TCP/IP协议的电脑上面均可以使用这个命令。主要用来诊断域名系统 (DNS) 基础结构的信息。 9、y=(x=1，++x，x+2)，y的值（4）括号中是逗号表达式，逗号表达式一直计算直至遇到分号，返回最后一个表达式的值 先计算x=1，即给x赋值 再计算++x；此时x=2； 后x+2，值为4，遇到分号，将这个值返回，赋给y，则y为4 10、输出1234567void fun(int *pa,int &amp;b,int c)&#123; *pa=5,b=5,c=5;&#125;int main&#123; int a=1,b=2,c=3; fun(&amp;a,b,c); printf(..,a,b,c);&#125; 招银网络笔试1、num between 10 and 20 X&gt;=20 AND X&lt;=30 2、OS特性（异步/中断/实时/多道）操作系统的四个特性 并发：同一段时间内多个程序执行(注意区别并行和并发，前者是同一时刻的多个事件，后者是同一时间段内的多个事件) 共享：系统中的资源可以被内存中多个并发执行的进线程共同使用 虚拟：通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个 异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进 3、数据库事务特性（一致性）数据库事务的四个特性及含义(ACID) 原子性(Atomicity)：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性(Correspondence)：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 隔离性(Isolation)：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。 持久性(Durability)：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 4、访问控制符实现哪种特性（封装/多态/继承） Java提供了4种访问控制符，主要用于控制其他类是否可以访问某一类中的属性或方法，从而实现数据封装。 访问控制符的权限(由大到小)为public、protected、default、 private。 private(私有)：当类中属性或方法被private修饰时，表示此成员或方法只能被自己类中的方法使用，而不能被外部类或对象直接使用。 default(默认)：具有包访问权限，如果类中属性或方法不使用public,protected,privete修饰符修饰时，则说明其具有包访问权限，具有包访问权限的属性或方法既可以被自己类中的方法使用也可以被同一包下的其他类使用，但不能被其他包中的类使用。 protected(保护)：具有子类访问权限。如果类中属性或方法被protected修饰符修饰，则此类中属性或方法可以被同一包下的类使用，也可以被不同包下的子类使用，但不能被不同包下的其他类使用。 public(公共)：具有公共访问权限。如果类中的属性或方法被public修饰，则此类中的属性或方法可以被任何类调用。 5、使用自底向下的动态规范算法求解矩阵链乘法的时间复杂度6、对于图G=(V,E)，基于DFS的拓扑排序算法的时间复杂度（O(V+E)）1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n,m,topo[100]; //topo数组用来储存最终形成的拓扑序列int G[100][100]; //储存有序对信息int c[100]; //储存每个节点是否被访问过的信息int t; bool dfs(int u)&#123; c[u]=-1; //该段代码的一个亮点，表示u节点正在被访问 for(int v=1;v&lt;=n;v++)&#123; if(G[u][v])&#123; if(c[v]==-1) //访问到正在访问的节点，即为存在有向环 return false; if(c[v]==0)&#123; if(!dfs(v)) //深度优先遍历 return false; &#125; &#125; &#125; c[u]=1; //返回时将该节点标记为已访问过 topo[--t]=u; //将此节点插入拓扑序列 return true;&#125;int main()&#123; int a,b; cin&gt;&gt;n&gt;&gt;m; t=n; memset(G,0,sizeof(G)); memset(c,0,sizeof(c)); for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;a&gt;&gt;b; G[a][b]=1; &#125; for(int u=1;u&lt;=n;u++)&#123; if(!c[u]) //如果该节点没有被访问过 if(!dfs(u))&#123; //dfs函数对图中节点进行深度优先遍历，返回值表示拓扑排序是否存在 cout&lt;&lt;&quot;存在有向环，失败退出&quot;&lt;&lt;endl; return 0; &#125; &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;topo[i]&lt;&lt;&quot; &quot;&lt;&lt;endl; return 0;&#125; 7、虚拟存储器与cache不同之处相同点 基于程序局部性原理，把程序中最近常用的部分驻留在高速存储器中。一旦这部分程序不常用，把它们送回到低速存储器中 换入、换出操作是由硬件或操作系统完成，对用户透明 力图使存储系统的性能接近高速存储器，而价格接近低速存储器。 不同点 cache是用硬件实现的，对操作系统透明；虚拟存储用操作系统与硬件结合的方式实现。 cache是一个物理存储器，而虚拟存储器是一个逻辑存储器，其物理结构建立在主存-辅存的结构基础上。 在虚拟存储中未命中的性能损失要大于cache系统中未命中的损失。 8、栈 对XML文件进行解析，识别与校验节点是否闭合是常用操作，为提升处理效率，用（栈）数据结构实现节点较好 栈的常见应用： 浏览器历史纪录 Android中的最近任务 Activity的启动模式 CPU中栈的实现 Word自动保存 解析计算式 解析xml/json 9、排它锁/计数 CountDownLatch是一个倒数计数的锁，当倒数到0时触发事件(开锁)，其他人可以进入了。在一些应用场合中，需要等待某个条件达到要求后才能做后面的事情；同时当线程都完成后也会触发事件，以便进行后面的操作。 CountDownLatch最重要的方法是countDown()和await()，前者主要是倒数一次，后者是等待倒数到0，如果没有到达0，就只有阻塞等待了。 一个CountDownLatch实例是不能重复使用的，也就是说它是一次性的，锁一经被打开就不能再关闭使用了，如果想重复使用，请考虑使用CyclicBarrier。 线程池需要显式shutdown。 CountDownLatch的使用方法 100米赛跑，10名选手已经准备就绪，只等裁判一声令下。当所有人都到达终点时，比赛结束。 123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class TestCountDownLatch&#123; public static void main(String[] args) throws InterruptedException&#123; //开始的倒数锁 final CountDownLatch begin=new CountDownLatch(1); //结束的倒数锁 final CountDownLatch end=new CountDownLatch(10); //10名选手 final ExecutorService exec=Executors.newFixedThreadPool(10); for(int index=0; index&lt;10;index++)&#123; final int NO=index + 1;//Cannot refer to a non-final variable NO inside an inner class defined in a different method Runnable run=new Runnable()&#123; public void run()&#123; try&#123; begin.await();//一直阻塞 Thread.sleep((long)(Math.random() * 10000)); System.out.println(&quot;No.&quot; + NO + &quot; arrived&quot;); &#125;catch(InterruptedException e)&#123; &#125;finally&#123; end.countDown(); &#125; &#125; &#125;; exec.submit(run); &#125; System.out.println(&quot;Game Start&quot;); begin.countDown(); end.await(); System.out.println(&quot;Game Over&quot;); exec.shutdown(); &#125; &#125; 10、适配器模式/装饰者模式 装饰器与适配器都有一个别名叫做 包装模式(Wrapper)，它们看似都是起到包装一个类或对象的作用，但是使用它们的目的很不一一样。 适配器模式的意义是要将一个接口转变成另一个接口，它的目的是通过改变接口来达到重复使用的目的。 而装饰器模式不是要改变被装饰对象的接口，而是恰恰要保持原有的接口，但是增强原有对象的功能，或者改变原有对象的处理方式而提升性能。 11、合并排序算法在对8个数字进行排序，递归树的层数为（3） 计算机科学里的lgn就是数学上的log2(n) 假设树的高度为h 第一层：cn(即cn/1)，所以该层有1个数 第二层：cn/2，所以该层有2个数 …… 最后一层：c(即cn/n)，所以该层有n个数，2^h=n，h=lgn=lg8=3 12、（指针索引）不属于关系型数据库的索引类型索引类型分类： 主索引：主索引是一种只能在数据库表中建立不能在自由表中建立的索引。在指定的字段或表达式中，主索 引的关键字绝对不允许有重复值。 候选索引：和主索引类似，它的值也 不允许在指定的字段或表达式中重复。一个表中可以有多个 候选索引。 唯一索引：唯一索引允许关键字取重复的值。当有重复值 出现时，索引文件只保存重复值的第1次出现。提供唯一索引主要是为了兼容早期的 版本。 普通索引：普通索引允许关键字段有相同值。在一对 多关系的多方，可以使用普通索引 13、子网问题 与子网掩码为255.255.255.224的IPV4地址10.11.13.70在同一子网的主机IPV4地址是10.110.13.64/63/94/95 子网掩码为255.255.255.224，每个子网地址为32个10.110.13.010.110.13.3210.110.13.6410.110.13.9610.110.13.12810.110.13.16010.110.13.19210.110.13.224可划分8个子网，10.110.13.70属于10.110.13.96/27子网，主机地址从10.110.12.65到10.110.12.94，广播地址10.110.12.95 14、UDP（有拥塞控制机制/不提供数组分组和排序）UDP的主要特点 UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。 UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。 UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。 UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低 UDP支持一对一、一对多、多对一和多对多的交互通信。 UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。 15、（封装）不可以用来实现多态封装：隐藏对象的属性和实现细节，仅对外公开访问方法，控制在程序中属性的读和写的访问级别。 16、检查待分派用户是在指定的用户组才能分配（职责链设计模式）职责链模式（Chain of Responsibility）：将对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。职责链可简化对象的相互连接，它们仅需保持一个指向后继者的引用，而不需要保持所有候选者的引用，链中对象不用知道链的结构，接受者和发送者都没有对方的明确信息。可以通过在运行时刻动态的增加或修改链来动态的改变处理一个请求的职责；不能保证请求一定被接受，一个请求也可能因链没有被正确配置而得不到处理。 17、over（partition by name order by num） OVER(PARTITION BY… ORDER BY…)把一组数据按照制定的字段进行分割成各种组，然后组内按照某个字段排序。 常用的分析函数: row_number() over(partition by … order by …) rank() over(partition by … order by …) dense_rank() over(partition by … order by …) count() over(partition by … order by …) max() over(partition by … order by …) min() over(partition by … order by …) sum() over(partition by … order by …) avg() over(partition by … order by …) first_value() over(partition by … order by …) last_value() over(partition by … order by …) lag() over(partition by … order by …) lead() over(partition by … order by …) 18、72个节点，完全二叉树，则（36）个是非叶子节点求完全二叉树叶子节点数 如果总结点数为偶数，则叶子节点数为：总结点数 / 2 如果总结点数为奇数，则叶子节点数为：(总结点数+1) / 2 19、查找 (4,11,23,33,41,50,53,64,72,78,80,115,147)，查找80，需比较次数（4） 20、计算一天可以获得的最大收益输入： 5 2 4 6 8 10输出：8]]></content>
      <categories>
        <category>笔经面经</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试汇总帖-1]]></title>
    <url>%2F2018%2F10%2F02%2F%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93%E5%B8%96-1%2F</url>
    <content type="text"><![CDATA[新浪笔试1、172.58.66.30这个主机IP地址对应的另一种表示形式AC3A421E 2、PHP连接MySQL服务器时，采用“长连接”比“短连接”有什么优势概念解释：长连接：相对于短连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。mysql的长连接如果长期闲置，mysql会8小时后（默认时间）主动断开该连接。短连接：指通讯双方有数据交互时，就建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。 连接的区别：1、短连接：客户端连接–创建socket认证连接–维护连接–数据传输–关闭连接2、长连接客户端连接–创建socket认证连接–维护连接–数据传输–维护连接–数据传输–…..–关闭连接 个人总结：长连接主要用于在少数客户端与服务端的频繁通信，因为这时候如果用短连接频繁通信常会发生Socket出错，并且频繁创建Socket连接也是对资源的浪费。但是对于服务端来说，长连接也会耗费一定的资源，需要专门的线程（unix下可以用进程管理）来负责维护连接状态。 长连接和短连接的选择要视情况而定。1、在频繁的与数据库服务通信，并且又非高并发的情况下，使用长连接更合适；2、太多持久连接，大部分是sleep状态的，或者系统是高并发的，使用短连接更合适。 3、https中的ssl工作在哪一层？SSL（Secure Socket Layer安全套接层）以及其继承者TSL（Transport Layer Security 传输层安全）是为了网络通信安全而提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。会话层的功能和表示层的功能正好和SSL记录协议和握手协议的功能 4、inode inode(发音：eye-node)译成中文就是索引节点，它用来存放档案及目录的基本信息，包含时间、档名、使用者及群组等。 inode 是 UNIX 操作系统中的一种数据结构，其本质是结构体，它包含了与文件系统中各个文件相关的一些重要信息。在 UNIX 中创建文件系统时，同时将会创建大量的 inode 。通常，文件系统磁盘空间中大约百分之一空间分配给了 inode 表。 inode 表包含一份清单，其中列出了对应文件系统的所有inode编号。当用户搜索或者访问一个文件时，UNIX 系统通过 inode 表查找正确的 inode 编号。在找到 inode 编号之后，相关的命令才可以访问该 inode ，并对其进行适当的更改。 例如，使用 vi 来编辑一个文件。当您键入 vi 时，在 inode 表中找到 inode 编号之后，才允许您打开该 inode 。在 vi 的编辑会话期间，更改了该 inode 中的某些属性，当您完成操作并键入:wq时，将关闭并释放该inode。通过这种方式，如果两个用户试图对同一个文件进行编辑，inode已经在第一个编辑会话期间分配给了另一个用户 ID (UID)，因此第二个编辑任务就必须等待，直到该 inode 释放为止。 5、返回状态码500http请求返回500状态码，整体原因是：服务器内部错误。 6、TCP协议中滑动窗口作用TCP 滑动窗口（发送窗口和接收窗口）滑动窗口本质上是描述接受方（本地）的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来TCP的滑动窗口主要有两个作用，一是提供TCP的可靠性，二是提供TCP的流控特性。同时滑动窗口机制还体现了TCP面向字节流的设计思路。 7、分屏显示分屏显示：more查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按下空格键可以显示下一页，按下q键退出显示，按下h键可以获取帮助 。利用Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。输入了ls -alh /bin | more ，可以看到分屏显示bin目录下文件的内容 8、用于显示进程执行时的系统调用命令linux strace命令–跟踪系统调用strace常用来跟踪进程执行时的系统调用和所接收的信号 9、快速查找某区号对应省份，最节约内存空间的算法（暂无答案）10、http和https常用端口HTTP服务器，默认的端口号为80/tcp（木马Executor开放此端口）；HTTPS（securely transferring web pages）服务器，默认的端口号为443/tcp 443/udp； 11、tcpdump命令TcpDump可以将网络中传送的数据包完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。 12、在浏览器输入 https://www.weibo.com 后，到页面展示完毕中间，发生了什么 在浏览器里输入网址: 浏览器查找域名的IP地址 浏览器给web服务器发送一个HTTP请求 weibo服务的永久重定向响应 浏览器跟踪重定向地址 服务器“处理”请求 服务器发回一个HTML响应 浏览器开始显示HTML 浏览器发送获取嵌入在HTML中的对象 浏览器发送异步（AJAX）请求 设计一个哈希函数，使哈希退化为链表 唯品会笔试1、Integer Integer 类在对象中包装了一个基本类型 int 的值。 Integer 类型的对象包含一个 int 类型的字段。该类提供了多个方法，能在int类型和 3. String类型之间互相转换，还提供了处理 int 类型时非常有用的其他一些常量和方法。 2、终止一个前台进程可能用到的命令和操作（kill） -kill 无参数表示向进程输入关闭的指令 -^C 关闭当前（前台）进程 -^Z 暂停当前（前台）进程 -shutdown 关机 -halt 就是调用shutdown -h 3、Linux改变文件所有者的命令（chmod） 修改文件所属组群——chgrp 修改文件拥有者——chown 改变文件权限——chmod 4、Linux文件权限，第三段内容 第一位表示文件类型 -表示普通文件。d表示目录文件 第二、三、四位表示文件所有者的读，写，执行权限 第五、六、七位表示文件所在属组的读，写，执行权限 第八、九、十位表示文件的其它用户的读，写，执行权限 5、java.lang.OutOfMemoryError.PermGen.Space导致OutOfMemoryError异常的常见原因有以下几种： 内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 代码中存在死循环或循环产生过多重复的对象实体； 使用的第三方软件中的BUG； 启动参数内存值设定的过小； 6、weak reference当一个对象仅仅被weak reference指向, 而没有任何其他strong reference指向的时候, 如果GC运行, 那么这个对象就会被回收.weak reference的语法是: 1WeakReference&lt;Car&gt; weakCar = new WeakReference(Car)(car); 当要获得weak reference引用的object时, 首先需要判断它是否已经被回收: 1weakCar.get(); 如果此方法为空, 那么说明weakCar指向的对象已经被回收了. 7、run()和start()区别start()：该方法是在当前线程中启动一个新的线程，而新启动的线程会调用run()方法，同时该方 法不能重复调用；run() ：该方法和普通的方法一样，可以重复执行，不会创建新的线程。 8、Error的子类表示无法修复 RuntimeException表示这种异常是否出现经常不可预料，出现了的话，就中止处理。 Error 一般表示无法恢复的故障，也就是你再试一次依然会出错，比如 OutOfMemoryError，试多少次很大概率出错的。 Exception 则表示一般性的异常，而且这种异常是设计中早已考虑到很常见的错误，并且一定要求在设计中说明如果处理这种异常。 10、线程停止执行（stop()、yield()） Thread.yield()：暂停当前正在执行的线程对象，并执行其他线程。 Thread.sleep(long millis)：使当前线程暂停millis所指定的毫秒，转到执行其它线程。 Thread.stop()：错误的停止线程的方法！戛然而止，立马停止。 11、对称加密算法 DES算法 3DES算法 TDEA算法 Blowfish算法 RC5算法 IDEA算法。 12、Java可以同时用abstract和final声明、volatile关键字不保证对变量操作的原子性abstract抽象类，需要继承，而final定义的类不能继承，所以final 和 abstract 不能同时修饰一个类。 Java 内存模型将内存分为共享内存和本地内存。共享内存又称为堆内存，指的就是线程之间共享的内存，包含所有的实例域、静态域和数组元素。每个线程都有一个私有的，只对自己可见的内存，称之为本地内存。 共享内存中共享变量虽然由所有的线程共享，但是为了提高效率，线程并不直接使用这些变量，每个线程都会在自己的本地内存中存储一个共享内存的副本，使用这个副本参与运算。由于这个副本的参与，导致了线程之间对共享内存的读写存在可见性问题。 Java语言中关键字 volatile 被称作轻量级的 synchronized，与synchronized相比，volatile编码相对简单且运行的时的开销较少 为何使用volatile？（1）简易性：在某些需要同步的场景下使用volatile变量要比使用锁更加简单（2）性能：在某些情况下使用volatile同步机制的性能要优于锁（3）volatile操作不会像锁一样容易造成阻塞 volatile特性（1）volatile 变量具有 synchronized 的可见性特性，及如果一个字段被声明为volatile，java线程内存模型确保所有的线程看到这个变量的值是一致的（2）禁止进行指令重排序（3）不保证原子性 注：① 重排序：重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段② 原子性：不可中断的一个或一系列操作③ 可见性：锁提供了两种主要特性：互斥和可见性，互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。 volatile的实现原理如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，该Lock指令会使这个变量所在缓存行的数据回写到系统内存，根据缓存一致性协议，每个处理器都会通过嗅探在总线上传输的数据来检查自己缓存的值是否已过期，当处理器发现自己的缓存行对应的地址被修改，就会将当前处理器的缓存行设置成无效状态，在下次访问相同内存地址时，强制执行缓存行填充。 正确使用volatile的场景volatile 主要用来解决多线程环境中内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，就无法解决线程安全问题。 一个线程对 volatile 变量的写一定对之后对这个变量的读的线程可见。 13、文件a的访问权限为rw-r–r–,增加所有用户的执行权限和同组用户的写权限（命令）chmod a+x g+w exer1 14、AtomicLong/Synchronized并发编程线程安全 当多个线程访问某个类是，这个类始终能表现出正常的行为，那么这个类（对象或方法）就是线程安全的。 synchronized在任意个对象及方法上加锁，而加锁的这段代码称为互斥区或临界区。关键字synchronized取得的锁都是对象锁，而不是把一段代码当作锁，所以示例代码中的那个线程先执行synchronized关键字的方法，那个线程就持有该方法所属对象的锁（Lock）,两个对象，线程获得的就是两个不同的锁，他们互不影响。 volatile:使变量在多个线程可见。在java中每个线程都会有一块工作内存区，其中存放着所有线程共享的主内存的变量值的拷贝。当线程执行时，他会在自己的工作内存区中操作这些变量。为了存取一个共享的变量，一个线程通常先获取锁并清除它的内存工作区，把这些共享变量从所有的线程的共享内存区中正确的装入他自己所在的工作内存区中，当线程解锁时保证该工作内存区中的变量的值写回到共享内存中。一个线程可执行的操作有使用(use)、赋值(assign)、装载(load)、存储(store)、锁定(lock)、解锁(unlock)。主内存执行的操作有读(read)、写(write)、锁定(lock)、解锁(unlock)，每个操作都是原子性的。 volatile的作用强制线程到主内存(共享内存)里去读变量，而不去线程工作内存区里去读取，从而实现多个线程间的变量可见。也就是满足线程安全的可见性。volatile关键字虽然拥有多个线程之间的可见性，但是却不具备同步性（原子性），可以算是一个轻量级的synchronized,性能要比synchronized强很多，不会造成阻塞,但一般volatile用于只针对多个线程可见的变量操作，并不能代替synchronized的同步功能。volatile关键字值具有可见性，没有原子性。要实现原子性建议使用atomic类系列的对象，支持原子性操作（注意：atomic类只保证本身方法的原子性，并不能保证多次操作的原子性） 原子操作在多进程（线程）访问共享资源时，能够确保所有其他的进程（线程）都不在同一时间内访问相同的资源。原子操作（atomic operation）是不需要synchronized，这是Java多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。 15、堆和栈的区别Java程序在运行时都要开辟空间，任何软件在运行时都要在内存中开辟空间，Java虚拟机运行时也是要开辟空间的。JVM运行时在内存中开辟一片内存区域，启动时在自己的内存区域中进行更细致的划分，因为虚拟机中每一片内存处理的方式都不同，所以要单独进行管理。 JVM内存的划分 寄存器 本地方法区 方法区 栈内存 堆内存 栈内存栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。 堆内存存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。 堆与栈的区别 栈内存存储的是局部变量而堆内存存储的是实体； 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短； 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。 商汤1.for嵌套循环的时间复杂度 如果内外循环之间的循环量之间没关系可将内外循环次数之积作为复杂度看待，若有关系则考虑内循环的基本操作的执行次数来分析复杂度 一次：n²/2+n/2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O（n²）二次：n*(n+1)(n+2)/6 &nbsp;&nbsp;&nbsp;O（n3） 2.int的自增/自减操作不是线程安全的？自增自减是包含了两个计算操作，不是线程安全的 3.图G是一个包含n个顶点和k个独立子树的森林，则图G边数？如果某棵树中有N个结点,K条边,则N = k + 1设森林中有m棵树,其结点数分别为n1,n2,n3,.,nm相应地,各棵树的边数分别为k1,k2,k3,…km显然：n1 = k1 + 1,n2 = k2 + 1,.,nm = km + 1&nbsp; (1)按照题设：n1 + n2 + n3 +.+ nm = N&nbsp; (2)k1 + k2 + k3 +.+ km = K&nbsp; (3)将(1) 代入(2) 得：(k1 + 1) + (k2 + 1) + (k3 + 1) + .+ (km + 1) = N即：k1 + k2 + k3 + …+ km + 1 + 1 +.+ 1 = N按照(3)：K+ m= N于是m = N - K 反之，边数=结点-树=n-k 4.在网段200.10.11.144/27中，可分配地址中第四组八字节地址以十进制表示最大为多少A类 从1.0.0.0 到126.255.255.255B类 从128.0.0.0到191.255.255.255C类 从192.0.0.0到223.255.255.255其中127.x.x.x段地址空间是被保留的回环地址 IP地址包含网络地址+主机地址，即IP地址=网络地址+主机地址网络地址:如果是192的C段地址，那么，网络地址就是：192.168.1.0，地址掩码是：255.255.255.0。如果地址掩码是：255.255.0.0，那么网络地址就是：192.168.0.0。网络地址很大一部分是由地址掩码决定的。主机地址：IP地址是202.112.14.137，掩码是255.255.255.224 ，网络地址是202.112.14.128，子网号是128。主机地址是202.112.14.137 。 根据子网掩码可以分割网络号+主机号255.255.255.224 转二进制：11111111 11111111 11111111 11100000网络号有27位，主机号有5位网络地址：把IP地址转成二进制和子网掩码进行与运算11001010 01110000 00001110 1000100111001010 01110000 00001110 1000100111111111 11111111 11111111 11100000即：202.112.14.128 5.雄患病概率30%，雌患病概率10%，雄雌数量各一半，随机抽一只，发现无患病，是雄的概率为？7/16，直接10只雄10只雌 编程：输入一个整数数组a，和一个整数k，对于a中每一个元素，必须进行一次操作（加上k或者减去k），执行完后，整个数组最大和最小值之差最小，输出差值 巨人网络1.给定一个奇数，比如n=3，生成1到n平方的数，填入九宫格，使行横竖斜的和都相等1234567891011121314151617181920212223242526272829//n=3（c++）void nineGongGe( int n)&#123; int **a ; a= new int*[n]; for(int i = 0; i&lt; n;++i) a[i] = new int[n]; for(int i = 0; i&lt; n; ++i) for(int j = 0; j &lt; n; ++j) a[i][j] = 0; int x = 0, y = n/2; a[x][y] = 1; for(int i = 2; i&lt;= n*n; ++i)&#123; int xNew = x-1; int yNew = y+1; if(yNew &gt; n-1) yNew = 0; if(xNew &lt; 0) xNew = n-1; if(a[xNew][yNew] != 0)&#123; xNew = x+1; yNew = y; &#125; a[xNew][yNew] = i; x = xNew; y = yNew; &#125; for(int i = 0; i&lt; n; ++i)&#123; for(int j = 0; j &lt; n; ++j)&#123; cout&lt;&lt; a[i][j]&lt;&lt;&quot;\t&quot;; &#125; cout&lt;&lt;endl; &#125;&#125; 2.画出QPS和响应时间随着服务请求数不断增多的趋势图（略）QPS（TPS）= 并发数/平均响应时间 3.400和500错误码的区别1xx（临时响应）: 表示临时响应并需要请求者继续执行操作的状态代码。 100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功）: 表示成功处理了请求的状态代码。 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向）: 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx（请求错误）: 这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5xx（服务器错误）: 这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错. 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求功能。 如服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 4.持续集成是什么，普遍用什么工具持续集成，Continuous Integration, CI， 一种软件项目管理方法，依据资产库（源码，类库等）的变更自动完成编译、测试、部署和反馈。 一种软件开发实践，它倡导团队开发成员协同工作，有需要的时候就对代码进行集成，不必要等到软件开发后期才开始集成。通常，每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件 用java实现的持续集成的开源工具有：CruiseControl http://cruisecontrol.sf.net/Continuum http://maven.apache.org/continuum/Anthill http://www.anthillpro.com/e/giant-ci-matrix-osLuntBuild http://luntbuild.javaforge.com/Gump http://jakarta.apache.org/gump/ 5.unitest原理python功能自动化测试框架首先是要写好TestCase，然后由TestLoader加载TestCase到TestSuite，然后由TextTestRunner来运行TestSuite，运行的结果保存在TextTestResult中，整个过程集成在unittest.main模块中。 测试的基础就是TestCase，也就是用例的编写，用例的开始需要对测试做前期准备，用例结束则需清理环境，保证下一个用例在合适的环境下进行。 类TestSequenceFunctions包含继承自unittest.TestCase，重写了setUp()方法和tearDown（）方法，打印语句以表明测试的开始和结束。TestSequenceFunctions还定义了三个以’test’开头的方法，对每一个以test开头的方法，都为其构建了一个TestCase对象。方法都放在TestSequenceFunctions类中，是因为这几个测试用例的fixture是相同的（即setUp()和tearDown()），如果每一个测试用例单独写成一个TestCase的话，会有很多的冗余代码。 每一个方法里面可以写入断言语句，如assertEqual，assertTrue，assertRaises等，对测试的结果进行判断，并在测试完成后输出。 6.边层值分析黑盒测试、白盒测试 7.78+78=123，多少进制 78+78=123为7x+8+7x+8=x^2+2x+3，得x=13 8+8=16，而123的尾数是3，16-13=3.故是 13进制 百度笔试1、哪个隧道方案用于IPV4到IPV6迁移 Ipv4到Ipv6的过渡的主要方法有双栈策略和隧道策略。 双栈策略：指在网元中同时具有 IPv4和IPv6两个协议栈，它既可以接收、处理、收发IPv4的分组，也可以接收、处理、收发IPv6的分组。对于主机（终端）来讲，“双栈”是指其 可以根据需要来对业务产生的数据进行IPv4封装或者IPv6封装。对于路由器来讲，“双栈”是指在一个路由器设备中维护IPv6和IPv4两套路由协议栈，使得路由器既能与IPv4主机也能与IPv6主机通信，分别支持独立的IPv6和IPv4路由协议。 隧道策略:IPv4/v6综合组网技术中经常使用到的一种机制，所谓“隧道”，简单地讲就是利用一种协议来传输另一种协议的数据技术，隧道包括隧道入口和隧道出口 （隧道终点），这些隧道端点通常都是双栈节点。在隧道入口以一种协议的形式来对另外一种协议数据进行封装并发送。在隧道出口对接收到的协议数据解封装， 并做相应的处理。在隧道的入口通常要维护一些与隧道相关的信息，如记录隧道MTU等参数。 2、三个节点A、B、C可以形成多少棵“有序树”？（12） 无序树：9棵 有序树：12棵 二叉树：30棵 3、测试类型 数据和数据库完整性测试 白盒测试：静态白盒测试、动态白盒测试 功能测试 UI测试 性能测试：负载测试，强度测试，数据库容量测试，基准测试以及竞争测试 安全性和访问控制测试：应用程序级别的安全性、系统级别的安全性 配置测试：浏览器兼容性、操作系统兼容性、硬件兼容性 安装测试 多语种测试 文字测试 分辨率测试 发布测试 文档审核测试 4、在给定命令中的哪个命令用于将文件“infile”的字数统计发送到文件“newfile” linux中的wc命令主要功能是统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。 语法：wc [选项] 文件名… 说明：该命令统计给定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所有指定文件的总统计数。字是由空格字符区分开的最大字符串。 该命令各选项含义如下： c 统计字节数。 l 统计行数。 w 统计字数。 5、交换机如何决定转发目标为单播MAC地址的帧交换机学习和转发的简单过程如下：当PC1发送数据到本子网的pc2，数据发送至交换机接口，如果交换机MAC表里没有PC1的表项，则保存帧里的MAC源地址并与PC1映射。然后交换机查看MAC表有没有PC2的MAC地址，如果有则转发数据，如果没有则发送一个ARP广播要求PC2发送MAC地址响应，然后将其存储并转发数据 6、将输出打印到一个文件并同时查看输出的内容在屏幕上输出信息，又想保留下输出的信息到文件中，可以使用tee命令。 tee：从标准输入中读取并同时写入到标准输出和指定的文件上 语法:tee [Options]…… [File]…… 描述： 将标准输入复制到每个指定的文件File中，也输出到标准输出上 选项： -a,–append:不覆盖，而是追加输出到指定的文件中 -i,–ignore-interrupts:忽略中断信息 –help:显示帮助信息并退出 –version:显示版本信息并退出 若指定的输出文件为’-‘，则再次输出到标准输出上 实例： #将标准输入中输入的内容同时输出到Example.txt和标准输出上1tee Example.txt ＃追加模式输出到Example.txt1tee -a Example.txt #将cat的输出输入到标准输出和e2.txt文件中 1cat Example.txt |tee e2.txt 7、chmod、递归 linux 递归修改所有权限 命令 ： chmod -R 755 tools_command/解释 ： -R 为递归遍历tools_command文件夹, chmod 755修改权限 编程输入exprsn=x-(p+q)+(y-a)输出x-p-q+y-a 360笔试1、Round(11.56,0)的值C语言中round函数的作用:四舍五入到最邻近的整数。答案：12 2、JVM 对于JVM内存配置参数：-Xmx10240m -Xms10240m -Xmn5120m -xxSurvivorRatio=3,其最小内存值和Survivor区总大小分别是(5120/10240,2048/1024m) JVM的结构问题JVM分两块：PermanentSapce和HeapSpace，HeapSpace = 【old + new{=Eden，from，to}】PermantSpace主要负责存放加载Class类级别的class本身，method，field等反射对象，一般不用配置，JVM的Heap区可以通过-X参数来设定。 当一个URL被访问时，内存申请如下： JVM会试图为相关Java对象在Eden中初始化一块内存区域； 当Eden空间足够时，内存申请结束。否则到下一步； JVM试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）, 释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区； Survivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区； 当OLD区空间不够时，JVM会在OLD区进行完全的垃圾收集（0级； 完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误。 JVM参数介绍和调优建议 Xms/Xmx：定义NEW+OLD段的总尺寸，ms为JVM启动时NEW+OLD的内存大小；mx为最大可占用的NEW+OLD内存小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销； NewSize/MaxNewSize：定义单独NEW段的尺寸，NewSize为JVM启动时NEW的内存大小；MaxNewSize为最大可占用的NEW的内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销； OLD区初始大小=（Xms-NewSize），OLD区最大可占用大小=（Xmx-MaxNewSize）； PermSize/MaxPermSize：定义Perm段的尺寸，PermSize为JVM启动时Perm的内存大小；MaxPermSize为最大可占用的Perm内存大小。在用户生产环境上一般将这两个值设为相同，以减少运行期间系统在内存申请上所花的开销； SurvivorRatio：设置Survivor空间和Eden空间的比例。以上各值的最大值与初始值的差值为各区段的virtual区，这部分保留的内存不会被其他进程使用。 内存溢出的可能性 OLD段溢出这种内存溢出是最常见的情况之一，产生的原因可能是： 设置的内存参数过小(Xms/Xmx, NewSize/MaxNewSize) 程序问题单个程序持续进行消耗内存的处理，如循环几千次的字符串处理，对字符串处理应建议使用StringBuffer。此时不会报内存溢出错，却会使系统持续垃圾收集，无法处理其它请求，相关问题程序可通过Thread Dump获取（见系统问题诊断一章）单个程序所申请内存过大，有的程序会申请几十乃至几百兆内存，此时JVM也会因无法申请到资源而出现内存溢出，对此首先要找到相关功能，然后交予程序员修改，要找到相关程序，必须在Apache日志中寻找。当Java对象使用完毕后，其所引用的对象却没有销毁，使得JVM认为他还是活跃的对象而不进行回收，这样累计占用了大量内存而无法释放。由于目前市面上还没有对系统影响小的内存分析工具，故此时只能和程序员一起定位。 Perm段溢出 通常由于Perm段装载了大量的Servlet类而导致溢出，目前的解决办法： 1) 将PermSize扩大，一般256M能够满足要求 2) 若别无选择，则只能将servlet的路径加到CLASSPATH中，但一般不建议这么处理 C Heap溢出系统对C Heap没有限制，故C Heap发生问题时，Java进程所占内存会持续增长，直到占用所有可用系统内存 jvm参数设置1: heap sizea: -Xmx指定 jvm 的最大 heap 大小 , 如 :-Xmx=2g b: -Xms指定 jvm 的最小 heap 大小 , 如 :-Xms=2g ， 高并发应用， 建议和-Xmx一样， 防止因为内存收缩／突然增大带来的性能影响。 c: -Xmn指定 jvm 中 New Generation 的大小 , 如 :-Xmn256m。 这个参数很影响性能， 如果你的程序需要比较多的临时内存， 建议设置到512M， 如果用的少， 尽量降低这个数值， 一般来说128／256足以使用了。d: -XX:PermSize=指定 jvm 中 Perm Generation 的最小值 , 如 :-XX:PermSize=32m。 这个参数需要看你的实际情况，。 可以通过jmap 命令看看到底需要多少。 e: -XX:MaxPermSize=指定 Perm Generation 的最大值 , 如 :-XX:MaxPermSize=64m f: -Xss指定线程桟大小 , 如 :-Xss128k， 一般来说，webx框架下的应用需要256K。 如果你的程序有大规模的递归行为，请考虑设置到512K／1M。 这个需要全面的测试才能知道。 不过，256K已经很大了。 这个参数对性能的影响比较大的。 g: -XX:NewRatio=指定 jvm 中 Old Generation heap size 与 New Generation 的比例 , 在使用 CMS GC 的情况下此参数失效 , 如 :-XX:NewRatio=2 h: -XX:SurvivorRatio=指 定 New Generation 中 Eden Space 与一个 Survivor Space 的 heap size 比例 ,-XX:SurvivorRatio=8, 那么在总共 New Generation 为 10m 的情况下 ,Eden Space 为 8m i: -XX:MinHeapFreeRatio=指定 jvm heap 在使用率小于 n 的情况下 ,heap 进行收缩 ,Xmx==Xms 的情况下无效 , 如 :-XX:MinHeapFreeRatio=30 j: -XX:MaxHeapFreeRatio=指定 jvm heap 在使用率大于 n 的情况下 ,heap 进行扩张 ,Xmx==Xms 的情况下无效 , 如 :-XX:MaxHeapFreeRatio=70 k: -XX:LargePageSizeInBytes=指定 Java heap 的分页页面大小 , 如 :-XX:LargePageSizeInBytes=128m 2: garbage collectora: -XX:+UseParallelGC指 定在 New Generation 使用 parallel collector, 并行收集 , 暂停 app threads, 同时启动多个垃圾回收 thread, 不能和 CMS gc 一起使用 . 系统吨吐量优先 , 但是会有较长长时间的 app pause, 后台系统任务可以使用此 gc b: -XX:ParallelGCThreads=指定 parallel collection 时启动的 thread 个数 , 默认是物理 processor 的个数 , c: -XX:+UseParallelOldGC指定在 Old Generation 使用 parallel collector d: -XX:+UseParNewGC指定在 New Generation 使用 parallel collector, 是 UseParallelGC 的 gc 的升级版本 , 有更好的性能或者优点 , 可以和 CMS gc 一起使用 e: -XX:+CMSParallelRemarkEnabled在使用 UseParNewGC 的情况下 , 尽量减少 mark 的时间 f: -XX:+UseConcMarkSweepGC指 定在 Old Generation 使用 concurrent cmark sweep gc,gc thread 和 app thread 并行 ( 在 init-mark 和 remark 时 pause app thread). app pause 时间较短 , 适合交互性强的系统 , 如 web server g: -XX:+UseCMSCompactAtFullCollection在使用 concurrent gc 的情况下 , 防止 memory fragmention, 对 live object 进行整理 , 使 memory 碎片减少 h: -XX:CMSInitiatingOccupancyFraction=指示在 old generation 在使用了 n% 的比例后 , 启动 concurrent collector, 默认值是 68, 如 :-XX:CMSInitiatingOccupancyFraction=70 i: -XX:+UseCMSInitiatingOccupancyOnly指示只有在 old generation 在使用了初始化的比例后 concurrent collector 启动收集 3:othersa: -XX:MaxTenuringThreshold=指 定一个 object 在经历了 n 次 young gc 后转移到 old generation 区 , 在 linux64 的 java6 下默认值是 15, 此参数对于 throughput collector 无效 , 如 :-XX:MaxTenuringThreshold=31 b: -XX:+DisableExplicitGC禁止 java 程序中的 full gc, 如 System.gc() 的调用. 最好加上么， 防止程序在代码里误用了。对性能造成冲击。 c: -XX:+UseFastAccessorMethodsget,set 方法转成本地代码 d: -XX:+PrintGCDetails打应垃圾收集的情况如 :[GC 15610.466: [ParNew: 229689K-&gt;20221K(235968K), 0.0194460 secs] 1159829K-&gt;953935K(2070976K), 0.0196420 secs] e: -XX:+PrintGCTimeStamps打应垃圾收集的时间情况 , 如 :[Times: user=0.09 sys=0.00, real=0.02 secs] f: -XX:+PrintGCApplicationStoppedTime打应垃圾收集时 , 系统的停顿时间 , 如 :Total time for which application threads were stopped: 0.0225920 seconds 3、GC收集标准：null无调用/对象重新分配内存空间在Java语言中，判断一块内存空间是否符合垃圾收集器收集的标准只有两个： 给对象赋予了空值null，以下再没有调用过。 给对象赋予了新值，既重新分配了内存空间。 4、运行时常量池（大小受栈区/方法区影响）1. 常量池（Constant Pool）： 常量池数据编译器被确定，是class文件中的一部分，存储了类，方法，接口等中的常量，当然也包括字符串常量。 可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目资源关联最多的数据类型 常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference）。 字面量：文本字符串、声明为final的常量值等； 符号引用：类和接口的完全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符 2. 字符串池/字符串常量池（String Pool/String Constant Pool）常量池中的一部分，存储了编译器产生的字符串类型数据 3. 运行时常量池（Runtime Constant Pool）: 方法区的一部分，所有线程共享。虚拟机加载class文件后把常量池中的数据存放到运行时常量池中在JDK1.6之前字符串常量池是存在于方法区之中，在JDK1.7和以上字符串常量池存在了堆之中。在JDK 7中，在Java堆的永久生成中不再分配interned字符串，而是在Java堆的主要部分(称为young和old generation)中分配，以及应用程序创建的其他对象。此更改将导致更多的数据驻留在主Java堆中，而在永久生成中数据更少，因此可能需要调整堆大小。由于这种变化，大多数应用程序在堆使用上只会看到相对较小的差异，但是更大的应用程序加载了许多类，或者大量使用了string.intern()方法将看到更显著的差异。 运行时常量是相对于常量来说的，它具备一个重要特征是：动态性。当然，值相同的动态常量与我们通常说的常量只是来源不同，但是都是储存在池内同一块内存区域。Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中。这里所说的常量包括：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将String放入常量池） 5、使用一个类的子类的实例，又不与该类的子类发生直接联系（中介者模式）中介者模式 如果一组对象之间的通信方式比较复杂，导致相互依赖、结构混乱，可以采用中介者模式，把这些 对象相互的交互管理起来，各个对象都只需要和中介者交互，从而使得各个对象松散耦合，结构也更清晰易懂。 如果一个对象引用很多的对象，并直接跟这些对象交互，导致难以复用改对象，可以采用中介者模式，把这个对象跟其他对象的交互封装到中介者对象里面，这个对象值需要和中介者对象交互就可以了。 6、每天开机在/misc目录下创建一个当天日期的文件夹（echo）1234@echo offset now=%DATE:~0,4%%DATE:~5,2%%DATE:~8,2%md \misc\%now%cd.&gt;\misc:\%now%\%now%.txt 7、模板模式/策略模式 模板方法模式:定义一个算法的骨架，将骨架中的特定步骤延迟到子类中。模板方法模式使得子类可以不改变算法的结构即可重新定义该算法的某些特定步骤 策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换，而不影响客户端的使用。 8、获取JVM的内存映像（jinfo/jmp/jhat/jstat）JDK的命令行工具——Java内存映像工具（jmap） 9、不能用来处理线程安全(transient/volatile/Lock/synchronized)synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。 10、volatile功能（持久性/可见性/有序性/原子性） volatile让变量每次在使用的时候，都从主存中取。而不是从各个线程的“工作内存”。 volatile具有synchronized关键字的“可见性”，但是没有synchronized关键字的“并发正确性”，也就是说不保证线程执行的有序性。 volatile变量对于每次使用，线程都能得到当前volatile变量的最新值。但是volatile变量并不保证并发的正确性。 11、哪种方式实现的单例是线程安全的（饿汉式/枚举/双检索模式/静态内部类）饿汉式单例是指在方法调用前，实例就已经创建好了12345678910111213141516171819202122232425//单例的饿汉式实现public class MySingleton &#123; private static MySingleton instance = new MySingleton(); private MySingleton()&#123;&#125; public static MySingleton getInstance() &#123; return instance; &#125; //饿汉式在多线程下的执行情况 public class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(MySingleton.getInstance().hashCode()); &#125; public static void main(String[] args) &#123; MyThread[] mts = new MyThread[10]; for(int i = 0 ; i &lt; mts.length ; i++)&#123; mts[i] = new MyThread(); &#125; for (int j = 0; j &lt; mts.length; j++) &#123; mts[j].start(); &#125; &#125; &#125;&#125; 懒汉式单例是指在方法调用获取实例时才创建实例 懒汉式单例（错误的单例）存在线程安全问题。要保证线程安全,得使用同步锁机制 Double Check Locking 双检查锁机制为了达到线程安全，又能提高代码执行效率12345678910111213141516171819202122//实现代码public class MySingleton &#123; //使用volatile关键字保其可见性 volatile private static MySingleton instance = null; private MySingleton()&#123;&#125; public static MySingleton getInstance() &#123; try &#123; if(instance != null)&#123;//懒汉式 &#125;else&#123; //创建实例之前可能会有一些准备性的耗时工作 Thread.sleep(300); synchronized (MySingleton.class) &#123; if(instance == null)&#123;//二次检查 instance = new MySingleton(); &#125; &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return instance;&#125; 使用静态内置类实现单例模式解决了多线程并发下的线程安全问题12345678910public class MySingleton &#123; //内部类 private static class MySingletonHandler&#123; private static MySingleton instance = new MySingleton(); &#125; private MySingleton()&#123;&#125; public static MySingleton getInstance() &#123; return MySingletonHandler.instance; &#125;&#125; 枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用123456789101112131415161718public enum EnumFactory&#123; singletonFactory; private MySingleton instance; private EnumFactory()&#123;//枚举类的构造方法在类加载是被实例化 instance = new MySingleton(); &#125; public MySingleton getInstance()&#123; return instance; &#125; &#125;class MySingleton&#123;//需要获实现单例的类，比如数据库连接Connection public MySingleton()&#123;&#125;&#125; 12、Prototype模式的优点概念用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 优点 使用原型模型创建一个对象比直接new一个对象更有效率，因为它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。 隐藏了制造新实例的复杂性，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。 13、对n个元素用插入法建堆的时间复杂度（Ologn）分析一下插入建堆的时间复杂度。我们先看最理想的情况，假设每次插入的元素都是严格递减的，那么每个元素只需要和它的父结点比较一次。那么其最优情况就是n。对于最坏的情况下，每次新增加一个元素都需要调整到它的根结点。而这个长度为lgn。 12345678910111213141516public void heapIncreaseKey(int i, int key) throws Exception &#123; if(key &lt; a[i]) throw new Exception(&quot;new key is small than current key&quot;); a[i] = key; while(i &gt; 0 &amp;&amp; a[parent(i)] &lt; a[i]) &#123; swap(i, parent(i)); i = parent(i); &#125; &#125; public void maxHeapInsert(int key) throws Exception &#123; heapSize++; a[heapSize - 1] = Integer.MIN_VALUE; heapIncreaseKey(heapSize - 1, key); &#125; 因此，插入建堆的时间复杂度为nlgn。 14、大根堆 最大堆是堆的两种形式之一。 根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆（大顶堆）。 大根堆要求根节点的关键字既大于或等于左子树的关键字值，又大于或等于右子树的关键字值。 15、最坏情况的时间复杂度为n^2的排序算法（插入排序）冒泡排序1234567891011121314151617public void bubblesort(int a[])&#123; int len=a.length; int i=len-1; int last=0; while(i&gt;0)&#123; last=0; for(int j=0;j&lt;i;j++)&#123; if(a[j]&gt;a[j+1])&#123; int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; last=j; &#125; &#125; i=last; &#125;&#125; 选择排序123456789101112131415public int[] SelectionSort(int a[])&#123; int len=a.length; for(int i=0;i&lt;len-1;i++)&#123; int min=i; for(int j=i+1;j&lt;len;j++)&#123; if(a[j]&lt;a[min])&#123; min=j; &#125; &#125; int temp=a[i]; a[i]=a[min]; a[min]=temp; &#125; return a;&#125; 插入排序1234567891011121314public int [] InsertSort(int []a)&#123; int len=a.length; for(int i=0;i&lt;len-1;i++)&#123; int m=a[i+1]; for(int j=i+1;j&gt;0;j--)&#123; if(a[j-1]&lt;m)&#123; int temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; &#125; &#125; &#125; return a;&#125; 游族网络1、面向字符的输出流 CharArrayWriter 写到字符数组的输出流 BufferedWriter 缓冲输出字符流 PipedWriter 输出管道 OutputStreamWriter 转换字符到字节的输出流 FilterWriter 过滤输出流 StringWriter 输出到字符串的输出流 PrintWriter 包含 print()和 println()的输出流 FileWriter 输出到文件的输出流 2、多态的表现形式 方法重载: 通常是指在同一个类中，相同的方法名对应着不同的方法实现，这些方法名相同的方法其区别在于他们需要的参数不同。即采用不同的方法形参表，区分重载方法要求形参在数据类型、个数和顺序的不同。 方法重写: 方法重写主要用于父类和子类间。子类重写父类的方法，只是对应的方法实现不同，其方法名和参数都相同。 抽象类: 在java语言中，一个类中的方法只给出了标准，而没有给出具体的实现方法，这样的类就是抽象类。例如父类就是抽象类，它不会被实例化的类。 接口: 在多态机制中，接口比抽象类使用起来更加方便。而抽象类组成的集合就是接口。 3、clone()不是object()类的方法Object类有12个成员方法，按照用途可以分为以下几种 构造函数 hashCode和equale函数用来判断对象是否相同, wait(),wait(long),wait(long,int),notify(),notifyAll() toString()和getClass, clone() finalize()用于在垃圾回收 4、set是排序的。（linkedhashset） HashSet，增、删、改、查的性能比较：添加元素速度较快，原因是无序。 TreeSet，有序的Set，但并非通过下标实现，而是添加/删除元素时，自动排序。 LinkedHashSet继承自HashSet，源码更少、更简单，唯一的区别是LinkedHashSet内部使用的是LinkHashMap。这样做的意义或者好处就是LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。 5、Iterator 不包括在JDK Collection FrameworkCollection FrameWork 如下： 1234567891011Collection ├List ├LinkedList ├ArrayList └Vector └Stack └SetMap ├Hashtable ├HashMap └WeakHashMap Collection 是最基本的集合接口，一个Collection 代表一组Object，即Collection 的元素（Elements）； Map 提供key 到value 的映射。 6、GET和POST的区别POST和GET都是向服务器提交数据，并且都会从服务器获取数据。 区别： 传送方式：get通过地址栏传输，post通过报文传输。 传送长度：get参数有长度限制（受限于url长度），而post无限制 GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 建议： get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式； 在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；一般情况下，登录的时候都是用的POST传输，涉及到密码传输 其他： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 7、Session和Cookie的区别Cookie 定义：当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择，都纪录下来。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie来辨认使用者，以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。 cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式 cookie机制正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。 具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 session机制session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。实际上这种技术可以简单的用对action应用URL重写来代替。 cookie 和session 的区别： cookie数据存放在客户的浏览器上，session数据放在服务器上。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 将登陆信息等重要信息存放为SESSION,其他信息如果需要保留，可以放在COOKIE中 8、synchronized和locked的区别 lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现； synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。） lock等待锁过程中可以用interrupt来终端等待，而synchronized只能等待锁的释放，不能响应中断； lock可以通过trylock来知道有没有获取锁，而synchronized不能； Lock可以提高多个线程进行读操作的效率。(通过readwritelock实现读写分离) 9、spring的bean配置有哪几种方式 工厂方式，事先把我们要获获取的对象存放到工厂里，当我们要用的时候我们就直接通过加载工厂去获取我们想要的对象 通过编写xml方式直接配置bean(在spring.xml的配置文件中编写) 通过工厂方式配置bean 通过静态工厂方式配置bean静态工厂，将我们的对象直接放在一个静态区里面，想用的时候我们可以直接调用就行 通过实例工厂方式配置bean实例工厂，需要先实例化工厂,在获取工厂里面的对象的 通过实现factoryBean方法来配置bean 通过注解方式 10、删除表数据，保留表结构 drop (删除表)：删除内容和定义，释放空间。简单来说就是把整个表去掉. drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。 truncate (清空表中的数据)：删除内容、释放空间但不删除定义(保留表的数据结构)。与drop不同的是,只是清空表数据而已。 11、索引字段值不唯一，选择索引类型(普通索引)索引类型分类 主索引：主索引是一种只能在数据库表中建立不能在自由表中建立的索引。在指定的字段或表达式中，主索 引的关键字绝对不允许有重复值。 候选索引：和主索引类似，它的值也 不允许在指定的字段或表达式中重复。一个表中可以有多个 候选索引。 唯一索引：唯一索引允许关键字取重复的值。当有重复值 出现时，索引文件只保存重复值的第1次出现。提供唯一索引主要是为了兼容早期的 版本。 普通索引：普通索引允许关键字段有相同值。在一对 多关系的多方，可以使用普通索引 12、Mysql查询时，只有满足联接条件的记录才包含在查询结果，这种联接是（内连接）。 内链接：取两个表的交集，仅显示符合连接条件的记录； 左外连接：显示左表的全部记录及右表符合连接条件的记录； 右外连接：显示右表的全部记录及左表符合连接条件的记录。 爱奇艺笔试1、在Eclipse，查看当前类或者接口的继承关系，默认进入时，显示的是（当前类/接口继承或实现的超类） 选中接口名，按快捷键Ctrl + T 弹出Type Hierarchy窗口，在窗口中可以查看该接口的所有实现类以及相关的层级关系。 2、某磁盘格式化后每个扇面10个扇区 现有记录1~11存放于同一磁道，若要顺序处理这些记录（若磁盘转速为20m/s，每条记录的平均处理时间为4ms，则处理完10条记录的时间为204ms） 例题123456假定磁盘的旋转速度为每圈20ms,格式化时每个磁道被,分成10个扇区。现有10个逻辑记录存放在同一磁道上,其,排列顺序如下表所示。 扇区号 | 1| 20| 3| 4 | 54| 6| 7 | 8| 94 | 104 逻辑记录| A| B| Ce| D| E+ | Fe | Ge| He| | J一处理程序要顺序处理这些记录,每读出一个记录要花费4ms的时间进行处理,然后再顺序读下一个记录并进行处理,直到处理完这些记录,请回答:(1)顺序处理完这10个记录总花费了多少时间?(2)请给出一种记录优化分布方案,使处理程序能在最短的时间内处理完成这10个记录,并计算优化时间。 答案12345678910111. 顺序处理完这10个记录所费时间: 读一个记录的时间是20/10-2ms 每条记录处理时间为4ms.计算如下: A记录: 2+4-6ms B记录:因为6ms后已转到第4扇区,因此还要转过8个扇区方能到达第2扇区取B记录,所需时间为: 2x8+2+4-22ms,同样的, C..J记录和B记录访问一样,会有8个扇区的空转时间。 总的时间为: 6+22×9-204ms2. 要使处理程序在最短时间内处理完毕,则根据我们 上面的计算,把B记录安排在第扇区4上,把C记录存 放在扇区7上,.按照这个办法,可以得到记录的优 化分布如下分配: A B C DEF GI 1 4 7 10 3 69 这时每处理一个记录后刚好转入下一记录扇区, 所以处理时间总和为: 10× (2+4) =60ms 3、 6个圆盘的汉诺塔，总的移动次数（63） 汉诺塔第i个圆盘移动次数=第i-1个圆盘的次数乘2n个盘子移动的次数表达式为：count(n) = 2^n - 1 (n&gt;0) 利用递归，求解； 12345678910111213#include&lt;stdio.h&gt;int main()&#123; __int64 a[100]; int n,k,t; a[0]=1; for(int i=1;i&lt;=60;i++) a[i]=a[i-1]*2; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); printf(&quot;%I64d\n&quot;,a[n-k]); &#125;&#125; 4、二次探测法处理哈希碰撞的方法 线性探测若当前key与原来key产生相同的哈希地址，则当前key存在该地址之后没有存任何元素的地址中key1：hash(key)+0key2：hash(key)+1key3：hash(key)+2 二次探测若当前key与原来key产生相同的哈希地址，则当前key存在该地址后偏移量为（1,2,3…）的二次方地址处key1：hash(key)+0key2：hash(key)+1^2key3：hash(key)+2^2 5、只出现在TCP报文，UDP不含（序列号、目标端口、窗口大小）TCP数据报和UDP数据报都包含目标端口、源端口、校验号。但是由于UDP是不可靠的传输，故数据报不需要编号，所以不会有序号这一字段，而TCP是可靠的传输，故需要设置序号这一字段 归纳总结注意UDP数据报有两个字段：数据字段和首部字段。首部字段有8个字节，由4个字段组成，每个字段都是两个字节(牢记)： 源端口，即源端口号(端口号用16bit来表示，故需要2字节长度)。 目的端口，即目的端口号。 长度，即UDP用户数据报的长度(尽管有2字节来描述UDP数据报的长度，但是一般来说UDP协议限制其应用程序数据为512字节或更小)。 检验和，即检测UDP用户数据报在传输中是否有错(既检验首部又检验数据部分)。而TCP报文段也分为首部和数据两部分，TCP的全部功能也都体现在首部的各个字段中，其中源端口和目的端口的意义和UDP是一致的。 6、永久删除表(drop)7、一个空的5阶b-树依次插入{6,8,15,16,22,10,18,32,20}，6所在结点包含的关键字一颗m阶的B树定义 每个结点最多有m-1个关键字。 根结点最少可以只有1个关键字。 非根结点至少有Math.ceil(m/2)-1个关键字。 每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。 所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。 B树的插入操作插入操作是指插入一条记录，即（key, value）的键值对。如果B树中已存在需要插入的键值对，则用需要插入的value替换旧的value。若B树不存在这个key,则一定是在叶子结点中进行插入操作。 根据要插入的key的值，找到叶子结点并插入。 判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。 以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第3步。 8、设置断点的快捷键 设置断点：在该行最前面边框双击 或快捷键：Ctrl+Shift+B Debug 运行启动 运行到断点后：使用快捷键F5,F6，F7单步执行。 F5：Step into/进入该行的函数内部 F6：Step over/一行一行执行 F7：Step return/退出当前的函数 9、str1.index(str2) 纠正，应该是indexOf(获取字符在字符串中的位置),没有index方法的。 indexOf 方法返回一个整数值，指出 String 对象内子字符串的开始位置。即indexOf()括号内所包含的字符在该字符串内的循序位置，在第几位就返回几。如果有重复的字符出现，以第一个字符为准。如果没有找到子字符串，则返回 -1。如果 startindex 是负数，则 startindex 被当作零。如果它比最大的字符位置索引还大，则它被当作最大的可能索引。从左向右执行查找 12345function IndexDemo(str2)&#123; var str1 = BABEBIBOBUBABEBIBOBU var s = str1.indexOf(str2); return(s);&#125; 10、吞吐量超过300页每秒，系统失效（性能测试） 响应时间(RT) 响应时间是指系统对请求作出响应的时间。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。 对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。 吞吐量(Throughput) 吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。 对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。 并发用户数 并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。 QPS每秒查询率(Query Per Second) 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 11、判定覆盖判定覆盖是设计足够多的测试用例，使得程序中的每一个判断至少获得一次“真”和一次“假”，即使得程序流程图中的每一个真假分支至少被执行一次。 12、使用大顶堆排序（45,78,57,25,41,89），初始堆为89,78,57,25,41,45初始堆的构建，一开始不用想，先让根节点和末节点交换 13、将系统所有模块集成，测试策略（三明治集成测试）瞬时集成测试策略，又称大爆炸测试、一次性集成。首先对每个模块分别进行模块测试，然后将所有模块集成起来在一起进行测试，最终得到要求的软件系统。 14、判定/条件覆盖的特点判定条件覆盖是设计足够的测试用例，得使判断中每个条件的所有可能取值至少执行一次，同时每个判断本身所有可能结果也至少执行一次。缺点是忽略了条件的组合情况。 15、求两个集合并集所用到的操作（remove/add）交集 1234567891011121314151617181920import java.util.ArrayList; import java.util.List; public class TestCollection &#123; public static void main(String[] args) &#123; List&lt;String&gt; strList = new ArrayList&lt;String&gt;(); List&lt;String&gt; strList2 = new ArrayList&lt;String&gt;(); for(int i = 0; i &lt; 10; i ++) &#123; strList.add(&quot;aaa&gt;&gt;&quot; + i); strList2.add(&quot;aaa&gt;&gt;&quot; + (10 - i)); &#125; //求出交集 strList2.retainAll(strList); System.out.println(&quot;交集大小：&quot; + strList2.size()); for(int i = 0; i &lt; strList2.size(); i++) &#123; System.out.println(strList2.get(i)); &#125; &#125; &#125; 并集 1234567891011121314151617181920import java.util.ArrayList; import java.util.List; public class TestCollection &#123; public static void main(String[] args) &#123; List&lt;String&gt; strList = new ArrayList&lt;String&gt;(); List&lt;String&gt; strList2 = new ArrayList&lt;String&gt;(); for(int i = 0; i &lt; 10; i ++) &#123; strList.add(&quot;aaa&gt;&gt;&quot; + i); strList2.add(&quot;aaa&gt;&gt;&quot; + (10 - i)); &#125; //求出并集 strList2.removeAll(strList); strList2.addAll(strList); System.out.println(&quot;并集大小：&quot; + strList2.size()); for(int i = 0; i &lt; strList2.size(); i++) &#123; System.out.println(strList2.get(i)); &#125; &#125; &#125; 16、希尔排序算法 分割后子序列内部的排序是直接选择排序/最后一次的步长增量一定为1 希尔排序(Shell Sort)，也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。]]></content>
      <categories>
        <category>笔经面经</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2标签]]></title>
    <url>%2F2018%2F09%2F06%2FStruts2%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[Struts标签 通用标签 UI标签 Ajax标签 通用标签 流程控制标签 if/elseif/else标签：必须指定test属性，进行条件判断的逻辑表达式 append标签：用于将多个集合对象拼接成为一个新的集合对象，在拼接完成之后使用一个&lt;s:iterator&gt;即可迭代多个集合对象 generator标签：将指定字符串按指定的分隔符分隔成多个子串 iterator标签：用于对集合进行迭代 merge标签：拼接集合对象，拼接方式不同 sort标签：用于对集合进行排序，排序时必须提供自己的排序规则 1&lt;s:bean var=&quot;myComparator&quot; name=&quot;xx.MyComparator&quot;&gt; subset标签：用于截取并获得集合的子集 数据访问标签 a标签：HTML超链接 action标签：用于在JSP页面直接调用action bean标签：用于创建一个JavaBean实例 date标签：用于格式化输出日期，还可计算两个日期之间的差值 debug标签：用于辅助测试，在页面生成一个连接，通过该链接可以查看到ValueStack和StackContext中所有的值信息 i18n标签：用于将某个资源文件放到当前的值栈中，允许使用text标签来访问资源文件中的键值对 include标签：用于将一个JSP页面或Servlet页面包含到本页面中 param标签：用于为其他标签提供参数 property标签：用于输出指定值 push标签：用于将某个对象放到ValueStack的栈顶 set标签：用于将某个对象或值放入指定范围内 text标签：用来显示资源文件中的键值对 url标签：用于生成URL链接 UI标签 表单标签 checkbox标签：用于生成复选框 checkboxlist标签：用于生成多个复选框 combobox标签：用于生成下拉菜单 doubleselect标签：用于生成连动下拉菜单 head标签：提供额外的utils.js及相应的css样式 file标签：用于生成文件域 form标签：用于生成HTML的form表单 hidden标签：用于生成一个隐藏域 label标签：用于生成一个隐藏域，支持使用OGNL表达式 optiontransferselect标签 optgroup标签：允许以分组的形式来使用html的select组件 password标签：用于生成HTML密码输入框组件 radio标签：用于生成单选按钮或单选按钮组 reset标签：用于生成重置表单的HTML组件 select标签：用于生成下拉菜单 submit标签：用于生成提供表单的HTML组件 textarea标签：用于生成文本输入区域 textfield标签：用于生成HTML的普通输入框组件 token标签：用于解决页面重复提交等问题 updownselect标签：对一个select下拉框组件中的内容进行排序 非表单标签 actionerror标签：用于显示执行action过程中的错误信息 actionmessage标签：用于显示执行action过程中的提示信息 fielderror标签：用于显示执行action过程中的属性的错误信息 component标签：用于指定主题下自定义的UI组件 div标签：用于生成一个div Ajax标签 a标签：允许用户单击链接发出一个Ajax请求 autocompleter标签：允许用户在输入表单时提供自动提示和关键字补全 bind标签：用于把某个html组件要调用的JavaScript事件嫁接到另一个html组件 datetimepicker标签：一个界面友好的日历控件 div标签：可以向后台发送异步请求，来不断更新自己的内容 head标签：用于生成Dojo配置、JavaScript代码以及相关主题的CSS样式 submit标签：具有异步提交功能 tabbedpanel标签：用来提供页卡功能 textarea标签：一个富文本编辑器 tree/treenode标签：用于生成树形列表]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Struts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署描述符web.xml]]></title>
    <url>%2F2018%2F09%2F05%2F%E9%83%A8%E7%BD%B2%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[部署描述符应用场景 需要传递初始参数给ServletContext 有多个过滤器，并要指定调用顺序 需要更改会话超时设置 要限制资源的访问，并配置用户身份验证方式 xsi:schemaLocation属性指定了模式文档的位置，以便可以进行验证 version属性指定了Servlet规范的版本 metadata-complete属性指定部署描述符是否是完整的 web-app是文档的根元素 Servlet声明 Servlet映射 ServletContext的初始化参数 会话配置 监听器类 过滤器定义和映射 MIME类型映射 欢迎文件列表 错误页面 JSP特定的设置 JNDI的设置 详情戳：http://java.sun.com/xml/ns/javaee/web-app_3.0.xsd context-param元素可传值给ServletContext，值可以被任何Servlet/JSP页面读取 distributable元素必须为空，若定义则表明应用程序已部署到分布式的Servlet/JSP容器 error-page元素包含一个HTTP错误代码与资源路径或Java异常类型与资源路径之间的映射关系，定义容器在特定HTTP错误或异常时应返回的资源路径 filter指定一个Servlet过滤器 listener用来注册一个侦听器 mime-mapping用来映射一个MIME类型到一个扩展名 security-constraint允许对一组资源进行限制访问]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter]]></title>
    <url>%2F2018%2F09%2F05%2F%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%26JMeter%2F</url>
    <content type="text"><![CDATA[压力测试步骤 确定接受请求并完成相应的最大允许的延时 估计Web应用程序的最大并发用户数量 模拟用户请求，以一个比较小的负载开始，逐渐增加模拟用户的数量，直到Web应用程序的相应延时超过最大延时 如果负载比估计的用户数量小，那么应该优化这个Web程序，否则选择性地执行优化 JMeter的主要测试组件： 测试计划是使用JMeter进行测试的起点，它是其他JMeter测试元件的容器 线程组代表一定数量的并发用户，它可以用来模拟并发用户发送请求。实际的请求内容在Sampler中定义，它被线程组包含 监听器负责收集测试结果，同时被告知了结果显示的方式 逻辑控制器可以自定义JMeter发送请求的行为逻辑，它与Sampler结合使用可以模拟复杂的请求序列 断言可以用来判断请求响应的结果是否如用户所期望的。它可以用来隔离问题域，即在确保功能正确的前提下执行压力测试 配置元件维护Sampler需要的配置信息，并根据实际的需要会修改请求的内容 前置处理器和后置处理器负责在生成请求之前和之后完成工作。前置处理器常常用来修改请求的设置，后置处理器则常常用来处理响应的数据 定时器负责定义请求之间的延迟间隔]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit]]></title>
    <url>%2F2018%2F09%2F05%2FJUnit%2F</url>
    <content type="text"><![CDATA[JUnit特性 用于测试期望结果的断言 用于共享共同测试数据的测试工具 用于方便的组织和运行测试的测试套件 图形和文本的测试运行器 对类的一个方法进行测试 在eclipse加入JUnit的library 新建一个class 1234567891011121314//HelloWorld.javapackage example;import org.omg.CORBA.PUBLIC_MEMBER;public class HelloWorld &#123; public int abs(int n)&#123; return n&gt;0?n:(-n); &#125; public static void main(String[] args)&#123; HelloWorld hWorld=new HelloWorld(); &#125;&#125; 在类里面新建一个JUnit Test Case,选中setUP()和tearDown() 123456789101112131415161718192021222324252627282930313233343536//setUP()用来建立测试环境//tearDown()用于清理资源//绿色代表测试通过，红色未通过package example;import static org.junit.Assert.*;import org.junit.After;import org.junit.Before;import org.junit.Test;import junit.framework.TestCase;public class HelloWorldTest extends TestCase&#123; private HelloWorld hello; @Before public void setUp() throws Exception &#123; super.setUp(); hello=new HelloWorld(); &#125; @After public void tearDown() throws Exception &#123; super.tearDown(); &#125; @Test public void testAbs() &#123; assertEquals(hello.abs(14),14); assertEquals(hello.abs(-5),5); assertEquals(hello.abs(0),0); &#125;&#125; success！[图略]]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[测试内容 界面测试 功能测试 连接测试 表单测试 Cookies测试 数据库测试 内容测试 性能测试 连接速度测试 负载测试 压力测试 客户端兼容性测试 平台测试 浏览器测试 安全性测试 回归测试 Alpha和Beta测试 文档测试]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EJB]]></title>
    <url>%2F2018%2F09%2F05%2FEJB%2F</url>
    <content type="text"><![CDATA[EJB是Sun的服务器端组件模型，用于部署分布式应用程序 Enterprise JavaBean是可重用的、可移植的JavaEE组件，由封装业务逻辑的方法组成 EJB在容器里面运行，并作为普通Java对象POJO的形式来开发，可使用元数据注释来指定容器如何管理bean EJB的三种类型 会话bean：执行独立的、解除耦合的任务 实体bean：复杂的业务实体，负责数据库中存在的业务对象 消息驱动bean：用于接收异步JMS消息]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2018%2F09%2F05%2FServlet%2F</url>
    <content type="text"><![CDATA[Servlet的作用：接受一个请求request，做一些处理，然后返回一个响应response Servlet的三个特性： Servlet是独立于平台和协议的 Servlet运行于服务器端 Serlvet用于生成动态的Web页面 Servlet容器是为Servlet对象运行提供支持的一类Web服务器，能将请求的URL映射到Servlet上。每个Servlet都需要在Servlet容器上注册，表明自己接收哪些请求，并做哪些处理。然后Servlet容器将会根据这些信息，调用和管理Servlet Servlet的生命周期定义了一个Servlet如何被加载、初始化，以及它怎样接收请求、响应请求、提供服务 客户端请求Servlet，容器根据此请求，寻找是否存在Servlet实例，若不存在，容器负责装载此Servlet 容器根据请求，创建一个对应的Servlet实例 容器调用创建完成的Servlet实例中的init()方法 容器创建一个ServletRequest对象和ServletResponse对象，分别代表客户端的请求和向客户端返回的响应 容器调用Servlet实例的Service()方法，并将创建出来的ServletRequest和ServletResponse对象作为参数传递 在Servlet的service()方法中根据ServletRequest的信息，处理请求，访问其他资源，获取需求的信息 在service()方法中利用ServletResponse将响应传回容器，并最终到达客户端 对于更多的客户端请求，Server创建新的ServletRequest和ServletResponse对象，仍激活此Servlet的service()方法，将这两个对象作为参数传递给它，但无需再次调用init() 当Server不再需要Servlet时，Server调用Servlets的destroy()方法 Servlet的非生命周期方法 getServletInfo：返回Servlet的描述 getServletConfig：返回由Servlet容器传给init方法的ServletConfig ServletRequest方法 返回请求主体的字节数.如果不知道字节长度，返回-1 1public int getContentLength() 返回请求主体的MIME类型.如果不知道类型，返回null 1public java.lang.String getContentType() 返回指定请求参数的值 1public java.lang.String.getParameter(java.lang.String name) 返回这个HTTP请求的协议名称和版本 1public java.lang.String getProtocol() HttpServletRequest方法 返回表示请求上下文的请求URL部分 1java.lang.String getContextPath() 返回一个Cookie对象数组 1Cookie[] getCookies() 返回指定HTTP标题的值 1java.lang.String getHeader(java.lang.String name) 返回生成这个请求的HTTP方法名称 1java.lang.String getMethod() 返回请求URL中的查询字符串 1java.lang.String getQueryString() 返回与这个请求相关的会话对象。若不存在，将创建一个新的会话对象 1HttpSession getSession() 返回与这个请求相关的会话对象。若有，并且create参数为true，将创建一个新的会话对象 1HttpSession getSession(boolean create) 会话管理(默认下一个Web服务器无法区分一个HTTP请求是否为第一次访问)注意URL和token间用问号？分割，token间用与号&amp; URL重写是一种会话跟踪技术，它将一个或多个token添加到URL的查询字符串中，每个token通常为key=value形式 隐藏域将值放到HTML表单中。当表单提交时，隐藏域的值也同时提交到服务器端 Cookies是一个很少的信息片段，可自动地在浏览器和Web服务器间交互，因此cookies可存储在多个页面间传递的信息 HttpSession对象最强大最通用。一个用户可以有且最多有一个HTTPSession，并且不会被其他用户访问到默认情况下，HttpSession会在用户不活动一段时间后自动过期，该时间可以通过部署描述符的session-timeout元素配置]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XPath语法]]></title>
    <url>%2F2018%2F08%2F20%2FXPath%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实例 1 基本的XPath语法类似于在一个文件系统中定位文件,如果路径以斜线 / 开始, 那么该路径就表示到一个元素的绝对路径 /AAA： 选择根元素AAA&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;/DDD&gt; &lt;CCC/&gt; &lt;/AAA&gt; /AAA/CCC： 选择AAA的所有CCC子元素&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;/DDD&gt; &lt;CCC/&gt; &lt;/AAA&gt; /AAA/DDD/BBB：选择AAA的子元素DDD的所有子元素&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;/DDD&gt; &lt;CCC/&gt; &lt;/AAA&gt; 实例 2 如果路径以双斜线 // 开头, 则表示选择文档中所有满足双斜线//之后规则的元素(无论层级关系) //BBB： 选择所有BBB元素&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;BBB/&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;/DDD&gt; &lt;CCC&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/DDD&gt; &lt;/CCC&gt; &lt;/AAA&gt; //DDD/BBB：选择所有父元素是DDD的BBB元素&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;BBB/&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;/DDD&gt; &lt;CCC&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/DDD&gt; &lt;/CCC&gt; &lt;/AAA&gt; 实例 3 星号 * 表示选择所有由星号之前的路径所定位的元素 /AAA/CCC/DDD/*：选择所有路径依附于/AAA/CCC/DDD的元素&lt;AAA&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;EEE/&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;EEE/&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/CCC&gt; &lt;CCC&gt; &lt;BBB&gt; &lt;BBB&gt; &lt;BBB/&gt; &lt;/BBB&gt; &lt;/BBB&gt; &lt;/CCC&gt; &lt;/AAA&gt; ///*/BBB：选择所有的有3个祖先元素的BBB元素&lt;AAA&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;EEE/&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;EEE/&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/CCC&gt; &lt;CCC&gt; &lt;BBB&gt; &lt;BBB&gt; &lt;BBB/&gt; &lt;/BBB&gt; &lt;/BBB&gt; &lt;/CCC&gt; &lt;/AAA&gt; //*：选择所有元素&lt;AAA&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;EEE/&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;EEE/&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/CCC&gt; &lt;CCC&gt; &lt;BBB&gt; &lt;BBB&gt; &lt;BBB/&gt; &lt;/BBB&gt; &lt;/BBB&gt; &lt;/CCC&gt; &lt;/AAA&gt; 实例 4 方块号里的表达式可以进一步的指定元素, 其中数字表示元素在选择集里的位置, 而last()函数则表示选择集中的最后一个元素. /AAA/BBB[1]：选择AAA的第一个BBB子元素&lt;AAA&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/AAA&gt; /AAA/BBB[last()]：选择AAA的最后一个BBB子元素&lt;AAA&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/AAA&gt; 实例 5 属性通过前缀 @ 来指定 //@id:选择所有的id属性&lt;AAA&gt; &lt;BBB id = &quot;b1&quot;/&gt; &lt;BBB id = &quot;b2&quot;/&gt; &lt;BBB name = &quot;bbb&quot;/&gt; &lt;BBB/&gt; &lt;/AAA&gt; //BBB[@id]:选择有id属性的BBB元素&lt;AAA&gt; &lt;BBB id = &quot;b1&quot;/&gt; &lt;BBB id = &quot;b2&quot;/&gt; &lt;BBB name = &quot;bbb&quot;/&gt; &lt;BBB/&gt; &lt;/AAA&gt; //BBB[@name]:选择有name属性的BBB元素&lt;AAA&gt; &lt;BBB id = &quot;b1&quot;/&gt; &lt;BBB id = &quot;b2&quot;/&gt; &lt;BBB name = &quot;bbb&quot;/&gt; &lt;BBB/&gt; &lt;/AAA&gt; //BBB[@*]:选择有任意属性的BBB元素&lt;AAA&gt; &lt;BBB id = &quot;b1&quot;/&gt; &lt;BBB id = &quot;b2&quot;/&gt; &lt;BBB name = &quot;bbb&quot;/&gt; &lt;BBB/&gt; &lt;/AAA&gt; //BBB[not(@*)]:选择没有属性的BBB元素&lt;AAA&gt; &lt;BBB id = &quot;b1&quot;/&gt; &lt;BBB id = &quot;b2&quot;/&gt; &lt;BBB name = &quot;bbb&quot;/&gt; &lt;BBB/&gt; &lt;/AAA&gt; 实例 6 属性的值可以被用来作为选择的准则, normalize-space函数删除了前部和尾部的空格, 并且把连续的空格串替换为一个单一的空格 //BBB[@id=’b1’]：选择含有属性id且其值为’b1’的BBB元素&lt;AAA&gt; &lt;BBB id = &quot;b1&quot;/&gt; &lt;BBB name = &quot; bbb &quot;/&gt; &lt;BBB name = &quot;bbb&quot;/&gt; &lt;/AAA&gt; //BBB[@name=’bbb’]：选择含有属性name且其值为’bbb’的BBB元素&lt;AAA&gt; &lt;BBB id = &quot;b1&quot;/&gt; &lt;BBB name = &quot; bbb &quot;/&gt; &lt;BBB name = &quot;bbb&quot;/&gt; &lt;/AAA&gt; //BBB[normalize-space(@name)=’bbb’]：选择含有属性name且其值(在用normalize-space函数去掉前后空格后)为’bbb’的BBB元素&lt;AAA&gt; &lt;BBB id = &quot;b1&quot;/&gt; &lt;BBB name = &quot; bbb &quot;/&gt; &lt;BBB name = &quot;bbb&quot;/&gt; &lt;/AAA&gt; 实例 7 count()函数可以计数所选元素的个数 //*[count(BBB)=2]：选择含有2个BBB子元素的元素&lt;AAA&gt; &lt;CCC&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/CCC&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/DDD&gt; &lt;EEE&gt; &lt;CCC/&gt; &lt;DDD/&gt; &lt;/EEE&gt; &lt;/AAA&gt; // [count()=2]：选择含有2个子元素的元素&lt;AAA&gt; &lt;CCC&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/CCC&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/DDD&gt; &lt;EEE&gt; &lt;CCC/&gt; &lt;DDD/&gt; &lt;/EEE&gt; &lt;/AAA&gt; // [count()=3]：选择含有3个子元素的元素&lt;AAA&gt; &lt;CCC&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/CCC&gt; &lt;DDD&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/DDD&gt; &lt;EEE&gt; &lt;CCC/&gt; &lt;DDD/&gt; &lt;/EEE&gt; &lt;/AAA&gt; 实例 8 name()函数返回元素的名称, start-with()函数在该函数的第一个参数字符串是以第二个参数字符开始的情况返回true, contains()函数当其第一个字符串参数包含有第二个字符串参数时返回true. //*[name()=’BBB’]：选择所有名称为BBB的元素(这里等价于//BBB)&lt;AAA&gt; &lt;BCC&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/BCC&gt; &lt;DDB&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/DDB&gt; &lt;BEC&gt; &lt;CCC/&gt; &lt;DBD/&gt; &lt;/BEC&gt; &lt;/AAA&gt; //*[starts-with(name(),’B’)]：选择所有名称以”B”起始的元素&lt;AAA&gt; &lt;BCC&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/BCC&gt; &lt;DDB&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/DDB&gt; &lt;BEC&gt; &lt;CCC/&gt; &lt;DBD/&gt; &lt;/BEC&gt; &lt;/AAA&gt; //*[contains(name(),’C’)]：选择所有名称包含”C”的元素&lt;AAA&gt; &lt;BCC&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/BCC&gt; &lt;DDB&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;/DDB&gt; &lt;BEC&gt; &lt;CCC/&gt; &lt;DBD/&gt; &lt;/BEC&gt; &lt;/AAA&gt; 实例 9 string-length函数返回字符串的字符数,你应该用&lt;替代&lt;, 用&gt;代替&gt; //*[string-length(name()) = 3]:选择名字长度为3的元素&lt;AAA&gt; &lt;Q/&gt; &lt;SSSS/&gt; &lt;BB/&gt; &lt;CCC/&gt; &lt;DDDDDDDD/&gt; &lt;EEEE/&gt; &lt;/AAA&gt; //*[string-length(name()) &lt; 3]:选择名字长度小于3的元素&lt;AAA&gt; &lt;Q/&gt; &lt;SSSS/&gt; &lt;BB/&gt; &lt;CCC/&gt; &lt;DDDDDDDD/&gt; &lt;EEEE/&gt; &lt;/AAA&gt; //*[string-length(name()) &gt; 3]:选择名字长度大于3的元素&lt;AAA&gt; &lt;Q/&gt; &lt;SSSS/&gt; &lt;BB/&gt; &lt;CCC/&gt; &lt;DDDDDDDD/&gt; &lt;EEEE/&gt; &lt;/AAA&gt; 实例 10 多个路径可以用分隔符 | 合并在一起 //CCC | //BBB:选择所有的CCC和BBB元素&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;DDD&gt; &lt;CCC/&gt; &lt;/DDD&gt; &lt;EEE/&gt; &lt;/AAA&gt; /AAA/EEE | //BBB:选择所有的BBB元素和所有是AAA的子元素的EEE元素&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;DDD&gt; &lt;CCC/&gt; &lt;/DDD&gt; &lt;EEE/&gt; &lt;/AAA&gt; /AAA/EEE | //DDD/CCC | /AAA | //BBB:可以合并的路径数目没有限制&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;DDD&gt; &lt;CCC/&gt; &lt;/DDD&gt; &lt;EEE/&gt; &lt;/AAA&gt; 实例 11 child轴(axis)包含上下文节点的子元素, 作为默认的轴,可以忽略不写. /AAA等价于 /child::AAA&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;/AAA&gt; /child::AAA等价于/AAA&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;/AAA&gt; /AAA/BBB等价于/child::AAA/child::BBB&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;/AAA&gt; /child::AAA/child::BBB等价于/AAA/BBB&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;/AAA&gt; /child::AAA/BBB,二者都可以被合并&lt;AAA&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;/AAA&gt; 实例 12 descendant (后代)轴包含上下文节点的后代,一个后代是指子节点或者子节点的子节点等等, 因此descendant轴不会包含属性和命名空间节点. /descendant::*:选择文档根元素的所有后代.即所有的元素被选择&lt;AAA&gt; &lt;BBB&gt; &lt;DDD&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;EEE/&gt; &lt;/CCC&gt; &lt;/DDD&gt; &lt;/BBB&gt; &lt;CCC&gt; &lt;DDD&gt; &lt;EEE&gt; &lt;DDD&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/EEE&gt; &lt;/DDD&gt; &lt;/CCC&gt; &lt;/AAA&gt; /AAA/BBB/descendant::*:选择/AAA/BBB的所有后代元素&lt;AAA&gt; &lt;BBB&gt; &lt;DDD&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;EEE/&gt; &lt;/CCC&gt; &lt;/DDD&gt; &lt;/BBB&gt; &lt;CCC&gt; &lt;DDD&gt; &lt;EEE&gt; &lt;DDD&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/EEE&gt; &lt;/DDD&gt; &lt;/CCC&gt; &lt;/AAA&gt; //CCC/descendant::*:选择在祖先元素中有CCC的所有元素&lt;AAA&gt; &lt;BBB&gt; &lt;DDD&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;EEE/&gt; &lt;/CCC&gt; &lt;/DDD&gt; &lt;/BBB&gt; &lt;CCC&gt; &lt;DDD&gt; &lt;EEE&gt; &lt;DDD&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/EEE&gt; &lt;/DDD&gt; &lt;/CCC&gt; &lt;/AAA&gt; //CCC/descendant::DDD:选择所有以CCC为祖先元素的DDD元素&lt;AAA&gt; &lt;BBB&gt; &lt;DDD&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;EEE/&gt; &lt;/CCC&gt; &lt;/DDD&gt; &lt;/BBB&gt; &lt;CCC&gt; &lt;DDD&gt; &lt;EEE&gt; &lt;DDD&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/EEE&gt; &lt;/DDD&gt; &lt;/CCC&gt; &lt;/AAA&gt; 实例 13 parent轴(axis)包含上下文节点的父节点, 如果有父节点的话 //DDD/parent::*:选择DDD元素的所有父节点&lt;AAA&gt; &lt;BBB&gt; &lt;DDD&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;EEE/&gt; &lt;/CCC&gt; &lt;/DDD&gt; &lt;/BBB&gt; &lt;CCC&gt; &lt;DDD&gt; &lt;EEE&gt; &lt;DDD&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/EEE&gt; &lt;/DDD&gt; &lt;/CCC&gt; &lt;/AAA&gt; 实例 14 ancestor轴(axis)包含上下节点的祖先节点, 该祖先节点由其上下文节点的父节点以及父节点的父节点等等诸如此类的节点构成,所以ancestor轴总是包含有根节点,除非上下文节点就是根节点本身. /AAA/BBB/DDD/CCC/EEE/ancestor::*:选择一个绝对路径上的所有节点&lt;AAA&gt; &lt;BBB&gt; &lt;DDD&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;EEE/&gt; &lt;/CCC&gt; &lt;/DDD&gt; &lt;/BBB&gt; &lt;CCC&gt; &lt;DDD&gt; &lt;EEE&gt; &lt;DDD&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/EEE&gt; &lt;/DDD&gt; &lt;/CCC&gt; &lt;/AAA&gt; //FFF/ancestor::*:选择FFF元素的祖先节点&lt;AAA&gt; &lt;BBB&gt; &lt;DDD&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;EEE/&gt; &lt;/CCC&gt; &lt;/DDD&gt; &lt;/BBB&gt; &lt;CCC&gt; &lt;DDD&gt; &lt;EEE&gt; &lt;DDD&gt; &lt;FFF/&gt; &lt;/DDD&gt; &lt;/EEE&gt; &lt;/DDD&gt; &lt;/CCC&gt; &lt;/AAA&gt; 实例 15 following-sibling轴(axis)包含上下文节点之后的所有兄弟节点 /AAA/BBB/following-sibling::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;DDD/&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;DDD/&gt; &lt;CCC/&gt; &lt;FFF/&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; //CCC/following-sibling::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;DDD/&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;DDD/&gt; &lt;CCC/&gt; &lt;FFF/&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; 实例 16 preceding-sibling 轴(axis)包含上下文节点之前的所有兄弟节点 /AAA/XXX/preceding-sibling::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;DDD/&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;DDD/&gt; &lt;CCC/&gt; &lt;FFF/&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; //CCC/preceding-sibling::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;DDD/&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;DDD/&gt; &lt;CCC/&gt; &lt;FFF/&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; 实例 17 following轴(axis)包含同一文档中按文档顺序位于上下文节点之后的所有节点, 除了祖先节点,属性节点和命名空间节点 /AAA/XXX/following::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ&gt; &lt;DDD/&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;/DDD&gt; &lt;/ZZZ&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;DDD/&gt; &lt;CCC/&gt; &lt;FFF/&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; //ZZZ/following::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ&gt; &lt;DDD/&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;/DDD&gt; &lt;/ZZZ&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;DDD/&gt; &lt;CCC/&gt; &lt;FFF/&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; 实例 18 following轴(axis)包含同一文档中按文档顺序位于上下文节点之前的所有节点, 除了祖先节点,属性节点和命名空间节点 /AAA/XXX/preceding::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ&gt; &lt;DDD/&gt; &lt;/ZZZ&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;DDD/&gt; &lt;CCC/&gt; &lt;FFF/&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; //GGG/preceding::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ&gt; &lt;DDD/&gt; &lt;/ZZZ&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;DDD/&gt; &lt;CCC/&gt; &lt;FFF/&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; 实例 19 descendant-or-self 轴(axis)包含上下文节点本身和该节点的后代节点 /AAA/XXX/descendant-or-self::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ&gt; &lt;DDD/&gt; &lt;/ZZZ&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;DDD/&gt; &lt;CCC/&gt; &lt;FFF/&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; //CCC/descendant-or-self::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ&gt; &lt;DDD/&gt; &lt;/ZZZ&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;DDD/&gt; &lt;CCC/&gt; &lt;FFF/&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; 实例 20 ancestor-or-self 轴(axis)包含上下文节点本身和该节点的祖先节点 /AAA/XXX/DDD/EEE/ancestor-or-self::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ&gt; &lt;DDD/&gt; &lt;/ZZZ&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;DDD/&gt; &lt;CCC/&gt; &lt;FFF/&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; //GGG/ancestor-or-self::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ&gt; &lt;DDD/&gt; &lt;/ZZZ&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;DDD/&gt; &lt;CCC/&gt; &lt;FFF/&gt; &lt;FFF&gt; &lt;GGG/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; 实例 21 ancestor, descendant, following, preceding 和self轴(axis)分割了XML文档(忽略属性节点和命名空间节点), 不能交迭, 而一起使用则包含所有节点 //GGG/ancestor::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ/&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;FFF&gt; &lt;HHH/&gt; &lt;GGG&gt; &lt;JJJ&gt; &lt;QQQ/&gt; &lt;/JJJ&gt; &lt;JJJ/&gt; &lt;/GGG&gt; &lt;HHH/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; //GGG/descendant::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ/&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;FFF&gt; &lt;HHH/&gt; &lt;GGG&gt; &lt;JJJ&gt; &lt;QQQ/&gt; &lt;/JJJ&gt; &lt;JJJ/&gt; &lt;/GGG&gt; &lt;HHH/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; //GGG/following::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ/&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;FFF&gt; &lt;HHH/&gt; &lt;GGG&gt; &lt;JJJ&gt; &lt;QQQ/&gt; &lt;/JJJ&gt; &lt;JJJ/&gt; &lt;/GGG&gt; &lt;HHH/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; //GGG/preceding::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ/&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;FFF&gt; &lt;HHH/&gt; &lt;GGG&gt; &lt;JJJ&gt; &lt;QQQ/&gt; &lt;/JJJ&gt; &lt;JJJ/&gt; &lt;/GGG&gt; &lt;HHH/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; //GGG/self::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ/&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;FFF&gt; &lt;HHH/&gt; &lt;GGG&gt; &lt;JJJ&gt; &lt;QQQ/&gt; &lt;/JJJ&gt; &lt;JJJ/&gt; &lt;/GGG&gt; &lt;HHH/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; //GGG/ancestor:: | //GGG/descendant:: | //GGG/following:: | //GGG/preceding:: | //GGG/self::*&lt;AAA&gt; &lt;BBB&gt; &lt;CCC/&gt; &lt;ZZZ/&gt; &lt;/BBB&gt; &lt;XXX&gt; &lt;DDD&gt; &lt;EEE/&gt; &lt;FFF&gt; &lt;HHH/&gt; &lt;GGG&gt; &lt;JJJ&gt; &lt;QQQ/&gt; &lt;/JJJ&gt; &lt;JJJ/&gt; &lt;/GGG&gt; &lt;HHH/&gt; &lt;/FFF&gt; &lt;/DDD&gt; &lt;/XXX&gt; &lt;CCC&gt; &lt;DDD/&gt; &lt;/CCC&gt; &lt;/AAA&gt; 实例 22 div运算符做浮点除法运算, mod运算符做求余运算, floor函数返回不大于参数的最大整数(趋近于正无穷), ceiling返回不小于参数的最小整数(趋近于负无穷) //BBB[position() mod 2 = 0 ]：选择偶数位置的BBB元素&lt;AAA&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;CCC/&gt; &lt;CCC/&gt; &lt;/AAA&gt; //BBB[ position() = floor(last() div 2 + 0.5) or position() = ceiling(last() div 2 + 0.5) ]：选择中间的BBB元素&lt;AAA&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;CCC/&gt; &lt;CCC/&gt; &lt;/AAA&gt; //CCC[ position() = floor(last() div 2 + 0.5) or position() = ceiling(last() div 2 + 0.5) ]：选择中间的CCC元素&lt;AAA&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;BBB/&gt; &lt;CCC/&gt; &lt;CCC/&gt; &lt;CCC/&gt; &lt;/AAA&gt;]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL双机热备份方法]]></title>
    <url>%2F2018%2F08%2F05%2FMySql%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E4%BB%BD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[MySql双机热备份方法（备份Master数据库mysql到Slave中） 【环境】 操作系统:两台32位Windows7旗舰版 Mysql版本：mysql-5.5.28-win32（低版本mysql在配置副库时有所区别） 工具 mysql-gui-tools-5.0-r17-win32 Master IP：192.168.1.4(主) Slave IP：192.168.1.15(副) MySQL安装路径：D:\Program Files\MySQL\MySQL Server 5.5 【设置】 分别另外添加用户：用户名：mysql，密码：mysql (grant all on . to ‘ mysql ‘@’%’ identified by ‘ mysql ‘;)；并将mysql数据库内的表user中的host列下的值改为%(或者设置为允许远程访问的主机的IP) 在master(192.168.1.4)上测试slave(192.168.1.15) mysql用户是否可以远程登录,以及在slave (192.168.1.15)上测试master (192.168.1.4) mysql用户是否可以远程登录,如果不能正常登录,需查看数据库mysql数据库内user表内用户信息是否正确.(如果不能登录,也可能是防火墙问题导致) 【配置】找到安装路径下的my.ini配置，并分别[mysqld]下添加以下内容: Master配置： 1234567[mysqld]server-id=1log-bin=bin_logbinlog-do-db=mysql（需备份的数据库名称） 重启master上的mysql服务，点击，输入密码进入,输入show master status命令后得，记录下File、Position对应的值；Slave配置： 123[mysqld]server-id=2 启动slave上mysql服务，点击进入，在命令行输入root用户密码后再输入命令： 12345678910change master to master_host=&apos;192.168.1.4&apos;,master_user=&apos;mysql&apos;, master_password=&apos;mysql’,master_log_file=&apos;bin_log.000001&apos;,master_log_pos=395;（此处的master_log_file、master_log_pos必须与主库信息相同）输入：slave start启动；输入：show slave status 当图中画线部分为“YES”时，表示主从同步正常。 【结论】经测试：在主库内创建、添加数据，副库可正常进行备份。]]></content>
      <categories>
        <category>实践操作</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策支持系统]]></title>
    <url>%2F2018%2F07%2F03%2F%E5%86%B3%E7%AD%96%E6%94%AF%E6%8C%81%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[决策，从宏观讲，就是制定政策。从微观讲，就是做出决定 决策是对未来的方向、目标以及实现途径做出决定的过程 决策是指个人或集体为了达到或实现某一目标，借助一定的科学手段和方法，从若干备选方案中选择或综合成一个满意。合理的方案，并付诸实施的过程 科学决策是决策者依据科学方法、科学程序和科学手段所进行的决策工作 科学决策主要特点：1、具有科学的决策体系和运作机制：决策系统、参谋系统、信息系统、执行系统、监督系统2、遵循科学的决策过程：提出问题和确定目标、拟定决策方案、决策方案的评估和优选、决策的实施和反馈3、重视“智囊团”在决策中的参谋咨询作用4、运用现代科学技术和科学方法 运筹学：为决策机构在对其和控制下的业务活动进行决策，提供以数量化为基础的科学方法 管理科学：用数学模型方法研究经济、国防等部门在环境的约束条件下，合理调配人力、物力和财力等资源，通过模型的有效运行，来预测发展趋势，制定行动规划或优选可行方案 决策支持系统：管理信息系统和运筹学的结合，在运筹学单模型辅助决策的基础上，结合多个模型以及相应的数据，形成决策方案辅助决策 决策问题的结构化分类：对决策问题的内在规律能否用明确的程序化语言给以清晰的说明或者描述。能够描述清楚的称为结构化问题。不能描述清楚，而只能凭人的直觉或者经验作出判断的称为非结构化问题。介于这两者之间的，则称为半结构化问题1、问题形式化描述的难易程度2、解题方法的难易程度3、解题中所需计算量的多少 决策支持系统的定义： Scott Morton：决策支持系统把个人的智能资源和计算机的能力结合在一起以改善决策的质量，它是基于计算机的支持系统，用于帮助管理决策者处理半结构化问题 R.H.Sqraque 和 E.D.Carlson：决策支持系统具有交互式计算机系统的特征，帮助决策者利用数据和模型去解决半结构化问题 解决高层管理者常碰到的半结构化和非结构化问题 把模型或分析技术与传统的数据存储和检索功能结合起来 以对话方式使用决策支持系统 能适应环境和用户要求的变化 P.G.W.Keen：决策支持系统是“决策D”、“支持S”、“系统S”三者汇集成的一体，即通过不断发展的计算机建立系统的技术，逐渐扩展支持能力，以更好地辅助决策 S.S.Mittra：决策支持系统是从数据库中找出必要的数据，并利用数学模型的功能为用户产生所需要的信息 R.H.Bonczek：决策制定是由决策支持系统和它的用户共同完成的 本书：按决策问题的需要，利用数据、模型和知识等决策资源，组合形成解决问题的多个方案，通过计算过的辅助决策的依据，达到支持科学决策的计算机程序系统 决策支持目的：1) 帮助经理在非结构化任务中做出决策2) 支持而不是代替经理的判断力3) 改进决策的效能而不是提高它的效率 模型：对客观事物的特征和变化规律的一种科学抽象，通过研究模型来揭示客观事物的本质 What-if分析：如何对不确定性情况做各种各样的假设，并反复通过模型计算后，对各种结果进行深入分析，研究最优解会有怎样的变化 What-if分析的基本作用：1) 优化模型的许多参数在建模时是很难精确确定的。通过What-if分析可以表明，系数估计值必须精确到怎样的程度，才能避免得出错误的最优解，而且，可以找出哪些系数是需要重新精确定义的灵敏度参数2) 在决策问题的条件发生变化时，即使不求解，也可以表明模型参数的变化是否会改变最优解3) 当模型特定的参数反映管理政策决策时，可表明改变这些决策对结果的影响，从而有效指导管理者做出最终的决策 数据处理：数据收集、数据录入、数据正确性检查、数据操作与加工、数据输出 数据处理的特性1) 数据量大2) 数据处理一般不涉及复杂的数学运算：大多采用变字长的十进制算术运算3) 时效性强4) 数据处理的方法是每次处理一个记录 管理信息系统：由人和计算机结合的对管理信息进行收集、存储、维护、加工、传递和使用的系统 管理信息系统特性：1) 管理信息系统的主要功能是事务处理2) 管理信息系统包括多个电子数据处理系统EDP3) 管理信息系统是为结构化决策服务的4) 管理信息系统具有系统的一切特征5) 管理信息系统是社会管理系统的一部分6) 管理信息系统是以数据库系统为基础建立起来的 决策支持系统与管理信息系统的不同1) MIS是面向中层管理人员，为管理服务的系统；DSS是面向高层人员，为辅助决策服务的系统2) MIS按事务功能综合多个事务处理的EDP；DSS是通过模型计算辅助决策3) MIS是以数据库系统为基础的，以数据驱动的系统；DSS是以模型库系统为基础的，以模型驱动的系统4) MIS分析着重于系统的总体信息的需求，输出报表的模式是固定的；DSS分析着重于决策者的需求，输出数据的模式是复杂的5) MIS系统追求的是效率，即快速查询和产生报表；DSS追求的是有效性，即决策的正确性6) MIS支持的是结构化决策；DSS支持的是半结构化决策 决策支持系统特点：增加了模型库和模型库管理系统，它把众多的模型有效地组织和存储起来，并且建立了模型库和数据库的有机结合 决策支持系统特性：1) 用定量方式辅助决策，而不是代替决策2) 使用大量的数据和多个模型3) 支持决策制定过程4) 为多个管理层次上的用户提供决策支持5) 能支持相互独立的决策和相互依赖的决策6) 用于半结构化决策领域 专家系统：利用专家的知识在计算机上进行推理，达到专家解决问题的能力 专家系统的特性：1) 用定性方式辅助决策2) 使用知识和推理机制3) 知识获取比较困难4) 知识包括确定知识和经验知识5) 解决问题的能力受知识库内容的限制6) 专家系统适应范围较宽 专家系统结构核心部分组成：1) 推理机：完成对知识的搜索和推理2) 知识库：存放大量的专家知识3) 动态数据库：存放已知的事实和推理出的事实与结果 神经网络：基于人脑神经元的数学模型建立起来的智能技术 前馈式网络：反向传播模型BP 反馈式网络： 离散型反馈式网络：用于联想记忆 连续性反馈式网络：用于优化计算 自组织网络：用于聚类 机器学习：模拟人的学习方法，通过学习获取知识的智能技术 归纳学习 信息论方法： ID3方法 C4.5方法 IBLE方法 集合论方法 AQ系列方法：用覆盖正例、排斥反例的思想规则知识 粗糙集理论 类比学习 解释学习 自然语言理解：计算机从用户输入的自然语言请求中分析语言中的语法，获取语义1) 词法分析2) 句法分析3) 语义分析 数据仓库是企业内部的运作数据和事务数据的中央仓库，这些数据经过了清理、转换、综合和编辑，把运作数据转换成商业信息，帮助企业解决许多不同的复杂商业难题 数据挖掘是在大型数据库中知识发现的一个步骤，它主要是利用某些特定的知识获取算法，在一定的运算效率的限制内，从数据库中发现出有用的知识 统计分析方法 神经网络方法 机器学习 归纳学习 覆盖正例 排斥反例 决策树 遗传算法 发现学习算法 知识发现是一个多步骤的对大量数据进行分析的过程1) 数据预处理2) 知识提取3) 知识评估及解释 数据挖掘产生信息类型1) 关联信息：显示与某个时间相关联的信息2) 序列信息：显示所有时间内互相链接的一些时间3) 聚类信息：把那些没有类别的数据聚集成多个类别，给用户提供“物以类聚”的宏观观念4) 分类信息：在于找出已知类别的描述信息5) 预测信息：通过使用隐藏在数据中的回归模型来估计一些连续变量的未来值 聚类：把没有类别的数据，按“距离”远近聚成不同的类 分类：在已有类别的数据中，对每个类找出描述该类的特征来 基于数据仓库的决策支持系统1) 数据仓库DW：存储着大量辅助决策的数据，为不同的用户随时提供各种辅助决策的随机查询、综合数据或趋势分析信息2) 联机分析处理OLAP：提供了多维数据分析，进行切片、切块和钻取等多种分析手段，发现问题和找出问题的原因3) 数据挖掘DM：挖掘数据中隐含的信息和知识来辅助决策 把数据仓库、联机分析处理、数据挖掘、模型库、数据库和知识库结合起来形成的综合决策支持系统是更高级形式的决策支持系统。其中数据仓库能够实现对决策主题数据的存储和综合以及时间趋势分析、联机分析处理实现多维数据分析，数据挖掘从数据库和数据仓库中获取知识，模型库实现多个模型的组合辅助决策，数据库为辅助决策提供数据，知识库中知识通过推理进行定性分析。它们在综合决策支持系统中将相互补充和依赖，发挥各自的辅助决策优势，实现更有效的辅助决策 决策过程基础步骤：1) 确定决策目标2) 拟定各种备选方案3) 从各种备选方案中进行选择4) 执行方案 决策步骤： 提出问题 寻找差距：实际情况与理想要求之间的差别 确定问题的性质、特点和范围 确定目标：决策者根据各种条件，对于未来一段时间内所要达到的目的和结果的判断 从变化与差异中找原因 对产生现象的可能原因进行寻根究底的详细分析 价值准则：落实目标、评价和选择方案的依据 把目标分解为若干层次的确定价值指标 规定价值的主次、缓急以及在相互矛盾时的取舍原则 指明实现这些指标的约束条件 拟定方案 原则 整体详尽性：应把所有可能方案包括无遗，即不要漏掉某些可能的方案 相互排斥性：不同的备选方案之间相互排斥 阶段 大胆设想阶段：寻找备选方案需要创新，取决于他的信息、知识、能力和精神 精心设计阶段： 对数据、模型和知识的确定 对方案后果的估计 分析评估 经验评价法：由决策者的经验知识进行定性评价和选择各种备选方案 数学分析法：对拟定的备选方案选用相应的模型和知识，利用计算机对决策支持系统进行计算，解代表了备选方案的结果 试验法 选定方案：从各种可供选择的方案中权衡利弊，然后选取其中一种方案或将多个方案综合成一种方案 试验验证：通过决策方案试验的验证为决策者做最后的决策提供依据 普遍实施：加强反馈工作的追踪方法 制定规章制度 用规章制度来衡量执行情况 随时纠正偏差 决策目标的特点：1) 目标概念明确或者决策目标数量化，这样目标不会引起不同的理解2) 决策目标有时间限制，在规定的时间内完成3) 决策目标可能有约束条件限制 决策体系：指决策整个过程中的各个层次、各个部门在决策活动中的决策权限、组织形式。机构设置、调节机制、监督方法的整个体系 决策系统：由负有决策责任的领导者组成，主要任务是以现代决策手段和技术对信息系统提供的大量信息进行去粗取精、去伪存真等科学处理，使信息全面、及时、准确 集体决策：由决策系统的集体来做决定，可以集思广益，克服片面性，减少失误。但决策速度慢，会殆误时机，有时由于意见不一致，致使决策无法进行，或调和折中，影响决策，一旦决策失误又相互推诿责任 单一决策：速度快、责任明确，但容易出现片面性并造成失误，适合一般性决策 参谋（智囊系统）：咨询系统，充分利用信息系统提供的信息为决策系统拟定各种备选方案 只参与决策研究，提供咨询意见和建议，而不是直接进行决策和执行决策，它对决策方案的科学性负责，但不对决策和执行后果负责 进行应用开发性研究。研究如何将新理论和新原理应用于特定目标的前景和途径，以及将研究成果具体应用于社会实践 一个综合性研究组织。对于决策问题需要多领域的专家共同协商来完成决策方案 作用是进行预测、提供或评估决策方案、反馈信息、评价效果 信息系统：为了满足决策的需要，把有关的信息资料经过搜集、整理、计算、分析和评价等加工处理环节，变为可以利用的有效信息，并用以支持决策工作的系统 外部信息：来源于组织外部环境的信息，量大而零散，变化较快并有一定的随机性 内部信息：反映一个组织内部经济活动的信息 固定信息：在事务处理过程中直接记录下来经过加工后的信息 加工信息：通过一定的数学方法和加工处理所获得的信息 执行系统：执行决策系统的各项决策指令并付诸实施的系统 监督系统：对执行系统贯彻执行决策系统的指令情况进行各方面的检查监督，并帮助决策系统自我调节，以保证指令的顺利贯彻执行和决策目标的胜利实现 决策体系运行过程：参谋系统利用信息系统制定决策方案提供给决策系统，决策系统利用信息系统提供的信息对智囊系统提供的方案进行决策。决策系统的决策指令在监督系统的监督下由执行系统贯彻执行，执行的情况和结果又经过智囊系统和信息系统反馈到决策系统。智囊系统根据新情况，提供修补或修改方案给决策系统，决策系统对修改方案进行决策，作出修订指示，再由执行系统执行 群体决策：若干决策者针对大型问题或复杂问题，在共同环境和一定的目标下发挥相互联系或相互制约的作用，通过共同协商，寻求各方都满意的结果 远程会议由两个或者多个决策室通过可视通信设备连接在一起，使用电子传真技术组织会议进行决策 GDSS的应用类型：1) 决策室：在同一个会议室内，决策者们在自己的计算机或终端上利用各自的DSS进行决策制定，GDSS的组织者协调和综合各决策者的决策意见，使GDSS得出群决策结论2) 局部决策网：利用计算机局部网络使各决策者在各自的办公室中进行群决策3) 远程会议：把相距遥远的会议室联系起来，通过通信线路实现录像电视传真等设备，形成现代化远程会议，达到群体决策4) 远程决策制定：任何一个决策者可在任何时候与群体的其他成员取得联系，共同做出决策 经理信息系统（高层信息系统）：执行信息系统，是对高层管理者的战略决策提供支持的决策支持系统。通过获取企业内部和外部的有关信息为高层决策者提供支持决策的系统 特性 直接为高层决策者使用 界面友好，操作简便 通过图、表和文字等形式输出信息 从内部和外部资源中获取信息 提供选择、析取、分离和追踪信息的工具 提供各种类型的报告：状态报告、异常情况报告、趋势分析报告和特别查询报告等 高层决策者工作 管理混乱局势：对出乎预料的事件进行连续不断的决策和关注 创新活动：对随时变化的市场和环境作出准确的预测和行动 资源配置：对人、钱、设备和商品等资源进行管理和配置 协商和谈判：对部门间的职权范围和工作流程中产生的纠纷和冲突需要进行协商和谈判 EIS应满足的需求 办公支持 分析支持 个性化服务 图形功能 规划功能 人机界面友好 安全措施 商务智能系统：以数据仓库为基础，通过联机分析处理和数据挖掘技术帮助企业领导者针对市场变化的环境做出快速、准确的决策 提取、转换和加载ETL工具 数据仓库 商务智能工具 用户查询和报表工具：满足用户不同需求的查询及产生相应报表 联机分析处理：实现对数据仓库中数据的多维数据查询 数据挖掘：从大量数据中挖掘出分类知识和关联知识 商务智能：在数据仓库中获得综合信息、预测信息和多维数据分析信息，解决商务中的决策问题。能随时应付意外情况的发生 商务智能系统改进企业决策过程1) 信息共享：用户可以迅速找到所需要的数据，通过对数据进行钻取分析已达到目标2) 实时反馈分析：使员工随时看到工作进展，并且了解一个特定的行为对现时目标的效用3) 鼓励用户找出问题的根本原因：对与成功或失败相关的诸多因素进行深度分析4) 使用主动智能5) 实时智能 具体业务的智能表现1) 客户智能2) 营销智能3) 销售智能4) 服务智能5) 采购智能6) 流程管理职能7) 财务智能 资源：被人们利用或消耗并产生价值的东西 计算机资源类型1) 共享资源：能被多个用户共同使用的资源2) 非共享资源：只能被单个用户使用的资源 为决策服务的资源1) 数据资源2) 模型资源3) 知识资源 数据：对客观事物的记录，用数字、文字、图形、图像、音频和视频等符号表示 数据的种类：1) 定类数据：依据事物的属性或性质进行分类的数据2) 定序数据：依据事物的某种关系排序或分级的数据3) 定距数据：对事物的属性进行精确的划分，明确指出事物的不同4) 定比数据：能进行比值、比率计算来对比事物差别的数据 数据库：大量的数据按一定结构形式组织起来，存放与计算机的存储设备中，需要时能够快速而有效的找出所需要的数据1) 数据共享2) 最小冗余3) 数据的独立性4) 数据由数据库管理系统统一管理和控制 数据仓库1) 支持决策分析2) 保存过去和现在的数据3) 数据不更新4) 对数据的操作是启发式的5) 操作需求是临时决定的6) 一个操作存取一个集合7) 数据时常冗余8) 决策分析需要过去和现在的数据 网络数据：网站、微博、微信、数字图书馆 即时数据能反映当前的潮流和新趋势 统计数据能建立起对全部数据的概括认识 数据的决策支持1) 用图表与曲线直观展示数据中的含义2) 数据是人决策的依据 决策：为了达到某一预定目标，在掌握充分、必要的数据的前提下，按照一定的评判标准，运用数学和逻辑的方法，对几种可能采取的方案作出合理的选择 模拟原理：建立一个与真实系统相关联的模型，通过模型来研究系统 模型：对于现实世界的事物、现象、过程或系统的简化描述 模型分类 物理模型（实体模型） 实物模型 类比模型 数学模型：用数学语言描述的模型 统计学模型：回归分析、聚类分析、判别分析、主成分分析 运筹学模型：线性规划与非线性规划、动态规划、网络理论、决策论、统筹法 经济数学模型：计量经济模型、投入产出模型、经济控制论模型、系统动力模型 预测模型：特尔斐法、回归法、时间序列法、增长曲线法 结构模型：反映系统的结构特点和因素关系的模型 仿真模型：通过计算机运行程序表达的模型 知识：人们对客观世界的规律性的认识 信息是对数据的解释，是加载在数据上的含义 知识类型1) 事实知识：关于事实方面的知识2) 原理知识：事物的客观原理和规律性的知识3) 技能知识：用于改变世界的知识4) 人力知识：知道谁能做哪些事的知识 显性知识（理论知识）：可以通过正常的语言方式传播的知识，以书本、报纸、杂志和计算机知识库等形式存储，便利交流、共享和转移 隐性知识（实践知识）：隐含的经验类知识。个人或组织经过长期积累而拥有的知识，通常不易用言语表达，传播给别人比较困难 知识资源可以不断地再生出来，并与原有的知识资源重新组合，扩大知识资源 数理逻辑：以命题逻辑和谓词逻辑为基础，研究命题、谓词及公式的真假值 简单命题是基本单位复合命题是由简单命题通过联结词组合而成的 联结词优先关系：与、或、非、蕴含、等价 在谓词逻辑中，把反映某些特定个体的概念称为个体词，而把反映个体所具有的性质或若干个体之间所具有的关系称为谓词 归结原理使用反证法来证明语句，即归结是结论的非导出已知语句的矛盾 产生式规则知识：if A than B，如果A成立则B成立 正向推理：逐条搜索规则库，对每一条规则的前提条件，检查事实库中是否存在。前提条件中各子项若在事实库中不是全部存在，则放弃该条规则；若在事实库中全部存在，则执行该条规则，把结论放入事实数据库中。反复循环执行上面过程，直至推出目标，并存入事实库中。 逆向推理：从目标开始，寻找以此目标为结论的规则，并对此规则的前提进行判断，若该规则的前提中某个子项是另一规则的结论时，再寻找以此结论的规则，重复以上过程，直到对某个规则的前提能够进行判断。按此规则的前提判断得出结论的判断，由此回溯上一规则的推理，一直回溯到目标的判断 规则栈：由规则编号、前提表和结论组成 智能：指知识的集合与智力的综合，是静态的知识和动态的智力综合所体现的一种能力 人的智能表现：1) 通过学习获取知识2) 利用知识进行逻辑思维（推理）3) 通过自然语言理解进行人机间交流4) 通过图像理解进行形象思维（联想）5) 利用启发式（经验）方法，解决随机变化问题6) 利用试验性（创新性）方法，解决新问题 智能行为：1) 获取知识2) 进行推理、联想或交流3) 解决随机问题或新问题 计算机编译工作1) 词法分析：完成符号串的识别形成单词2) 语法分析：完成单词组成句子 一个关系数据库是由大量事实组成的 演绎数据库是在现有的数据库中增加规则知识而形成的，不仅包含事实，也包含规则知识 区域：以人为主体的社会、经济、文化和生态环境的地域空间 区域发展：在一定的历史与自然条件下，人们进行产业活动、社会活动以及物质、文化生活的承前启后的历史发展过程 规划：制定未来一定时刻区域发展中所要完成的任务和要实现的目标，分析各种实现途径，经过综合评价，选择满意的实际方案 区域发展规划多层次内容1) 资源与生态层：为产业结构方面提供资源生态信息，为经济开发预测提供依据，为系统优化提供约束条件，为总体宏观控制提供基础2) 产业结构层：向资源生态提出要求，为总体经济发展提供参数，对资金、能源、劳力和科技等提出要求3) 经济能源层：对经济能源的研究，将为经济、生产提供需求量的约束4) 社会经济系统层：对社会经济的研究，将为总体控制提供参数，为产业结构提供需求量约束，它与资源生态系统之间形成反馈回路5) 区域总体控制层：对各层次提出优化设计要求和控制限度，在总体上进行协调，使各层次模型组合成总体的系统化模型群，建立总体设计方案。 决策支持系统的三部件结构 对话部件：人机交互系统，主要组合模型部件和数据部件形成DSS，并控制DSS运行 提供丰富多彩的显示和对话形式 菜单和窗口 命令语言和自然语言 多媒体和可视化技术 输入输出转换：转换成系统能够理解和执行的内部表示形式 控制决策支持系统的有效运行 数据部件：数据库管理系统和数据库 数据库存储的组织形式 关系模式 层次模式 网络模式 数据库管理系统的功能：数据库建立、删除、修改、维护、查询、浏览、排序、索引、统计、安全和通信等功能 数据库管理语言体系 数据库定义语言DDL：对数据库中数据的组成形式 数据库操作语言DML：对数据库中的数据进行操作 模型部件：模型库管理系统和模型库 模型库：用来存放模型 模型的表示：以某种计算机程序形式表示的 模型的动态形式：以程序形式运行，完成输入、输出、计算等处理 模型库管理系统：用于管理模型库 模型库的静态管理 模型字典的管理：采用数据库形式 模型文件管理：以文件形式存放，文件管理方式或操作系统直接管理 模型字典和模型文件的统一管理 模型的动态管理：运行管理，把模型看作一个活动的实体进行的动态管理 控制模型的运行：顺序、选择、循环 模型与数据库部件之间的接口：规定输入输出数据的来源及去向 模型库管理学院的语言体系 模型管理语言 模型操作语言 模型库管理系统的特定功能 决策支持系统的三系统结构 语言系统LS：把自然语言转化为机器能够理解的形式，以及把机器对问题的解答或者系统内部的其他信息转化为自然语言的相应形式向用户输出 数值计算语言（高级程序设计语言） 数据库语言 智能语言 知识系统KS：包含决策问题领域中的大量事实和相关知识，更多的是对问题领域的规律性描述 问题处理系统PPS：对描述的决策问题进行识别、分析和求解的过程 决策支持系统结构形式特点1) 强调语言系统：利用计算机语言来形式化描述决策问题和知识系统中的知识2) 强调问题处理系统的重要性：对语言系统所描述的决策问题进行分析和求解3) 强调知识系统的决策支持作用：定性辅助决策 三部件结构优点：1) 明确了三部件的结构以及它们之间的关系，便于决策支持系统的设计和关键技术的解决2) 便于和其他系统的区别 三部件结构不足：没有突出DSS的问题处理特性 三系统结构优点1) 突出了问题处理系统PPS的重要性2) 明确了语言系统LS在人机交互中的作用3) 强调了知识的作用：为决策支持系统向智能方面发展提出了宏观方向 三系统结构不足1) 在三系统结构中将数据和模型都统一放入知识系统中，忽略了数据库系统和模型库系统之间的区别和相互关系2) 三系统结构接近专家系统 DSS语言应是数值计算语言和数据库语言的综合，应具有调用模型运行能力、数据库存取能力、数值运算能力、数据处理能力和人机交互能力 数据库系统组成：1) 数据库：按一定结构组织在一起的相关数据的集合2) 数据库管理系统：一组能完成描述、管理和维护数据库等功能的程序系统3) 数据库管理员：负责设计、建立、维护和管理数据库4) 用户和应用程序：不同用户使用的数据以多种方式重叠 数据库系统的核心是数据库管理系统和数据库 数据库的重要特点是实现不同用户对数据库的共享 数据库管理系统是在操作系统的基础上对数据库进行统一的管理和控制 描述数据库：数据的逻辑结构、存储结构、语义信息和保密要求等 管理数据库 控制整个数据库系统的运行 执行数据检索、插入、删除和修改等操作 控制用户的并发性访问 检验数据的安全、保密与完整性 维护数据库 控制数据库初始数据的装入 记录工作日志 修改、更新数据库 重新组织数据库 恢复出现故障的数据库 数据通信：组织数据的传输 数据描述语言DDL及其解释程序：描述数据库数据的结构 数据操作语言DML及其解释程序：用户存储、检索和修改数据库中的数据 数据库查询1) 数据库列查询：选择数据库中的全部列或部分列的操作（投影）2) 条件查询：按指定的查询条件进行查询3) 组合查询：在多个属性中，对所需要的属性输入查询条件并进行多条件的任意组合查询 数据库中数据项之间的各种联系统称为数据项关系 表示运算关系的式子称为数据项表达式 数据项表达式计算特点1) 表达式的形式是任意变化的2) 表达式的计算是临时进行的 对所有项表达式的识别和解释执行的具体过程：先对表达式进行词法分析，得出表达式的组成单词。再进行语法分析，将单词构成句子。 编译程序能识别和执行任何表达式并进行计算 模型库系统由模型库和模型库管理系统所组成 模型在计算机中的实现主要是编制模型程序 模型程序是利用计算机语言来描述模型的算法过程 设计和编制计算机程序：先设计数据的存储结构，再用计算机语言设计算法，利用计算机语言的语句以及语句的组合形成计算机程序 计算机程序1) 源程序：用计算机语言编写，便于人阅读和修改2) 目标程序：机器语言，二进制指令代码形式，便于计算机操作和运算 由源程序转换成目标程序是通过编译程序来完成的 模型程序包：用户调用相应的模型程序，输入所需要的数据，就可在计算机计算模型的运行结果1) 模型程序包组织结构简单2) 各模型程序相对独立3) 每个模型程序的数据是各自封闭的4) 程序包是适合于模型间无关系的组织结构形式 模型库：将众多的模型按一定的结构形式组织起来，通过模型库管理系统对各个模型进行有效的管理和使用 模型库中的模型可以重复使用，即可以被不同系统所调用，避免了冗余 多种类型的模型不但扩充了辅助决策的能力，且不同模型组合能适应更广泛的决策问题 数学模型1) 方程形式：建立了模型中变量的相互关系，反映了事物的规律性，具有高度的概括性2) 算法形式：用一系列演算步骤表示模型的数学求解过程3) 程序形式：利用计算机语言按模型的算法步骤编制模型程序，在计算机中进行计算 数据处理：对数据库中的数据的处理，特点是处理的数据量很大 数据处理模型：完成一定任务的数据处理过程，一般采用数据库语言来编制数据处理过程的程序 图形图像模型：用于人机交互，使计算机更形象、更直观地将数据表现给用户1) 图形模型：以向量数据、绘图程序形式表示2) 图像模型：以点阵数据形式表示 报表：数据处理的主要输出手段 报表模型：以程序形式表示 报表程序一般用数据库语言编写，完成任意表格的生成以及数据项表达式的识别和求解等复杂运算 专家系统：以知识推理形式达到人类专家解决问题的能力 智能模型：以智能程序形式表示的 知识库是由大量的产生式规则知识和事实知识组成的，由知识库管理系统来管理 模型库的组织和存储：对大量模型统一组织和存储，建立一个字典库，用索引描述对应的模型文件 字典库：对模型的名称、编号和模型的文件等进行说明 作用 字典是模型文件的索引 字典便于对模型的分类 字典方便了对模型的查询和修改：模型算法、参数、有关模型说明 组织结构 文本形式：模型字典内容用文本形式进行存储 菜单形式：模型字典用一个层次式的菜单来表示 数据库形式：模型字典的内容按照关系数据库的组织形式存放 模型文件库：模型文件是模型的主体。源程序和目标程序是主要的模型文件 存储方式 直接在计算机操作系统管理下存储 建立子目录存储模型文件： 按模型分类建子目录 按模型文件的类别建立子目录 对模型文件的运行，一般应该通过模型字典库，沿着模型文件的存储路径找到具体的模型文件，再启动它运行 模型管理技术的发展阶段1) 程序文件：模型算法以程序文件形式存放在计算机的存储器中，由操作系统的文件管理系统统一管理2) 模型软件包：模型之间是相对独立的，模型使用的数据仍放在各自的数据文件中3) 模型库管理系统：有效地对模型进行存储、修改、查询和调用。模型相互独立，且可以互相组合 计算机建模： 在已有的数学模型结构中确定变量，并生成方程的系数 选择基础模型并将它们组合成大模型 顺序结构：模型间按前后顺序依次执行 选择结构：模型间按选择条件决定执行哪个模型 循环结构：一个模型或多个模型的多次反复执行 模型库管理系统的功能 模型的存储管理 模型的表示：与模型自身的特点有关 数学模型：以数值计算语言的程序形式表示，程序文件 数据处理模型：以数据库语言的程序形式表示，程序文件 图形图像模型：数据文件 报表模型：程序文件 模型存储组织结构(在开始时顺序存放输入的各种文件，以后就按空位存放新输入的文件 模型字典库：建立多个库，在一个库中存放同类型的模型文件名或经常在一起使用的模型文件名 模型文件库：模型的主体，具有文件的形式，按文件方式存储，应指明模型文件的存取路径 模型的查询和维护 查询：首先查询模型字典库，查到需要的模型名，再沿着该模型文件的存取路径查到相应的模型文件 维护：对模型的增加、插入和删除。先在模型字典中增加、插入和删除该模型的记录，再沿模型存取路径去增加、插入和删除模型文件 模型的运行管理 模型程序的输入和编译：源程序通过相应语言的编译系统编译成目标程序 模型的运行控制：让计算机执行模型的目标程序。 独立运行目标程序 DSS总控制程序中运行目标程序：调用执行语句 模型对数据的存取：利用语言和数据库之间的接口，使模型能存取数据库的数据，如ODBC、ADO等 支持模型的组合 模型间的结合：在模型的基础上进行顺序、选择和循环的组合 模型间数据的共享和传递 所有的共享数据应该都存放在数据库中，由数据库管理系统进行统一的管理 为了实现模型对数据的有效存取，需利用模型存取数据库的接口 模型库管理系统本身不进行模型的组合，而是能够支持模型的组合，模型的组合是通过决策问题的集成，即利用决策支持系统控制程序来完成的 模型库管理系统语言体系1) 模型管理语言MML：完成对模型的存储管理以及对模型的查询和维护2) 模型运行语言MRL：完成对单模型的调用、运行以及支持模型的组合运行3) 数据接口语言DIL：实现模型操作数据库的能力 人机交互：人与计算机需要进行相互间的通信 人机交互系统：实现人与计算机之间通信的硬、软件系统 菜单：由用户在一组项目表中选择一个认为最合适的选项并激活，系统执行 填表：用户在由一系列相关字段构成的表中输入相关的数据 命令语言：解释性语言，用于语法控制 屏幕显示： 数学和文字信息的显示 图形信息的显示 图像信息的显示 窗口：支持多任务相互切换 报表输出：报表头、表格框架。实际数据 多媒体：多种媒体的综合 综合部件1) 人机交互系统：实现人机对话和对DSS的控制2) 问题综合系统：在决策问题用DSS语言描述（形式化）后，完成对DSS问题的分析和求解 决策支持系统实质上是把模型库中的多个模型和它们分别使用的数据库中的数据集成起来，按决策问题的需求，构建多模型的组合方式，形成解决实际问题的方案，对方案编制程序就形成了该决策问题的决策支持系统程序。通过计算机对DSS程序计算，求出决策支持系统的解。当求出的解不能满足用户需求时，可以重新选择模型或修改参数或数据，以及改变多模型的组合方式，形成决策问题的新方案，重新进行计算，反复多次，最终得到理想的DSS解 综合部件功能 控制模型的运行：每个模型的运行需要存取不同数据库的数据并进行计算或处理 多模型的组合运行 输出数据处理：将输入数据转换成模型所需要的数据存储方式 输出数据处理：将模型计算出的数据转换成人们便于观看的方式 人机交互：用户通过交互信息来控制和改变模型的运行以及DSS的运行过程，DSS又通过多媒体和可视化技术表现系统运行情况和最终结果 数值计算和数据处理：两个模型之间的连接是通过数据来完成的 总控程序：由数值计算语言和数据库语言编制的，才能完成对多个模型的组合和对数据库中数据的存取和处理 模型组合技术 模型组合的基本方法 与：顺序结构 或：选择结构 闭包：循环结构 模型组合的嵌套方法：相互嵌套 模型组合程序的正确性：任何程序都可以用顺序结构、选择结构和循环结构表示出来 模型组合的程序设计：控制模型在综合部件，模型运行在模型部件，存取的数据在数据部件。在综合部件中由控制程序发出运行命令，并将运行权交给模型库中的模型进行运行。运行时调用数据库中的数据1，模型运行完成后将数据送入数据库中保存为数据2，并将控制权交回给综合部件中控制程序的“下步操作” 智能决策支持系统IDSS是DSS和AI技术相结合的系统1) 专家系统：利用大量的专门知识解决特定领域中的实际问题的计算机程序系统2) 神经网络：利用神经元的信息传播的数学模型进行数值计算，来完成对样本的学习和对实例的应用3) 遗传算法：利用模拟生物遗传过程的数学模型进行群体优化遗传的算法4) 机器学习：让计算机模拟和实现人类的学习，获取解决问题的知识5) 自然语言理解：让计算机理解和处理人类交流所使用的自然语言 智能系统：用人工智能技术完成的系统 IDSS把定性和定量结合起来，加强辅助决策的效果 IDSS中DSS和ES的结合1) DSS和ES的总体结合2) 知识库KB和模型库MB的结合3) 静态数据库和动态数据库的结合 IDSS的集成形式1) DSS和ES并重的IDSS结构：将DSS的控制系统功能进行扩充，增加对专家系统的调用组合能力2) DSS为主体的IDSS结构：以定量分析为主体，结合定性分析解决问题3) ES为主体的IDSS结构 专家系统：利用大量的专家知识，运用知识推理的方法来解决特定领域中的实际问题 知识处理特点：1) 知识包括事实和规则（状态转变过程）2) 适合于符号处理3) 推理过程是不固定形式的4) 能得出未知的事实 专家系统的核心是知识库和推理机 知识获取：把专家的知识按一定的知识表示形式输入到专家系统的知识库中 产生式规则的推理机=搜索+匹配（假言推理） 产生式规则知识一般表示为if A then B（如果A成立则B成立） 产生式规则知识的特点1) 相同的条件可以得出不同的结论2) 相同的结论可以由不同的条件得到3) 条件之间可以是“与”和“或”连接4) 一条规则中的结论可以是另一条规则中的条件 不确定性推理主要研究由于知识的不确定性，在推理过程中引起结论的不确定性的传播情况1) 事实的不确定性：用可信度CF表示2) 规则的不确定性（经验性规则）3) 推理的不确定性（利用事实和规则结合起来得出结论） 一般规定推理过程中的阙值为0.2，当CF小于0.2时，置CF=0；当CF大于或大于0.2时，CF才有意义 元知识：关于知识的知识。对领域知识描述、说明和处理的知识知识：1) 领域知识：特定领域的知识。关于具体领域的事实、规则、方程和实验对象等知识2) 元知识：说明如何运用领域知识的知识 元知识是人类认识活动（记忆、推理、理解和学习）的核心 元知识的获取1) 从领域专家获取2) 知识工程师在开发实际系统过程中获取3) 从系统的运行结果中获取 元知识的分类1) 指导规则的选择2) 记录与领域知识有关的事实3) 规则的论证4) 检查规则中的错误5) 描述领域知识表示的结构6) 论证系统的体系结构7) 辅助优化系统8) 说明系统的能力 元事实类型1) 目标2) 对叶节点变量向用户的提问3) 变量的多值说明4) 变量的合法值 元知识的应用1) 马尾松毛虫防治决策专家系统2) 黑板结构形式的专家系统3) 利用元知识完成对领域知识的语法、语义和一致性检查&nbsp;&nbsp;&nbsp;&nbsp;a) 检查语法错误&nbsp;&nbsp;&nbsp;&nbsp;b) 检查语义错误&nbsp;&nbsp;&nbsp;&nbsp;c) 一致性和完备性检验 知识推理1) 规则分解：将OR连接规则分解为只含AND连接规则2) 建立规则栈和事实数据库3) 逆向推理与解释过程4) 正确路径的解释 神经元是组成人脑的最基本单元 从信息处理功能看，神经元是一个信息多输入单输出的结构 神经网络专家系统：神经网络和专家系统的结合 神经元网络特点：1) 神经元网络知识库体现在神经元之间的连接权值上，以矩阵形式存储2) 神经元网络的推理机是基于神经元的信息处理过程，属于计算智能范畴3) 神经元网络有成熟的学习算法4) 容错性好 神经元网络专家系统组成 开发环境 确定系统框架 样本知识库（规则） 神经元学习 网络权值知识库 运行环境 实际问题参数 输入模式的转换 神经网络的知识推理机制 网络权值知识库 输出模式的转换 神经元网络设计 确定系统框架 神经网络层次和神经元个数 神经元的连接和作用函数 样本知识库（规则） 学习算法 感知机模型：采用delta规则 反向传播模型：采用误差反向传播方法 神经网络的推理机和知识库 输入模式转换：将文字概念转换成数值 实际输入概念集 神经元输入数值集 输出模式转换：将数值转换为文字概念 知识是定性分析的主要资源 数学模型是定量分析的主要资源 预测模型：对未来的发展作出判断 定性预测模型：利用专家知识或个人经验而不是利用数据进行预测。1) 德尔菲法：汇总多个专家意见，再反馈给专家，多次反复，最后获得趋于一致的意见的方法2) 情景预测法：对预测的主题，分析其未来可能发生的多种交叉情景，在引入影响因素后，通过分析进行预测3) 主观概率法 定量预测模型：依据大量的历史数据或相关变量数据资料建立数学模型进行预测 时间序列预测模型：利用目标的历史数据进行引申外推来预测目标的未来发展趋势 移动平滑法：目标变量既不快速增长也不快速下降，且不存在季节性因素 加权移动平滑法：历史各期的需求量对未来的需求量的作用不一样时，给各期限内的每个变量值以不同的权重 指数平滑法：近期的影响比远期大，给近期的权数大，远期的权数小 生长曲线法：数据在发生阶段变化速度较为缓慢，在发展阶段变化速度加快，在成熟阶段变化速度又趋缓慢 因果关系预测模型：利用目标变量同其他变量之间的因果关系进行预测 回归分析法 经济计量模型 投入产出模型 灰色系统模型 数据拟合：利用大量测量数据去求得自变量和因变量的一个近似公式 公式发现系统FDD：从大量实验数据中发现经验公式，进行任意函数的任意组合，完成对自然规律和经验规律的发现，即建立数据之间的数学模型 FDD设计思想：利用人工智能启发式搜索来寻找具有最佳线性逼近关系的函数原型，并结合曲线拟合技术及可视化技术来寻找数据间的规律性 函数原型1) 基本原型：由初等函数组成2) 组合原型：由初等函数的初等运算组合而成 FDD系统中的规则知识1) 发现常数2) 两变量的初等运算组合3) 变量取初等函数4) 某变量取某一初等函数与另一变量的线性组合5) 两变量取初等函数的线性组合6) 对某一变量xi取初等函数，另一变量xi取两个xi的初等函数进行线性组合7) 建立某变量的某种初等函数为新变量8) 建立新变量 数据仓库的提出是以关系数据库、并行处理和分布式技术为基础的信息新技术 数据仓库是面向主题的、集成的、稳定的、不同时间的数据集合，用于支持经营管理中的决策制定过程 数据仓库是一种管理技术，旨在通过通畅、合理、全面的信息管理，达到有效的决策支持 数据仓库是明确为决策支持服务的 数据库是为事务处理服务的 数据仓库特点1) 数据仓库是面向主题的：主题是数据归类的标准，每一个主题基本对应一个宏观的分析领域2) 数据仓库是集成的：对不同的数据来源进行数据结构和编码的统一，以消除原始数据中的所有矛盾之处3) 数据仓库是稳定的：数据经集成进入数据仓库后是极少或根本不更新的4) 数据仓库是随时间变化的：数据时限为5~10年5) 数据仓库中的数据量很大：数据量为10GB级。综合数据占2/3，原始数据占1/36) 数据仓库的软硬件要求较高&nbsp;&nbsp;&nbsp;&nbsp;a) 一个巨大的硬件平台&nbsp;&nbsp;&nbsp;&nbsp;b) 一个并行的数据库系统 支持决策的数据仓库：以决策主题需求集成多个数据库，重新组织数据结构，统一规范编码，使其有效地完成各种决策分析 从数据库到数据仓库的演变1) 数据库用于事务处理，数据仓库用于决策分析2) 数据库保持事务处理的当前状态，数据仓库既保存过去的数据又保存当前的数据3) 数据仓库的数据是大量数据库的集成4) 对数据库的操作比较明确，操作数据量小 数据仓库的结构组成1) 当前基本数据：最近时期的业务数据，是数据仓库用户最感兴趣的部分，数据量大2) 历史基本数据3) 轻度综合数据：从当前基本数据中提取出来的4) 高度综合数据：数据精练，是一种准决策数据5) 元数据 整个数据仓库的组织结构是由元数据来组织的 元数据在数据仓库的用途1) 数据仓库的目录2) 数据从业务环境向数据仓库环境转换的目录3) 从当前基本数据到轻度综合数据，轻度综合数据到高度综合数据的综合说明 数据集市：一种更小、更集中的数据仓库，为公司提供分析商业数据的一条廉价途径。主要针对具体部门级的应用 多个数据集市简单合并不能成为数据仓库1) 各数据集市之间对详细数据和历史数据的存储存在大量冗余2) 同一个问题在不同的数据集市中的查询结果可能不一致，甚至相互矛盾3) 各数据集市之间以及与源数据库系统之间难以管理 数据集市的特性1) 规模小2) 面向特定的应用3) 面向部门4) 由业务部门定义、设计和开发5) 由业务部门管理和维护6) 快速实现7) 购买较便宜8) 投资快速收回9) 工具集的紧密集成10) 更详细的、预先存在的数据仓库的摘要子集11) 可升级到完整的数据仓库 数据集市类型1) 从属的数据集市：数据直接来自中央的数据仓库2) 独立的数据集市：数据直接来源于各生产系统 数据集市与数据仓库的差别1) 数据仓库基于整个企业，数据集市基于部门2) 部门的主体与企业的主题之间可能存在关联，也可能不存在关联3) 数据集市的数据组织一般采用星形模型。大型数据仓库的数据组织则不同 数据仓库的逻辑数据模型是多维结构的数据视图，也称为多维数据模型1) 星形模型：由事实表以及多个维表所组成&nbsp;&nbsp;&nbsp;&nbsp;a) 存取数据速度快，由于针对各个维作了大量的预处理&nbsp;&nbsp;&nbsp;&nbsp;b) 非规范化的，以增加存储空间为代价，提高了多维数据的查询速度2) 雪花模型：增加了用户必须处理的表的数量，增加了某些查询的复杂性3) 星网模型：多个相关的星形模型通过相同的维表连接起来形成网状结构4) 第三范式：事实表和维表的属性集中在同一个数据库的一个表或多个表中，按第三范式组织数据，减少了维表中的主键和不必要的属性 元数据在数据仓库中有着举足轻重的作用，它不仅定义了数据仓库有什么，指明了数据仓库中的内容和位置，刻画了数据的抽取和转换前后的数据，存储了与数据仓库主题有关的各种商业信息，而是整个数据仓库的运行都是基于元数据的，如数据的修改、跟踪、抽取、装入和综合 元数据是关于数据的数据，是描述和使用数据仓库的数据 关于数据源的元数据 数据源中所有的物理数据结构，包括所有的数据项及数据类型 所有数据项的业务定义 每个数据项的有效值 关于数据模型的元数据 I/O对象：支持数据仓库I/O操作的各种对象 关系：两个I/O对象之间的关联 关系成员：描述每个关系中两个I/O对象的具体角色、关系度及约束条件 关系关键字：指明建立每个关系的相应对象的关键字 关于数据仓库映射的元数据：反映数据仓库中的数据项是从哪个特定的数据源填充的，经过哪些转换以及变化和加载过程 关于数据仓库使用的元数据 如何按主题查看数据仓库的内容 元数据提供已有的可重复利用的查询语言信息 抽取步骤1) 获取：从外部或内部源数据系统获取对决策支持系统用户有用的数据2) 过滤：过滤掉不需要的内容3) 验证：从用户的角度验证数据的质量4) 融合：把本次抽取的数据与数据仓库中的数据进行融合5) 综合：对数据进行综合，生产综合级数据6) 装载：把新数据装入数据仓库中 数据仓库系统： 数据仓库 仓库管理 数据建模：建立数据仓库的数据模型 数据只供决策分析用 增加了时间属性的数据增加了一些导出数据，如综合数据 数据抽取、转换和装载：首先在源数据中抽取数据，再按数据仓库的逻辑数据模型的要求进行数据转换，最后按物理数据模型的要求装载到数据仓库中去 元数据：指导数据的抽取、转换和装载工作 系统管理 数据管理：为适应竞争的变化业务需求更新数据，清理脏数据，删除休眠数据等 性能监控：搜集和分析系统性能的信息，确定系统是否达到了所确定的服务水平 存储器管理：使数据仓库的存储器能够适应数据量的增长需求，实现快速检索 安全管理：保证应用程序的安全以及数据库访问的安全 分析工具：实现从数据仓库中提供辅助决策的信息，完成决策支持系统的各种要求 查询工具：对分析工具的查询。以图形化方式展示数据，可以帮助用户了解数据的结构、关系以及动态性 多维数据分析工具：通过对多维数据进行快速、一致和交互性的存取，以便用户对数据进行深入的分析和观察 数据挖掘工具：从大量数据中挖掘具有规律性知识，需要利用数据挖掘中的各种不同算法 客户/服务器工具：以服务器形式在网络环境下提供服务，能对多个客户同时提供服务 OLAP服务器用于加强和规范化决策支持的服务工作，集中和简化了数据仓库服务器的部分工作，即OLAP服务器从数据仓库服务器中抽取数据，在OLAP服务器中转换成客户端用户要求的多维视图，并进行多维数据分析，将分析结果传送给客户端 联机分析处理OLAP使企业的决策者能从多方面和多角度以多维的形式来观察企业的状态和了解企业的变化，达到支持决策的目的 联机事务处理OLTP是在网络环境下面向交易的事务处理，利用计算机网络技术，以快速的事务响应和频繁的数据修改为特征，使用户能够快速地处理具体的业务 OLAP是一种软件技术，使分析人员能够迅速、一致、交互地从各个方面观察信息，以达到深入理解数据的目的 OLAP是共享多维信息的快速分析1) 快速性：在5秒内对用户的大部分分析要求做出反应2) 可分析性：处理与应用有关的任何逻辑分析和统计分析3) 多维性：提供对数据分析的多维视图和分析4) 信息性：及时获取信息，并且管理大容量的信息 OLAP准则1) 多维概念视图：切片、切块、旋转、钻取2) 透明性3) 可访问性4) 一致稳定的报表5) 客户/服务器体系结构：服务器组合数据，客户端应用逻辑及用户界面6) 维的等同性7) 动态的稀疏矩阵处理8) 多用户支持能力：并发控制、数据完整性、安全性9) 非限定的跨维操作10) 直观的数据操作11) 灵活的报表生成12) 不受限制的维和聚集层次 OLAP基本术语1) 变量：数据的实际含义，描述数据“是什么”，一个数值度量指标2) 维：人们观察数据的特定角度3) 维的层次：存在细节程度不同的多个描述方面4) 维成员：由各个不同维层次的取值组合而成5) 多维数组6) 数据单元：多维数组的取值 OLAP的数据模型1) 基于多维数据库的OLAP—-MOLAP以多维方式组织数据，即以维作为坐标系，采用类似于数组的形式存储数据2) 基于关系数据库的OLAP—-ROLAP通过关系数据库实现多维查询时，通过维表的主码对事实表和每一个维表做连接操作，一次查询就可以得到数据的具体值以及对数据的多维描述3) 网络OLAP—-WOLAP4) 混合OLAP—-HOLAP MOLAP与ROLAP的区别1) 数据存取速度2) 数据存储的容量3) 多维计算的能力4) 对维度变化的适应性5) 对数据变化的适应性6) 对软硬件平台的适应性 多维数据分析操作 切片：选定多维数组的一个二维子集的操作。在某两个维上取一定区间的维成员或全部维成员，而在其余的维上选定一个维成员的操作 切块 在多维数组的某一个维上选定某一区间的维成员的操作 选定多维数组的一个三维子集的操作 钻取 向下钻取：使用户在多层数据中能通过导航信息而获得更多的细节性数据 向上钻取：获取的是概括性数据 旋转：得到不同视角的数据 广义OLAP功能 基本代理操作：用于当系统出于某种特殊状态时提醒分析员 示警报告：定义一些条件，当条件满足，系统提醒分析员去分析 时间报告：按日历和时钟提醒分析员 异常报告：当超出边界条件时提醒分析员 商业分析模型 分销渠道的分析模型 客户利润贡献度模型 客户关系（信用）优化模型 风险评估模型 数据立方体：数据仓库结构图中的综合数据层（轻度和高度），在所有可能组合的维上进行分组聚集运算的总和 多维数据集的属性1) 维属性：观察数据对象的角度2) 度量属性：反映 数据对象的特征 典型的压缩型数据立方体1) 冰山立方体：仅聚集高于（或低于）某个阙值的子立方体2) 紧凑数据立方体：保持数据立方体的钻取操作的语义3) 外壳片段立方体：给定高维数据集，将维划分为互不相交的维片段，并且将每个片段转换为倒排索引，然后构造外壳片段立方体4) 流式数据立方体：不同层次的异常模式、兴趣模式、变化趋势 战略信息:1) 给出销售量最好的产品名单2) 找出出现问题的地区3) 追踪查找出现问题的原因（向下钻取）4) 对比其他的数据（横向钻取）5) 显示最大的利润6) 当一个地区的销售低于目标值时提出警告信息 数据仓库的查询环境特点：1) 能向用户提供查询数据、公式表示和结果显示等功能2) 由元数据来引导查询过程3) 用户能够轻松的浏览数据结构4) 信息是用户自己主动索取的，而不是数据仓库强加给他们的5) 查询环境必须灵活地适应不同类型的用户 查询服务的具体表现1) 查询定义：确保数据仓库用户能够很容易地将商业需求转换成适当的查询语句2) 查询简化a) 让数据和查询公式的复杂性对用户透明b) 让用户能够简单的查看数据的结构和属性c) 使组合表格和结构简单易用3) 查询重建：对用户输入的查询进行分解并重新塑造，使其能更高效地工作4) 导航的简单性：用户使用元数据在数据仓库中浏览数据，并能很容易地用商业术语导航5) 查询执行：使用户能够在没有任何IT人员的帮助下提高并执行查询6) 结果显示：以各种方法显示查询结果7) 对聚合的了解：将查询重新定义到聚合表格上，以加快检索速度 数据仓库报表环境内容1) 预格式化报表2) 参数驱动的预定义报表3) 简单的报表开发4) 公布和订阅5) 传递选项6) 多数据操作选项7) 多种展示方式选项 数据仓库中存放了大量的历史数据，从历史数据中找出变化规律，可以用来预测未来 聚类模型：利用距离的远近，把没有分类的大量实例聚成不同的类 分类模型：在已经有了类别后，分别对各个不同类进行类特征的描述。通过对各类实例的学习，得到各类的判别知识，利用这些知识可以判别新实例属于哪个类别 动态数据仓库：实时数据仓库，用于支持战术型决策，即实时决策，有效地解决当前的实际问题。1) 主要功能：缩短重要业务决策及其实施之间的时间。2) 主导思想：提高业务决策的速度和准确性3) 目标：达到近乎实时决策，生成最大价值 实时决策：为现场提供信息，实时支持决策 自动决策：由事件触发，利用动态数据库自动决策，达到“希望发生什么” 知识发现KDD：从数据中发现有用知识的整个过程。 KDD过程：从数据集中识别出有效的、新颖的、潜在有用的以及最终可理解的模式的高级处理过程 数据集：事实F（数据库元组）的集合模式：用语言L表示的表达式E KDD过程（不断反馈的过程）1) 数据准备&nbsq;&nbsq;&nbsq;&nbsq;a) 数据选择：确定发现任务的操作对象&nbsq;&nbsq;&nbsq;&nbsq;b) 数据预处理：消除噪声、推导计算缺值数据、消除重复记录&nbsq;&nbsq;&nbsq;&nbsq;c) 数据转换：完成数据类型转换，进行属性约简2) 数据挖掘：确定挖掘任务/目的，决定挖掘算法3) 结果评价 数据挖掘方法和技术 信息论方法：利用信息论的原理建立决策树 ID3等方法：利用信息论中互信息寻找数据库中具有最大信息量的字段，建立决策树的一个结点，再根据字段的不同取值建立树的分支，再由每个分枝的数据子集重复建立树的下层结点和分枝的过程 IDLE方法：利用信息论中的信道容量，寻找数据库中信息量从大到小的多个字段的取值建立决策规则树的一个节点，根据该结点中指定字段取值的权值之和与两个阙值比较，建立左中右3个分枝，在各分支子集中重复建立树结点和分枝的过程 集合论方法 粗糙集方法：在数据库中将行元素看成对象，列元素看成属性 关联规则挖掘：在交易事务数据库中挖掘出不同项（商品）集的关联关系 覆盖正例排斥反例方法：利用覆盖所有正例、排斥所有反例的思想来寻找规则 概念树：数据库中记录的属性字段按归类方式进行合并而建立起来的层次结构 仿生物技术的神经网络方法 前馈式网络 反馈式网络 自组织网络 仿生物技术的遗传算法：模拟生物进化过程的数学算法 繁殖（选择） 交叉（重组） 变异（突变） 数值数据的公式发现 物理定律发现系统BACON：对数据项进行初等数学运算形成组合数据项 经验公式发现系统FDD 可视化技术：图形显示技术，基本工作是提取几何图元绘制显示和演放 数据可视化：创建二维或三维业务数据集的图表，使得用户能够理解业务数据，从而提升知识和洞察力 可视化数据挖掘：创建可视化的数据挖掘模型，利用这些模型发现业务数据集中存在的模式，从而辅助决策支持及预测新的商机 可视化绘制方法：把隐藏于大容量数据集中的物理信息转化为有组织结构的视觉信号集合 几何法 彩色法 多媒体法 光学法 数据挖掘的知识表示1) 规则：由前提条件和结论两部分组成2) 决策树3) 知识基（浓缩数据）：通过属性约简方法能压缩数据库的属性和相应的元组，最后得到的浓缩数据4) 网络权值：网络连接权值和结点的阙值5) 公式：找出各种变量间的相互关系，用公式表示出来6) 案例：利用以前案例中解决问题的方法或者处理的结果作为参考并进行适当的修改，以解决当前的新问题（&lt;问题描述，解描述，效果描述&gt;） 数据挖掘任务 关联分析 支持度：表示该规则所代表的事例占全部事例的百分比 可信度：表示该规则所代表事例占满足前提条件事例的百分比 时序模式：通过时间序列搜索出重复发生概率较高的模式 聚类：在没有类的数据中按“距离”概念聚集成若干类 统计分析方法：基于距离的聚类 机器学习方法：无导师的学习 神经网络：无监督学习方法 分类：在聚类的基础上，对已确定的类找出该类别的概念描述，代表了这类数据的整体信息，即该类的内涵描述 特征描述：对类中对象的共同特征的描述 辨别性描述：对两个或多个类之间的区别描述 偏差检测：寻找观察结果与参照之间的差别 分类中的反常反例 模式的例外 观察结果对模型预测的偏差 量值随时间的变化 预测：利用历史数据找出变化规律，建立模型，并用此模型来预测未来数据的种类和特征等 判别分类方法好坏：1) 预测准确度：对非样本数据的判别准确度2) 计算复杂度：方法实现时对时间和空间的复杂度3) 模式的简洁度：在同样效果情况下，希望决策树小或规则少 决策树：用样本属性作为结点，用属性取值作为分枝的树结构1) 根节点：所有样本中信息量最大的属性2) 中间节点：该结点为根的子树所包含的样本子集中信息量最大的属性3) 叶节点：样本的类别值 决策树用于对新样本的分类，即通过决策树对新样本属性值的测试，从树的根节点开始，按照样本属性的取值，逐渐沿着决策树向下，直到树的叶节点，该叶节点表示的类别就是新样本的类别 互信息：信息增益，作为特征（属性）判别能力的度量 在一个实体世界中，每个实体用多个特征来描述。每个特征限于在一个离散集中取互斥的值 ID3算法 主算法 从训练集中随机选择一个既含正例又含反例的子集（窗口） 用建树算法对当前窗口形成一棵决策树 对训练集（除窗口）中的例子用所得决策树进行类别判定，找出错判的例子 若存在错判的例子，把它们插入窗口，转（2），否则结束 建树算法 对当前的例集，计算各特征的互信息 选择互信息最大的特征Ak作为树（子树）的根节点 把在Ak处取值相同的例子归于同一子集，该取值作为树的分枝 对既含正例又含反例的子集，递归调用建树算法 若子集只包含正例或反例，对应分枝标上P或N 返回（4），逐一检查未处理的子集，直到所有子集都标记了类别（P或N）为止 ID3优点：算法的基础理论清晰，使得算法较简单 ID3缺点：1) 互信息的计算依赖于特征取值的数目较多的特征2) 用互信息作为特征选择量存在一个假设，即训练例集中的正反例的比例应与实际问题领域里正反例的比例相同。一般不保证相同3) 建树时，每个结点仅含一个特征，特征间的相关性强调不够4) 对噪声比较敏感5) 当训练集增加时，ID3的决策树会随之变化。对渐进学习是不方便的 C4.51) 用信息增益率来选择属性，偏向选择取值多的属性2) 在树构造过程中或者构造完成之后进行剪枝3) 能够完成对连续属性的离散化处理4) 能够对于不完整的数据进行处理5) C4.5采用的知识表示形式为决策树，并最终可以形成产生式规则 IBLE算法1) 预处理2) 建规则算法3) 建决策树算法4) 类别判定算法&nbsq;&nbsq;&nbsq;&nbsq;a) 置根节点为当前节点&nbsq;&nbsq;&nbsq;&nbsq;b) 用当前节点中的规则对E进行判定&nbsq;&nbsq;&nbsq;&nbsq;c) 输出判别结果，结束 IBLE的预测正确率比ID3高1) 信道容量不依赖于正反例比例，而互信息依赖。2) IBLE在建树过程中每次循环选择多个特征构成规则，变量间的相关性得到较好的体现，而ID3不能较好的体现特征间的相关性 IBLE特点1) 决策规则树中的规则在表示和内容上与专家知识具有较高的一致性2) 在训练集中，若正反例数目变化较大，IBLE得到的规则具有较好的稳定性 基于数据仓库的新决策支持系统DW-DSS：数据仓库和联机分析处理及数据挖掘结合的决策支持系统（DW+OLAP+DM）,通过多维数据分析和数据挖掘以获取辅助决策的信息和知识。 在多维数据分析的切片和切块中，通过维成员之间的对比发现问题；利用多维数据分析的钻取功能找到问题的原因，为决策者下一步的规划提供依据；在多维数据中，抽取和组合形成一个二维表，利用数据挖掘的方法获取辅助决策的知识 沃尔玛公司进行的决策支持分析1) 商品分组布局2) 降低库存成本3) 了解销售全局4) 市场分析5) 趋势分析 开发一个实际的智能决策支持系统的关键技术 模型库系统的设计和实现 模型库的组织结构 模型库管理系统的功能 模型库语言等方面的设计和实现 部件接口：各部件之间的联系通过接口来完成 对数据部件的数据的存取 对模型部件的模型的调用和运行 对知识部件的知识的推理 系统综合集成：根据实际决策问题的要求，通过集成语言完成对各部件的有机综合，形成一个完整的系统 新决策支持系统的特点是从数据资源中获取辅助决策信息和知识 数据仓库的关键技术 管理大量数据：历史数据、细节和汇总数据、元数据 数据的高效装入和数据压缩 装入数据：i. 一个语言接口一次装入一条记录ii. 一个程序一次全都装入 数据压缩 存储介质的管理：一个满载的数据仓库应该放在多种存储层次上 元数据管理 数据仓库表的结构和属性的说明 数据仓库的源数据说明 源数据到数据仓库的映射 访问数据仓库数据的说明 高效索引 位索引 多级索引 将部分或全部索引装入内存 当被索引的数据的次序允许压缩时，对索引项进行压缩 数据立方体和数据仓库 数据立方体提供了一种信息系统结构，使得对数据的访问非常灵活，可以用多种方法对数据进行切片和分隔，从汇总数据钻取到细节数据 数据要定期从数据仓库中导入数据立方体 数据仓库开发中的一些错误观念1) 未能理解数据仓库的应用价值2) 对数据仓库规模的估计模糊 基于数据仓库的决策支持系统是针对实际问题，利用分析工具或者编制程序，采用一种或多种组合的决策支持能力，对数据仓库中的数据进行多维分析，从而掌握企业的经营现状，找出现状的原因，并预测未来的发展趋势，弥补经验和直觉的不足，协助企业制定决策，增强竞争优势 数据仓库系统的用户是信息使用者，信息使用者以一种可预测的、重复性的方式来使用数据仓库平台 数据仓库的信息使用者对数据仓库使用特征1) 在搜索数据前，已经知道对数据的需求2) 有规律地访问数据3) 知道自己正在寻找什么4) 访问的数据量较小5) 访问可预测的数据6) 经常处理以前访问的数据7) 经常访问各类综合数据8) 较少访问最近的详细数据9) 能发现少量的精华10) 最佳的数据结构是星形模型 决策支持系统的用户是探索者，有一个完全不可预测的、非重复性的数据使用模式 探索者对数据仓库使用特征1) 不规律地访问数据2) 只知道总体的需求3) 有规律地访问最近的详细数据4) 查看数据关系而不是数据值5) 利用数据挖掘工具和统计分析工具进行探索6) 最佳的数据结构是关系结构 探索者需完成工作 概括分析：被用来评定是否有充分的样本数据量 分析数据仓库中数据的外部特征 分析数据的完整性和准确性（质量） 抽取：从数据仓库中抽取指定的数据，并用分析所需要的格式来组织这些数据，将这些数据送入临时仓库中，用来支持探索者的分析活动 建模：开发一种描述实体特征的模型的过程 客户分段 欺诈检测 渠道响应 信用风险客户的价值 推销响应 分类：依据实体与模型的匹配来分类数据仓库的其他实体 探索者帮助指导战略商务的处理，而信息使用者是从战术上监控这些决策的效果 传统决策支持系统特点：1) 用模型和模型的组合来辅助决策2) 用知识推理进行定性分析 新决策支持系统特点1) 数据仓库和联机分析处理的数据分析方式是多维数据2) 数据仓库是为决策分析服务的3) 联机分析处理提供多维分析手段4) 数据挖掘是从数据中挖掘出隐藏知识 数据仓库强调的是数据驱动，即以数据为基础，将传统的数据库系统的数据面向应用的需求转变到数据仓库的数据面向分析的需求，向用户提供更准确和更有用的决策信息 综合决策支持系统S-DSS体系结构1) 模型库系统和数据库系统的结合：基本决策支持系统的基础，为决策问题提供定量分析（模型计算）的辅助决策信息2) 数据仓库和OLAP：从数据仓库中提取综合数据和信息，反映了大量数据的内在本质3) 知识库与推理机和数据挖掘的结合：利用知识资源达到定型分析辅助决策 数据、模型和知识等都是决策资源，它们是决策支持系统的基础 决策支持系统：按决策问题的需要，利用数据、模型和知识等决策资源，组合形成解决问题的多个方案，通过计算获得辅助决策的依据，达到支持科学决策的计算机程序系统 基本DSS：1智能DSS：13新决策DSS：23综合DSS：123 决策支持系统开发的主要步骤 决策支持系统分析 确定实际决策问题目标 对系统分析进行论证 决策支持系统初步设计：将决策问题分解成多个子问题以及综合 决策支持系统详细设计： 数据设计数据文件设计数据库设计 模型设计模型算法设计模型库设计模型库管理系统设计 知识设计知识表示设计推理机设计知识库管理系统设计 综合设计：对各个子问题的综合控制设计 各部件编制程序 建立数据库和数据库管理系统 编制模型程序，建立模型库和模型库管理系统 建立知识库，编制推理机程序以及完成知识库管理系统 编制综合控制程序，由总控程序控制模型的运行和组合，对知识的推理，对数据库数据的存取和计算等处理，并设置人机交互等 将部件集成为决策支持系统，包括解决部件接口问题，由总控程序的运行实现对模型部件、知识部件和数据部件的集成，形成决策支持系统 决策目标：在一定的环境和条件下，在预测的基础上所要达到的结果1) 可计量，能代表一定水平2) 规定其时间限制3) 能确定其责任4) 具有发展的方向性 数据设计需考虑1) 数据提供辅助决策的要求2) 为模型计算提供所需要的数据 模型程序文件：1) 源程序文件2) 目标程序文件3) 模型数据说明文件：对模型的变量数据以及输入输出数据进行说明4) 模型说明文件：对模型的功能、模型的数学方程以及解法进行说明 编制程序阶段：1) 数据部件的处理：实际数据库和数据库管理系统的统一2) 模型部件的处理：模型库和模型库管理系统的统一3) 知识部件的处理：建立知识库、编制推理机程序和开发知识库管理系统4) 综合部件的处理：按照总控详细流程图，选用合适的计算机语言，或者自行设计DSS来编制程序 DSS集成1) 接口问题&nbsq;&nbsq;&nbsq;&nbsq;a) 模型对数据库中数据的存取接口&nbsq;&nbsq;&nbsq;&nbsq;b) 总控程序对数据库的接口问题&nbsq;&nbsq;&nbsq;&nbsq;c) 总控程序对模型的调用&nbsq;&nbsq;&nbsq;&nbsq;d) 总控程序对知识推理的接口2) 集成问题：把4个部件有机的结合起来3) 利用DSS总控程序集成各部件，形成DSS DSS运行结构设计1) 总控程序的设计&nbsq;&nbsq;&nbsq;&nbsq;a) 对每个模型的控制运行&nbsq;&nbsq;&nbsq;&nbsq;b) 模型间数据的加工&nbsq;&nbsq;&nbsq;&nbsq;c) 对知识推理的控制&nbsq;&nbsq;&nbsq;&nbsq;d) 人机交互设计2) 模型程序的设计3) 推理机程序的设计 建模技术1) 建模：用模型来描述系统的因果关系或相互关系2) 建立模型步骤&nbsq;&nbsq;&nbsq;&nbsq;a) 建立模型的数学结构：模型中变量之间的方程形式&nbsq;&nbsq;&nbsq;&nbsq;b) 确定模型的参数：变量数目、方程个数、变量系数3) DSS的建模技术：在已知数学结构的基础上建立实际问题的数学模型/如何选择多个模型组合形成解决实际问题的方案 决策支持系统开发技术级别1) 专用DSS：实际问题的决策支持系统。一种基于计算机的信息系统，利用计算机语言，针对实际决策问题。按决策支持系统的结构，编制出程序并计算得出结果，支持一个或一群决策者解决实际的决策问题2) DSS工具：已经开发出的模型库管理系统和知识库管理系统，其中包含了比较通用的大量标准模型和通用知识，可以被用户用来组合多模型和利用知识进行推理 决策支持系统开发方法 系统开发的生命周期法 系统分析 系统设计 系统编程调试 系统实现 快速原型法：把生命周期的4个阶段合并为一体，利用DSS工具，在很短的时间内开发出一个初始的可用的原型系统，在使用中根据用户的反映进行评价、修改和扩充，经过几轮循环后，得到一个相对稳定的系统 主要任务是按决策问题处理过程，快速生成对多模型的组合、知识推理以及大量数据库数据的存取并进行集成的决策支持系统 根据系统的需求能迅速的产生出系统的原型，该原型能表现出系统的功能和行为特性，但不一定符合其全部要求。当用户对原型运行结果不满意时，能迅速修改原型，经过几次反复，将可得到用户满意的应用系统 使用户对系统的需求通过原型的运行和修改很快明确下来。最终系统也能通过快速原型法很快产生出来，大大缩短了系统的开发周期 快速原型法的实现是需要一个很好的支撑环境来保证软件原型的快速生成 DSS总控程序完成工作：1) 控制模型程序的运行2) 控制知识推理程序的运行3) 存取数据库的数据4) 进行数据处理5) 进行数值计算6) 完成人机交互 计算机语言1) 数值计算语言2) 数据库语言3) 人工智能语言 解决决策支持系统的开发语言问题1) 研制适合于决策支持系统开发的集成语言2) 以某种功能较强的计算机语言为主语言，嵌入开发决策支持系统尚不足的其他语言形成宿主语言 GFKD-DSS开发工具：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要进行问题分解，把一个大而复杂的问题分解成若干个较小且容易解决的子问题。对各子问题选用相应的模型来求解，并建立所需的数据库。对各模型可以选用最合适的语言编写实现。在解决了这些子问题的基础上，按照实际问题的处理流程，利用工具提供的DSS集成语言将这些子问题间的相互关系编制成DSS控制程序，经过编译，将多个模型、大量数据库有机结合起来，生成了实际问题的决策支持系统 运行控制系统（决策用户）：完成对DSS程序的目标代码解释执行 解释执行部分 模块的驱动运行部分 数据库操作支持部分 管理系统（开发人员）：由DSS管理语言实现对模型库和数据库的建立、查询和维护工作 模型库管理系统：完成对模型字典库和相应的模型文件库的管理 数据库管理系统：dBASE系统 对模型文件库的处理：实现对模型源程序的编辑和编译，形成模型目标程序 GFKD-DSS工具的语言体系 DSS核心语言：用来编写实际问题的决策支持系统，完成对模型目标程序运行的控制、对数据库中数据的存取、人机对话、数值计算和数据处理等功能 IO DIVISION:描述本DSS程序所使用的数据库和控制变量 USING DIVISION:描述本程序中调用的各个模型的及其使用的数据库和控制变量 PROGRAM DIVISION:决策问题DSS程序的处理和对模型控制运行的具体表达 说明部分：标号、类型、变量、过程、函数的说明语句 语句体：程序基本语句、数据库操纵语句、数据库管理语句、模型运行语句、执行操作系统命令语句。屏幕声音类语句 模型库管理语言 数据库接口语言 工具操作语言 管理系统命令 核心语言编译系统命令 运行控制系统命令 DSS程序完成的功能1) 进行数值计算和数据处理2) 直接对多个数据库操作3) 能调用任一种计算机语言编写的模型程序4) 组合多个模型构成复杂结构5) 允许人机对话，支持人的决策 专家系统开发工具与专家系统的对比 专家系统开发工具由开发环境和运行环境组成 开发环境用于建立知识库和事实数据库，以及修改和查询知识库等 对制定知识表示形式的推理机和解释器预先做好 运行环境的目的在于支持实际系统的运行 专家系统开发工具的语言体系：专家系统开发工具需要提供一套语言，用于开发专家系统 知识表示语言 工具操作语言：使用工具中的开发环境和实现运行环境的各功能 专家系统开发工具TOES 系统结构 知识获取系统 知识编辑 知识编译 专家系统框架 推理机 解释器 动态数据库 人机交互使用环境 专家系统生成器 系统操作的有关命令 系统功能 知识获取 知识库编辑 知识库编译 专家系统的生成1.知识库的装入1.生成专家系统 元知识：预先定义的起到控制推理作用的知识 目标 多只 提问句 目标修改 目标增加 数据仓库的开发（螺旋式周期性开发）一、分析与设计阶段 需求分析：根据用户的决策支持需求，确定决策主题域，并分析主题域的商业维度，同时分析支持决策的数据来源，以及向决策主题数据的转换，确定整个数据仓库的数据量以及数据更新的频率，并确定决策分析方法等。 （设计和实现数据仓库的基础） 决策支持需求 信息需求 业务需求 用户访问需求 选择主题 初始规模 概念设计：建立概念模型（对真实世界中面向用户的数据概念进行描述） 主题域范围 所需细节水平 初步概括表 逻辑模型：建立逻辑模型（在计算机中表示的数据模型） 物理设计：对逻辑模型设计的数据模型确定物理存储结构和存取方法 数据库设计 概括表 索引 建立备份和恢复准则 二、数据获取阶段 数据抽取 数据源的确认 确定数据抽取技术 确认数据抽取频率 按照时间要求抽取数据 数据转换 数据格式的修正 字段的解码 单个字段的分离 信息的合并 变量单位的转化 时间的转化 数据汇总 数据装载 初始装载：第一次装入数据仓库。在装载工作完成以后建立索引 增量装载：由于源系统的变化，将变化的数据装载到数据仓库中 完全刷新：由于周期性重写数据仓库，完全删除现有数据，重新装入新的数据 三、决策支持阶段 信息查询（信息查询者） 创建数据陈列：将相应的数据放在同一个物理位置上 预聚集数据：利用“滚动概括”结构组织数据 聚类数据：将同类数据放置在同一地点 知识探索（知识探索者） 四、维护与评估阶段 数据仓库增长 数据仓库维护 适应数据仓库增长的维护 数据增长的处理 存储空间的处理 ETL处理 数据模型的修订 增强决策支持的处理 数据仓库评估 系统性能评定 投资回报分析 定量分析 定性分析 数据质量评估 数据是准确的 数据符合它的类型要求和取值要求 数据具有完整性和一致性 数据是清晰的且符合商业规则 数据保持时效性并且不能出现异常 经过ETL过程，将源系统中的数据改造成有用的信息存储到数据仓库中1) 决定数据仓库中需要的所有的目标数据2) 决定所有的数据源，包括内部和外部的数据源3) 准备从源数据到目标数据的数据映射关系4) 建立全面的数据抽取规则5) 决定数据转换和清洗规则6) 为综合表制定计划7) 维度表的抽取、转换和装载8) 事实表的抽取、转换和装载 数据抽取 确认数据源 列出对事实表的每一个数据项和事实 列出每一个维度属性 对于每个目标数据项，找出源数据项 数据仓库中一个数据元素有多个来源，选择最好的来源 确认一个目标字段的多个源字段，建立合并规则 确认一个目标字段的多个源字段，建立分离规则 确定默认值 检查缺失值的源数据 数据抽取技术 静态数据的抽取 修正数据的抽取 数据转换基本功能1) 选择：从源系统中选择整个记录或者部分记录2) 分离/合并3) 转化4) 汇总 数据转换类型1) 格式修正2) 字段的解码3) 计算值和导出值4) 信息的合并5) 度量单位的转化6) 日期/时间转化7) 汇总8) 关键字重新构造 数据整合和合并：将相关的源数据组合成一致的数据结构，装入数据仓库1) 实体识别2) 多数据源相同属性不同值 数据转换方式1) 编写程序实现数据转换2) 使用转换工具 数据装载：将转换好的数据存储到数据仓库的数据库中 数据装载方式 基本装载：按照装载的目标表，将转换过的数据输入到目标表上去 追加 破坏性合并：用新输入数据更新目标记录数据 建设性合并：保留已有的记录 数据装载类型 最初装载 增量装载 完全刷新 数据质量问题1) 字段中的虚假值2) 数据值缺失3) 不一致的值4) 违反常规的不正确值5) 一个字段有多种用途6) 标准不唯一 产生数据污染的原因1) 系统转换2) 数据老化3) 复杂的系统集成：数据不一致4) 数据输入的不完整信息5) 输入错误6) 欺诈7) 缺乏相关政策 清洗数据（“面向目标”原则）1) 需要清洗哪些数据2) 在什么地方清洗3) 怎么清洗 ETL工具特征1) 从多种关系型数据库中抽取数据2) 从旧数据库、索引文件和平面文件中抽取数据3) 源字段和目标字段从一种格式向另一种格式进行数据转换4) 执行标准转化、重定义键和结构化变化5) 提供从数据源到目标的检查轨迹6) 抽取和转换中商业规则的应用7) 将源系统中的几个记录组合成一个整合的目标记录8) 元数据的记录和清理 OLAP工具功能1) 能进行数据的多维显示2) 能够通过数据聚集，建立汇总的数据立方体3) 能进行一些公式计算和复杂的计算4) 具有时间上的统计功能5) 能够依据单个或多个维度进行旋转、交叉表格、向下钻取和概括化操作6) 具有与电子数据表、专有客户端工具、第三方工具和第四代语言环境等应用系统及软件的接口 数据挖掘的商业应用1) 客户分类2) 市场菜篮子分析3) 风险管理4) 欺诈检测5) 拖欠跟踪6) 需求预测 客户/服务器的处理模型1) 共享设备：多个PC连接到一个共享设备上，共享公共资源2) 客户/服务器：应用处理由客户发起，由客户端控制，服务器提供服务，由两者合作完成3) 同级到同级处理模型 客户/服务器体系结构1) C/S网络环境：网络硬件、网络软件、通信协议2) 中间件：在一个分布式计算机环境中将分开的系统各部分集成在一起的“胶合剂” 客户/服务器系统部件 客户端应用程序 提供用户与数据库交互的界面 向数据库服务器提交用户请求并接收来自数据库服务器的信息 利用客户应用程序执行应用逻辑要求 数据库服务器：负责有效地管理系统的资源 实现数据库安全性要求 实现数据库访问并发性的控制 实现数据库的备份与恢复 网络：完成数据库服务器与客户端应用程序之间的数据传输 基于客户/服务器的决策支持系统快速开发平台CS-DSSP 客户端交互控制系统 可视化系统生成工具：用于制作实际问题的系统控制流程 模型服务器操作 数据库服务器操作 广义模型服务器：提供各种通用算法、模型、知识以及若干方案和实例，由算法库、模型库、方案库、实例库组成 各库的统一管理：静态管理1.存储结构：“文件库+字典库”1.各库的查询、浏览、增加、修改和删除等功能 运行引擎1.模型运行：运行命令1.实例运行：实例解释程序1.知识推理：推理机 数据库接口 三层C/S/S结构 数据库服务器 CS-DSSP的系统生成工具能够根据用户对实际问题的处理流程生成可视化框架流程，既便于用户理解，也便于方案的修改 实际问题的决策支持系统组成1) 系统控制流程2) 多模型组合3) 大量共享数据库存取 DSS的运行机制1) 框架流程的运行机制2) 集成语言程序运行机制 CS-DSSP的决策支持方式1) 单模型生成2) 建立多模型组合的决策支持系统3) 快速生成和改变决策支持系统方案 Web Services的主要目标是在现有各种异构软件和硬件平台的基础上构建一个通用的与平台和语言无关的技术层，各种平台上的应用依靠这个技术层来实施彼此之间的连接和集成，彻底解决以往由于开发语言、部署平台、通讯协议和数据表示等方面的差异所带来的高代价的系统集成问题 对象特征1) 完好的封装性2) 松散耦合3) 使用协约的规范性4) 使用标准协议规范 Web Services体系架构1) 服务提供者2) 服务注册中心：可搜索的服务目录索引中心3) 服务请求者 Web Services具体操作1) 发布2) 查找3) 绑定4) 服务5) 服务描述 Web Services三个行为1) 发布服务描述2) 查询或查找服务描述3) 根据这些服务描述实现绑定和调用服务操作 信息技术：支撑信息的产生、处理、存储、交换及传播的技术 云计算：利用远处的数据中心，通过互联网向客户提供软件、存储、计算能力和其他服务 云计算=因特网上的资源（云）+分散的信息处理（计算） 云计算特征1) 使用模式：可随时随地接入互联网的终端，即申请/注册即使用2) 业务模式：自助服务，可定制，按需使用3) 商业模式：免费或按使用付费 资源池特征1) 统一管理和调度2) 较大的规模a) 可以承载尽可能多的系统和应用b) 支撑海量的数据存储和处理需求3) 良好的可扩展性4) 良好的可伸缩性5) 即时提供6) 最低的成本 云计算是指基于互联网将规模化资源池的计算、存储、开发平台和软件能力提供给用户，实现自动化、低成本、快速提供和灵活伸缩的IT服务 云计算的基础技术1) 服务器的虚拟化2) 信息分散处理3) 经过Web Services的方式提供软、硬件的调用接口4) 云计算在数据存储、数据管理和编程模式等方面具有自身独特的技术&nbsq;&nbsq;&nbsq;&nbsq;a) 海量数据分布存储技术&nbsq;&nbsq;&nbsq;&nbsq;b) 海量数据管理技术&nbsq;&nbsq;&nbsq;&nbsq;c) 并行编程模式 云计算是技术、商业模式和运营组织架构3个要素共同发展驱动的结果 传统计算机系统结构：1) 硬件资源2) 操作系统3) 软件 云计算分层技术结构1) 云计算基础架构：基础设施及服务IaaS&nbsq;&nbsq;&nbsq;&nbsq;a) 基础设施&nbsq;&nbsq;&nbsq;&nbsq;b) 基础架构管理2) 云计算应用开发与执行环境：平台即服务PaaS3) 云计算应用软件：软件即服务SaaS 云计算平台的服务体系结构1) 用户界面2) 服务目录3) 管理系统4) 部署工具5) 监控6) 服务器集群 云计算典型特征：IT服务化。将传统的IT产品通过互联网以服务的形式交付给用户，对应于传统IT中的硬件、平台和（应用）软件 云计算的IT服务1) 基础设施及服务IaaS：通过网络向用户提供计算机、存储空间、网络连接、负载均衡和防火墙等基本硬件资源2) 平台即服务PaaS：一般为开发者提供操作系统、多种编程语言、数据库管理系统和Web服务器，用户在此平台上部署和运行自己的应用3) 软件即服务SaaS：一种通过Internet提供软件的模式，用户无需购买软件，而是向提供商租用基于Web软件来管理企业经营活动 云计算的决策支持系统典型的是基于数据仓库的决策支持系统，也称为商务智能 大数据=海量数据+复杂类型数据 大数据基本特征1) 数据量巨大2) 数据类型多样3) 处理速度快4) 价值密度低 大数据带来的变化1) 从掌握局部数据变为掌握全部数据2) 从纯净数据变为凌乱数据3) 从探求因果关系到掌握事物的相关关系 从数据到决策的大数据时代 利用即时数据的决策 跟着潮流走 跟着新观念走 逆着潮流走 从差距中找商机，从思考中出智慧 互联网络上搜索获取知识，进行决策 利用进入知识分析当前的数据做决策 开源软件激发了人的创新热情 制造假信息和病毒数据 网络丰富了个人生活 利用统计方法的辅助决策 从数据中归纳出数学模型 从数据中获取知识：利用数据挖掘技术 Web内容挖掘：提取文字图片或其他组成网页内容成分的信息和知识 Web结构挖掘：提取网络的拓扑信息，即网页之间的链接信息 Web应用挖掘：提取关于客户如何运用浏览器浏览和使用页面链接的信息 流数据挖掘 大数据与云计算的结合 大数据与云计算是相辅相成的 大数据根植于云计算 相同点1.为数据存储和处理服务1.占用大量的存储和计算资源 差异点1.目的不同1.对象不同 带来的价值不同 [略][略][略]]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT项目管理]]></title>
    <url>%2F2018%2F06%2F20%2FIT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[信息系统：输入数据，通过加工处理，产生信息的系统信息系统具有数据的采集和输入、传输、存储、加工、维护、使用的基本功能。 信息系统的生命周期可以分为系统规划、系统分析、系统设计、系统实现、系统运行和维护5个阶段 信息系统建设的原则：1、高层管理人员介入原则（参加、决策指导或支持）2、用户参与开发原则3、自顶向下规划原则4、工程化原则（解决软件危机问题） 信息系统开发方法：1、结构化方法2、快速原型法（开发周期短、见效快、适用于用户需求模糊、结构化较差的信息系统开发）3、企业系统规划方法BSP4、战略数据规划方法5、信息工程方法（与以上两种交叉）6、面向对象方法 项目：在特定条件下，具有特定目标的一次性任务，是在一定时间内，满足一系列特定目标的多项相关工作的总称项目的基本特征：一次性、独特性、目标的确定性、组织的临时性和开放性、成果的不可挽回性 项目管理：把各种资源应用于目标，以实现项目的目标，满足各方面既定的需求 项目管理的要素：环境、资源、目标、组织。 项目管理最大特点是注重于综合性管理，并且项目管理工作有严格的时间期限。 项目的基本准则：项目经理对项目结果全面负责（基于团队管理的个人负责制） 信息系统项目特点：高智力密集性、综合性，高投入、高风险、高收益，高度时效性、信息交流高度重要、目标的柔韧性、团队的重要性、过程的重要性 项目管理知识体系PMBOK：将项目管理的知识划分为9个领域，（简答）1、范围管理2、时间（进度）管理3、成本管理4、质量管理【核心和目标】5、人力资源管理6、沟通管理7、风险管理8、采购管理【辅助手段】9、整合管理（综合管理、整体管理）【全局综合和协调】{由美国项目管理学会PMI提出} 项目管理专业技术的知识领域：1、应用领域知识、标准、规则2、项目环境3、一般管理知识和技巧4、人际交往技巧 项目生命周期：1、概念阶段（进行项目论证与可行性研究）2、规划阶段（对可行的项目做好开工前的人、财、物及一切软硬件准备，是对项目的总体策划）3、实施阶段（按项目计划实施项目的工作）4、收尾阶段（项目结束的有关工作） 项目干系人：指那些积极参与项目、或是其利益会受到项目执行的影响、或是其利益会受到项目结果影响的个人和组织，可能会对项目及其结果施加影响。包括客户、用户、项目经理、执行组织、项目团队成员、项目发起人、职能经理、影响者、项目管理办公室 项目管理组织：为了完成某个特定的项目任务而由不同部门、不同专业的人员所组成的一个特别工作组织，不受既存的职能组织构造的束缚，也不能代替各种职能组织的职能活动1、职能式组织形式（企业按职能，以及职能的相似性来划分部门） 优点：有利于企业技术水平的提升、资源利用的灵活性与低成本、有利于从整体上协调企业活动 缺点：协调难度大、项目组成员责任淡化2、项目单列式组织形式（按项目来规划所有资源，即每个项目有完成项目任务所必需的所有资源，每个项目实施组织有明确的项目经理） 优点：目标明确及统一指挥、有利于项目控制、有利于全面型人才的成长 缺点：机构重复及资源的闲置、不利于企业专业技术水平的提高、不稳定性3、矩阵式组织形式（按职能划分的纵向部门和按项目划分的横向部门结合，构成类似句子的管理系统） 过程：一组为了完成一系列事先制定的产品、成果或服务而需执行的相互联系的行动和活动 项目的实现过程：指项目团队为创造项目的产出物而开展的各种业务活动所构成的整个过程 项目的管理过程：在项目的实现过程中，项目团队开展项目的计划、决策、组织、协调、沟通、激励和控制等方面活动所构成的过程 项目管理：将知识、技能、工具和技术应用于项目活动之中，以满足项目的要求 项目管理5个基本管理过程：启动、计划、执行、控制和收尾 项目管理的5个过程组：启动过程组、计划过程组、执行过程组、控制过程组、收尾过程组 项目管理过程组之间是一种前后衔接、承前启后，也是信息收集、存储、处理和传递的关系 项目管理过程的应用：1、不同专业的项目选用不同的项目管理过程2、不同的项目会有不同的管理过程3、不同的项目会有不同的管理过程安排顺序4、不同项目的管理过程会有不同的前提条件和要求5、不同项目的管理过程需要不用的集成管理程度6、不同项目有不同的项目管理过程的简化程度 项目立项必经阶段：1、项目机会研究（目的是选择投资机会、鉴别投资方向）：从政策导向、市场需求、技术发展、特定事件寻找项目机会2、项目可行性研究（目的是在信息系统项目立项之前，对所要承担的系统进行必要性、可能性及可能采取的方案进行分析和评价，为组织管理层决策提供科学的依据。任务是确定问题是否值得去解决）技术可行性：进行项目开发的风险、人力资源的有效性、技术能力的可能性、物资（产品）的可用性经济可行性：支出分析、收益分析、收益投资比、敏感性分析运行环境可行性分析（管理可行性）法律可行性社会可行性 可行性研究报告（项目初期策划的结果）(1) 概述。现行系统的目标、功能、范围、关键需求及存在的主要问题(2) 项目技术背景与发展概况(3) 现行系统业务、资源、设施情况分析(4) 项目技术方案。说明拟建新系统的总体方案(5) 实施进度计划(6) 投资估算与资金筹措计划(7) 人员及培训计划(8) 不确定性（风险）分析(9) 经济和社会效益预测与评价(10) 可行性研究结论与建议 3、项目论证与评估：对拟实施项目的技术先进性、经济合理性、实施可能性和风险性等方面进行全面、科学的技术经济分析 “先论证、再决策、后实施”是现代项目管理的基本原则 项目论证阶段：(1) 机会研究阶段(2) 初步可行性研究阶段(3) 详细可行性研究阶段(4) 评价和决策阶段 项目论证步骤：(1) 明确项目范围和业主目标(2) 收集并分析相关资料(3) 拟定多种可行的能够相互替代的实施方案(4) 多方案分析、比较(5) 选择最优方案进一步详细全面地论证(6) 编制项目论证报告、环境影响报告书和采购方式审批报告(7) 编制资金筹措计划和项目实施进度计划 项目评估工作：(1) 成立评估小组，进行分工，制定评估工作计划(2) 开展调查研究，收集数据资料，并对可行性研究报告和相关资料进行审查和分析(3) 分析与评估(4) 编写评估报告(5) 讨论、修改报告(6) 专家论证会(7) 评估报告定稿 项目评估内容：(1) 项目与企业概况评估(2) 项目建设的必要性评估(3) 项目建设规模评估(4) 资源、配件、燃料及公用设施条件评估(5) 网络物理布局条件和方案评估(6) 技术和设备方案评估(7) 信息安全评估(8) 安装工程标准评估(9) 实施进度评估(10) 项目组织、劳动定员和人员培训计划评估(11) 投资估算和资金筹措(12) 项目的财务效益评估(13) 国民经济效益评估(14) 社会效益评估(15) 项目风险评估 项目评估报告：(1) 项目概况(2) 评估目标(3) 评估依据(4) 评估内容(5) 评估机构与评估专家(6) 评估过程(7) 详细评估意见(8) 存在或遗漏的重大问题(9) 潜在的风险(10) 评估结论(11) 进一步的建议 项目整合管理过程：1、制定项目章程（正式授权一个项目和项目资金的文件）&nbsp;&nbsp;&nbsp;项目章程中正式任命项目经理，授权其使用组织的资源开展项目活动2、制定项目管理计划（对定义、编制、整合和协调所有子计划所必需的行动进行记录的过程） 项目整体介绍：(1) 项目名称(2) 项目以及项目所需满足需求的简单描述(3) 发起人的名称(4) 项目经理与主要项目组成员的姓名(5) 项目可交付成果(6) 重要资料清单(7) 列举有关定义和缩写词的说明 项目组织描述：(1) 组织结构图(2) 项目责任(3) 其他与组织或过程相关的信息 项目所需的管理程序和技术程序(1) 管理目标(2) 项目控制(3) 风险管理(4) 项目人员(5) 技术过程 项目所需完成的任务(1) 工作包(2) 主要可交付成果(3) 与工作有关的其他信息 项目时间进度(1) 进度概要（列出一些关键的可交付成果和计划完成日期）(2) 详细进度（详细描述项目进度计划）(3) 与进度有关的其他信息 项目预算(1) 预算概要(2) 详细预算(3) 与项目预算有关的其他信息 项目子项计划1、范围管理计划2、时间管理计划3、成本管理计划4、质量管理计划5、人力资源管理计划6、沟通管理计划7、风险管理计划8、采购管理计划9、项目验收计划 如何制定项目管理计划1、注意项目管理计划的层次性2、项目管理计划要详略得当3、项目管理计划要现实4、重视与客户的沟通 3、指导与管理项目执行（为实现项目目标而执行项目管理计划） 4、监控项目工作 （跟踪、审查和调整项目进展，以实现项目管理计划中确定的绩效目标的过程）&nbsp;&nbsp;目的是提供对项目进展的理解，从而在项目表现明显偏离计划时能够采取适当的纠正措施&nbsp;&nbsp;&nbsp;正规控制：通过定期的和不定期的进展情况汇报和检查，以及项目进展报告进行。&nbsp;&nbsp;&nbsp;非正规控制：走动管理，项目经理频繁地到项目管理现场，与项目团队人员交流，了解情况，及时解决问题&nbsp;&nbsp;&nbsp;预防性控制：在深刻理解项目各项活动、预见可能发生的问题基础上，制定出相应的措施，防止不利事件的发生&nbsp;&nbsp;&nbsp;更正性控制：由于未能或者根本无法预见项目会发生什么问题，只能在问题出现后采取行动，纠正偏差&nbsp;&nbsp;&nbsp;预先控制：在项目活动或阶段开始时进行，可以防止使用不合要求的资源，保证项目的投入满足规定的要求&nbsp;&nbsp;&nbsp;过程控制：对进行过程中的项目活动进行检查和指导，一般在现场进行。&nbsp;&nbsp;&nbsp;事后控制：在项目活动或阶段结束时进行&nbsp;&nbsp;&nbsp;直接控制：项目经理直接对项目活动进行控制&nbsp;&nbsp;&nbsp;间接控制：项目经理对项目团队成员进行控制，具体的项目活动由团队成员去控制5、实施整体变更控制（审查所有变更请求，批准变更，并管理对可交付成果、组织过程资产、项目文件和项目管理计划的变更的过程）&nbsp;&nbsp;整体变更控制：指在项目生命周期的整个过程中对变更进行识别、评价和管理，主要目标是对影响变更的因素进行分析、引导和控制，使其朝着有利于项目的方向发展；确定变更是否真的已经发生或不久就会发生；当变更发生时，对变更进行有效的控制和管理。 变更的常见原因：1、产品范围（成果）定义的过失或者疏忽2、项目范围（工作）定义的过失或者疏忽3、应对风险的紧急计划或回避计划4、项目执行过程与项目基准要求不一致带来的被动调整5、外部事件 变更管理活动：1、对规避整体变更控制的因素施加影响，确保只有经批准的变更才能付诸执行2、迅速地审查、分析和批准变更请求3、管理已批准的变更4、仅允许经批准的变更纳入项目管理计划和项目文件中，以此维护基准的严肃性5、审查已推荐的全部纠正措施和预防措施，并加以批准或否决6、协调整个项目中的各种变更7、完整地记录变更请求的影响 包含变更控制过程的配置管理系统目标1、建立一种先进的方法，以便规范地识别和提出对既定基准的变更，并评估变更的价值和有效性2、通过分析各项变更的影响，为持续验证和改进项目创造机会3、建立一种机制，以便项目管理团队规范地向有关干系人沟通变更的批准和否决情况 包含在整体变更过程中的部分配置管理活动：1、配置识别2、配置状态记录3、配置核实与审计 变更控制的工作程序：1、提出与接受变更申请2、对变更初审3、变更方案论证4、CCB审查5、发出变更通知并开始实施6、变更实施的监控7、变更效果的评估8、判断发生变更后的项目是否已纳入正常轨道 项目变更控制的基本原则：1、谨慎对待变更请求，尽量控制变更2、高度重视需求变更3、签署变更控制的协议4、在基线的基础上做好变更实施5、需要有好的变更控制工具的支持6、把项目变化融入项目管理计划7、及时发布变更信息 6、结束项目（结束阶段） 项目验收：项目结束时，项目团队将其成果交付给使用者之前，项目接收方会同项目团队、监理等有关方面对项目的工作成果进行审查，查核项目管理计划规定范围内的各项活动是否已经完成，应交付的成果是否令人满意。若检查合格，将项目成果由项目接收方及时接收，实现投资转入生产或使用 项目验收意义：1、项目的验收标志着项目的结束2、若项目顺利地通过验收，项目的当事人就可以终止各自的义务和责任3、项目的验收是保证合同任务完成，提高质量的最后关口4、对于基本建设项目和投资项目，通过项目验收，促进投资项目及时投入生产和交付使用，将基本建设投资及时转入固定资产，发挥投资效益 项目验收范围的确认：对需要验收的内容进行科学、合理的界定，以保障项目各方的权益和明确各方的责任 项目后评价：对已经完成的项目（或阶段）的目的、执行过程、效益、作用和影响所进行的系统、客观的分析1、项目效益后评价：指项目竣工后对项目投资经济效果的再评价2、项目管理后评价：通过对项目实施过程的实际情况的分析研究，全面总结项目管理经验，为今后改进项目管理服务 项目后评价报告内容：1、项目背景2、项目实施过程评价3、效果评价4、结论和经验教训 项目范围管理：为了达到项目目标，为了交付具有某种特质的产品和服务，对项目规定要做的工作进行管理 产品范围：某项产品、服务或成果所具有的特性和功能 项目范围：指为交付具有规定特性与功能的产品、服务或成果而必须完成的工作 项目范围管理包括确保项目做且只做成功完成项目所需的全部工作的各过程 项目管理过程：1、收集需求：为实现项目目标而定义并记录干系人的需求的过程2、定义范围：制定项目和产品详细描述的过程3、创建工作分解结构：将项目可交付成果和项目工作分解为较小的、更易于管理的组成部分的过程4、核实范围：正式验收项目已完成的可交付成果的过程5、控制范围：监督项目和产品的范围状态、管理范围基准变更的过程 项目范围管理能够确定项目的边界，明确项目的目标和项目的主要可交付成果 收集需求：为实现项目目标而定义并记录干系人的需求的过程 需求：指发起人、客户和其他干系人的已量化且记录下来的需要与期望 项目需求：1、商业需求2、项目管理需求3、交付需求 产品需求：1、技术需求2、安全需求3、性能需求 收集需求的方法：1、访谈：与干系人直接交谈2、焦点小组会议：将预先选定的干系人和主题专家集中在一起3、引导式研讨会4、群体创新技术：(1) 头脑风暴法(2) 名义小组技术(3) 德尔菲技术（专家判断法）(4) 概念/思维导图(5) 亲和图5、群体决策技术（为达成某种期望结果而对多个为了行动方案进行评估）：(1) 一致同意(2) 大多数原则(3) 相对多数原则(4) 独裁6、问卷调查（通过设计书面问题，向为数众多的受访者快速收集信息）7、观察：直接观察个人在各自的环境中如何开展工作和实施流程8、原型法：根据干系人初步需求，利用系统开发工具，快速地建立一个系统模型展示给干系人，在此基础上与干系人交流，最终实现干系人需求的信息系统快速开发的方法 需求管理计划：对项目的需求进行定义、确定、记载、核实管理和控制的行动指南 需求管理计划内容：1、如何规划、跟踪和汇报各种需求活动2、需求管理需要使用的资源3、培训计划4、项目干系人参与需求管理的策略5、判断项目范围与需求不一致的准则和纠正规程6、需求跟踪结构7、配置管理活动 需求文件：描述各种单一的需求将如何满足与项目相关的业务需求 需求规格说明书要求：1、完整性2、一致性3、可修改性4、可跟踪性 需求跟踪：改善产品的质量，降低维护成本，而且能提高需求定义、项目产品构件的可重用性 正向跟踪：检查需求规格说明书中的每个需求是否都能在后继工作成果中找到对应点逆向跟踪：检查设计文档、代码、测试用例等工作成果是否都能在需求规格说明书找到出处 需求跟踪的目的1、审核2、变更影响分析3、维护4、项目跟踪5、再工程6、重复利用7、减小风险8、测试 需求跟踪矩阵：表示需求和其他系统元素之间的联系链 项目范围说明书内容：1、产品范围描述2、产品验收标准3、项目可交付成果4、项目的除外责任5、项目制约因素6、项目假设条件 工作分解结构WBS内容1、定义项目范围2、定义项目组织3、编制项目产品质量计划4、编制成本管理计划5、编制项目进度计划 WBS分解过程意义1、项目管理计划编制的依据2、项目控制的依据3、确保项目的完整性和系统性4、明确工作任务分派5、沟通协调的依据6、项目目标的保证 工作分解步骤：1、识别和确认项目的主要可交付成果2、分解并确认每一组成部分或工作包是否分解得足够详细3、将可交付成果或工作包分解为更小的组成部分4、核实分解的正确性，并对产品分解项进行工作定义 创建工作分解结构原则：1、各分解层次均应保证项目的完整性，避免遗漏项目可交付成果成分或工作包2、任一分解项只能从属其直接上层分解项，不可出现交叉3、工作任务单元相互之间不应重叠工作内容，应当能分别对应到具体负责人4、属于较高层次的分解节点项可以是项目可交付成果成分、工作包，但最低层叶节点分解项必须是工作包5、最低层叶节点工作包应便于编制资源预算、成本预算、进度预算、质量管理6、对于分包给其他项目管理者的工作，可以分解为一个粒度较大的工作包 核实范围（范围确认）：正式验收项目已完成的可交付成果的过程 控制范围：监督项目和产品的范围状态、管理范围基准变更的过程 造成项目范围变更的原因：1、项目外部环境发生变化2、项目范围定义不周，有错误或者遗漏3、项目实施过程的偏差4、新的技术、手段和方案的应用5、项目组织发生了变化6、项目投资方对项目或者项目产品的要求发生变化 范围变更控制系统规定了项目范围变更所应遵循的流程、文书工作、系统追踪、审批程序等 时间管理：在规定的时间内，拟定出合理且经济的进度计划。采取措施确保项目按时完成。 定义活动：识别为完成项目可交付成果而需采取的具体行动的过程 定义活动的依据1、范围基准2、事业环境因素3、组织过程资产 定义活动的结果：1、活动清单（一份包含项目所需的全部进展活动的清单）2、活动属性（每项活动所具有的多种属性，用于扩展对该活动的描述）3、里程碑清单（项目中的重要时点或事件） 排列活动顺序1、前导图法（单代号网络图法）2、箭线图法（双代号网络图法）3、进度计划网络模板4、确定依赖关系：活动之间的先后顺序(1) 强制性依赖关系（硬逻辑关系）：合同所要求的或工作本身的内在性质所决定的(2) 选择性依赖关系（首选、优先、软逻辑关系）：基于具体应用领域(3) 外部依赖关系：项目活动与非项目活动之间的依赖关系 逻辑关系1、平行关系（并行关系）：相邻两项活动同时开始2、顺序关系：相邻两项活动先后进行3、搭接活动：两项活动只有一段时间是平行进行的 利用时间提前量，可以提前开始紧后活动利用时间滞后量，可以推迟开始紧后活动 活动资源估算的输入：1、活动清单2、活动属性3、资源日历4、事业环境因素5、组织过程资产 活动资源估算的方法与技术：1、专家判断2、备选方案分析3、出版的估算数据4、自下而上估算5、项目管理软件 活动资源估算的输出：识别和说明每一个计划活动所需要的资源类型和数量，这些资源汇总即决定每个工作包所需要的资源 估算活动持续时间是根据资源估算的结果，估算完成单项活动所需工作时段数的过程1、软件项目的工作量2、专家判断（借鉴历史信息）3、类比估算（以过去类似项目的参数值为基础）4、参数估算（利用历史数据与其他变量之间的统计关系）5、三点估算（最可能时间mi，最乐观时间ai，最悲观时间bi，ti= ）6、功能点估算（研究初始应用需求）7、储备分析（预留时间作为对应急情况发生时的一种补充） 制定进度计划：决定项目活动的开始和完成的日期 关键路径法CPM：计算每一活动的最早或最迟开始和结束时间 CPM算法的核心思想：将WBS分解的活动按逻辑关系加以整合，统筹计算出整个项目的工期和关键路径 活动的总时差：指在不延误总工期的前提下，该活动的机动时间。等于该活动最迟完成时间与最早开始时间之差，或该活动最迟开始时间与最早开始时间之差 活动的自由时差：在不影响紧后活动的最早开始时间的前提下，该活动的机动时间 费用斜率： （描述某一项活动加急所需要的代价比） 进度压缩：在不改变项目范围的条件下缩短项目进度的途径 甘特图（横道图、条形图）：把计划和进度安排两种智能结合在一起 控制进度：改变某些因素使进度朝有利方向改变，确定原有的进度已经发生改变，当实际进度发生改变时要加以控制。 控制进度需做好的工作：1、判断项目进度的当前状态2、对引起进度变更的因素施加影响3、确定项目进度是否已经发生变更4、在变更实际发生时对其进行管理 影响项目工期目标实现的干扰因素：1、人：项目经理、项目团队、项目干系人2、材料设备：停工待料、移植返工、效率低下3、方法技术4、资金因素5、环境因素：软环境（政策影响、宏观经济）和硬环境（开发环境、施工场地）&nbsp;(1) 错误估计了项目实现的特点及实现的条件&nbsp;(2) 盲目确定工期目标&nbsp;(3) 工期计划方面的不足&nbsp;(4) 项目参加者的工作失误&nbsp;(5) 不可预见事件的发生 比较分析1、横道图比较法：将在项目进展中通过观测检查搜集到的信息，经整理后直接用横道线并列标于原计划的横道线一起，进行直观比较的方法2、S型曲线比较法：以横坐标表达进度时间，纵坐标表示累计完成任务量或已完成的投资，而绘制出一条按计划时间累计完成任务量的S型曲线，将项目的各检查时间实际完成的任务量与S型曲线进行实际进度与计划进度相比较3、香蕉型曲线比较法：以最早时间和最迟时间分别绘制出相应的S型曲线，前者称为ES曲线，后者称为LS曲线&nbsp;(1) 利用香蕉型曲线进行进度的合理安排&nbsp;(2) 进行施工实际进度与计划进度比较&nbsp;(3) 确定在检查状态下，后期工程的ES曲线与LS曲线的发展趋势 项目进度更新工作：1、分析进度偏差的影响2、进行项目进度计划的调整 分析进度偏差的影响：1、分析产生进度偏差的活动是否为关键活动2、分析进度偏差是否大于总时差3、分析进度偏差是否大于自由时差 项目进度计划的调整1、关键活动的调整2、非关键活动的调整3、增减工作项目4、资源调整 （简答）估算成本：对完成项目活动所需资金进行近似估算的过程，是在某特定时点，根据已知信息所做出的成本预测 估算的基本方法：1、自顶向下的估算法：从项目整体出发，进行类推。即估算人员根据以前已完成项目所消耗的总成本，来推算将要开发的软件的总成本，然后按比例将它分配到各开发任务单元中去。2、自底向上的估算法：把待开发的软件细分，直到每一个子任务都已经明确所需要的开发工作量，然后把它们加起来，得到软件开发的总工作量3、差别估算法：把待开发的软件项目与过去已完成的软件项目进行类比，从其开发的各个子任务中区分出类似的部分和不同的部分 信息系统项目估算成本的困难1、 复杂的信息2、 技术的变化3、 同类项目的缺乏4、 缺乏专业和富有经验的人才5、 信息系统项目建设人员的不同6、 管理层的压力和误解 项目成本估算的困难：1、 草率的成本估算2、 在项目范围尚未确定时就进行成本估算3、 过于乐观或者保守的估算 制定预算：汇总所有单个活动或工作包的估算成本，建立一个经批准的成本基准的过程 制定预算的作用：1、按计划分配项目资源的活动，以保证各项项目工作能够获得所需要的各种资源2、一种控制机制。项目成本预算是度量项目各项活动在实际实施过程中资源使用数量和效率的标准，项目工作所花费的实际成本应该尽量在预算成本的限度以内3、为项目管理人员监控项目实施进度提供了一把标尺。项目费用总和要与一定的实施进度相联系，在项目实施的任何时间点上，都应该有确定的预算成本支出 制定预算的步骤1、分摊项目总成本到WBS的各个工作包，为每一个工作包建立总预算成本，在将所有工作包的预算成本进行相加时，结果不能超过项目的总预算成本2、将每个工作包分配得到的成本再二次分配到工作包所包含的各项活动上3、确定各项成本预算支出的时间计划，以及每一时间点对应的累积预算成本，制定出项目成本预算计划 进行项目预算需考虑因素1、非直接成本2、沉没成本：当前项目的以前尝试已经发生过的成本3、学习曲线4、项目完成的时限5、质量要求6、保留 零基准预算：在项目预算中，并不以过去的相似的项目成本作为成本预算的基准，然后根据项目之间的规模、性质、质量要求、工期要求等不同，对基准进行调节来对新的项目进行成本预算，而是项目已零作为基准，估计所有的工作任务的成本 控制成本：监督项目状态以更新项目预算、管理成本基准变更的过程 项目成本控制工作：1、对造成成本基准变更的因素施加影响2、确保所有的变更请求都获得及时响应3、当变更实际发生时，管理这些变更4、确保成本支出不超过批准的资金限额，包括阶段限额和项目总限额5、监督成本绩效，找出并分析与成本基准间的偏差6、对照资金支出，监督工作绩效7、防止在成本或资源使用报告中出现未经批准的变更8、向有关干系人报告所有经批准的变更及其相关成本9、设法将预期的成本超支控制在可接受的范围内 挣值管理EVM：绩效测量方法挣值测量：一种基于综合基准的项目管理技术，以便依据该综合基准来测量项目期间的绩效 EVM的3个指标：1、计划价值PV：为某活动或WBS组成的预定工作进度而分配且经批准的预算2、挣值EV：项目活动或WBS组成部分的已完成工作的价值3、实际成本AC：为完成活动或WBS组成部分的工作，而实际发生并记录在案的总成本 偏差测量：1、进度偏差SV=E-PV，用来表明项目是否落后于基准进度2、成本偏差CV=EV-AC，BAC与实际总成本之间的差值 绩效指数：1、进度绩效指数SPI=EV/PV，比较项目已完成进度与计划进度的一种指标2、成本绩效指数CPI=EV/AC，比较已完成工作的价值与实际成本的一种指标 完工估算：1、按预算单价完成ETC工作，ETC=BAC-EV,EAC=AC+ETC=AC+BAC-EV2、以当前CPI完成ETC工作，ETC=(BAC-EV)/CPI,EAC=AC+ETC=BAC/CPI3、SPI与CPI同时影响ETC工作，ETC=(BAC-EV)/(CPI SPI),EAC=AC+ETC=AC+(BAC-EV)/(CPISPI) 完工尚需绩效指数TCPI：为了实现特定的管理目标，剩余工作实施必须达到的成本绩效指标。 【案例分析】项目质量管理的目的：通过执行项目质量管理过程和使用一些基本项目管理工具和技术来有力保证信息系统的质量 质量：使实体具备满足明确或隐含需求能力的各项特征之总和明确或隐含的需求：项目要求制定的基础性文件（系统需求规格说明书） 信息系统质量：1、信息系统产品中能满足给定需求的性质和特性的总体2、信息系统具有所期望的各种属性的组合程度3、顾客和用户觉得信息系统满足其综合期望的程度4、确定信息系统在使用中将满足顾客预期要求的程度 质量：一组固有特性满足需求的程度需求：明确的、通常隐含的或必须履行的需求或期望特性：可区分的特性，可以是固有的或赋予的、定性或定量的、各种类别的。 质量政策：某个组织针对自身要求制定的一种质量指导方针 质量度量：对信息系统所具有的、影响其质量的给定属性所进行的定量测量 质量方案制定工作必须明确:1、通常质量方针与组织的总方针相一致并为制定质量目标提供框架2、有效的质量管理原则可以作为制定质量方针的基础 质量管理理论：1、戴明理论：“目标不变、持续改善和知识积累”&nbsp;1) 持续改进&nbsp;2) 把质量管理全过程划分为计划、实施、检验、纠正4个阶段，建立PCDA的循环&nbsp;3) 严格把关&nbsp;4) 预防胜于检验2、朱兰理论&nbsp;1) 适用性就是通过遵守技术规范，使项目符合或者超越项目干系人及客户的期望&nbsp;2) 定义了质量和等级的区别和联系&nbsp;3) 提出了质量规划、质量控制、质量提高的质量三元论，被称为“朱兰三部曲”3、克鲁斯比理论&nbsp;1) 质量的定义即符合预先的要求&nbsp;2) 质量源于预防&nbsp;3) 质量的执行标准是零缺陷&nbsp;4) 质量是用非一致成本来衡量的4、6σ管理方法（100万个机会里面，出现缺陷的机会DPMO=总缺陷数/总机会数）&nbsp;1) 定义&nbsp;2) 测量&nbsp;3) 分析&nbsp;4) 改进&nbsp;5) 控制5、全面质量管理TQM：为了能够在最经济的水平上，并考虑到充分满足用户要求的条件下进行市场研究、设计、生产和服务，把企业内各部门研制质量、维持质量和提高质量的活动构成为一体的一种有效体系&nbsp;1) 全员参加&nbsp;2) 全过程&nbsp;3) 全面运用一切有效方法&nbsp;4) 全面控制质量因素TQM的两大基本原则：&nbsp;1) 以满足用户需求为导向，不断改善，最终使用户全面满足&nbsp;2) 以全员参与为基础，进行全过程的质量控制TAM的五步法：&nbsp;1) 决策&nbsp;2) 准备&nbsp;3) 开始&nbsp;4) 扩展&nbsp;5) 综合6、目标管理：根据注重结果的思想，先由组织最高管理者提出组织在一定时期的总目标，然后由组织内各部门和员工根据总目标确定各自的分目标，并在获得适当资源配置和授权的前提下积极主动为各自的分目标而奋斗，从而使组织的总目标得以实现的一种管理模式&nbsp;1) 确定总体目标&nbsp;2) 目标分解&nbsp;3) 资源配置&nbsp;4) 检查和反馈目标管理模式的优点：&nbsp;1) 使组织的运作有了明确的方向，使每个人都明确了努力的目标&nbsp;2) 结合了人性管理的思想，促使权力下放，强调员工自我控制，可以激发员工的积极性&nbsp;3) 为业绩的检查反馈和效果评价提供了更为客观的基础7、ISO标准：（ISO 9000现代）&nbsp;1) 以顾客为关注焦点&nbsp;2) 领导作用&nbsp;3) 全员参与&nbsp;4) 过程方法&nbsp;5) 管理的系统方法&nbsp;6) 持续改进&nbsp;7) 以事实为基础进行决策&nbsp;8) 与供方互利的关系 过程质量有助于提高产品质量产品质量有助于提高使用质量 软件质量属性的6个特性：&nbsp;1) 功能性&nbsp;2) 可靠性&nbsp;3) 易用性&nbsp;4) 效率&nbsp;5) 维护性&nbsp;6) 可移植性 使用质量：软件产品使指定用户在特定的使用环境下达到满足有效性、生产率、安全性和满意度要求的特定目标的能力 McCall质量模型1、软件运行2、软件修改3、软件转移 软件质量特性度量1、预测型：利用定性或定量的方法，估算软件质量的评价值，以得到软件质量的比较精确的估算值&nbsp;1) 尺度度量（定量度量）&nbsp;2) 二元度量（定性度量）2、验收型：在软件开发各阶段的检查点，对软件的要求质量进行确认性检查的具体评价值，是对开发过程中的预测进行评价 与软件质量相关的3个概念：1、验证：在软件开发周期中的一个给定阶段的产品是否达到在上一阶段确立的需求的过程2、确认：在软件开发过程结束时对软件进行评价以确定它是否和软件需求相一致的过程3、测试：通过执行程序来有意识地发现程序中的设计错误和编码错误的过程 质量管理和项目管理强调重要性：1、顾客满意度2、预防胜于检查3、管理层的责任4、各阶段内的过程 规划质量：识别项目及其产品的质量要求和/或标准，并书面描述项目将如何达到这些要求和/或标准的过程 现代质量管理的一项基本准则：质量是计划出来的，而不是检查出来的 质量测量指标：一种操作性定义。用非常具体的语言，描述项目或产品属性以及质量控制过程如何对其进行测量质量核对表：一种结构化工具。通常具体列出各项内容，用来核实所要求的一系列步骤是否已经执行过程改进计划：项目管理计划的子计划，详细说明进行过程分析的各个步骤，以便识别增值活动。1、过程边界：描述过程的目的、开始与结束、输入输出、所需数据、责任人和干系人2、过程配置：过程的图形表示。用于辅助分析3、过程测量指标：与控制界限一起，用于分析过程的效率4、绩效改进目标：用于指导过程改进活动 实施质量保证的目标：保证项目按照流程和规范达到预先设定的质量标准，并为质量检查、改进和提高提供具体的度量手段，使质量保证和控制有切实可行的依据。另一个是不断地改进质量 持续过程改进：不断地改进所有过程的质量。可以减少浪费，消除非增值活动，使各过程在更高的效率与效果水平上运行 质量审计：一种独立的结构化审查，用来确定项目活动是否遵循了组织和项目的政策、过程与程序 质量审计目标：&nbsp;1) 识别全部正在实施的良好/最佳实践&nbsp;2) 识别全部差距/不足&nbsp;3) 分享所在组织和/或行业中类似项目的良好实践&nbsp;4) 积极、主动地提供协助，以改进过程的执行，从而帮助团队提高生产效率&nbsp;5) 强调每次审计都应对组织经验教训的积累做出贡献 过程分析：按照过程改进计划中概括的步骤来识别所需的改进&nbsp;1) 根本原因分析—-用于识别问题&nbsp;2) 探究根本原因&nbsp;3) 制定预防措施 软件质量保证活动SQA&nbsp;1) 制定SQA计划&nbsp;2) 参与开发该软件项目的软件过程描述&nbsp;3) 评审&nbsp;4) 审计&nbsp;5) 记录并处理偏差&nbsp;6) 报告 实施质量控制：监测并记录执行质量活动的结果，从而评估几点并建议必要变更的过程 质量管理工具与技术：&nbsp;1) 因果图：用于说明各种直接原因和间接原因与所产生的潜在问题和影响之间的关系。每个分支都代表着可能的擦错原因，用于查明质量问题可能所在和设立相应检验点&nbsp;&nbsp;&nbsp;a) 确定问题&nbsp;&nbsp;&nbsp;b) 选择各学科的头脑风暴班子&nbsp;&nbsp;&nbsp;c) 画问题框和主箭头&nbsp;&nbsp;&nbsp;d) 具体化的主要分类&nbsp;&nbsp;&nbsp;e) 识别问题原因&nbsp;&nbsp;&nbsp;f) 确定纠正措施&nbsp;2) 控制图：直观反映某个过程随时间推移的运行情况，以及何时发生了特殊原因引起的变化，导致该过程失控。用来确定一个过程是否稳定，或者是否具有可预测的绩效（当某个数据点超过控制界限，或连续7个点落在均值上方或下方时认为过程失控）&nbsp;3) 检查表：通常由详细的条目组成，用于检查和核对一系列必须采取的步骤是否已经实施的结构化工具，具体内容因应用而不同&nbsp;4) 直方图：由事件发生的频率组织而成，用以显示多少成果是产生于已确定的各种类型的原因的。每个柱形都代表某个问题/情景的一种属性或特征&nbsp;5) 帕累托图：一种按发生频率排序的特殊直方图，显示每种已识别的原因分别导致了多少缺陷&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;帕累托分析：ABC分析图法&nbsp;6) 流程图：对一个过程的图形化方法，用来显示该过程中各步骤之间的相互关系&nbsp;7) 趋势图：没有界限的控制图，用来反映某种变化的历史和模式。可借助趋势图并采用相关的数学技术，进行趋势分析，以便根据历史结果来预测未来情况&nbsp;&nbsp;&nbsp;a) 技术性能&nbsp;&nbsp;&nbsp;b) 成本与进度绩效&nbsp;8) 散点图：用来显示两个变量间的关系。数据点越接近对角线，两个变量之间的关系就越密切。两种变量之间的相互关联性越大，图中的点越不分散，点越趋向集中于一条直线附近&nbsp;9) 统计抽样：从目标总体中选取部分样本用于检查 样本大小=0.25*（可信度因子/可接受误差）可信度因子表示被抽样的数据样本变化的可信度标准差测量数据分布存在多少偏差 提高项目质量的措施方法1、强有力的领导2、建立组织级项目管理体系3、建立组织级质量管理体系&nbsp;1) 确定顾客和其他相关方的需求与期望&nbsp;2) 建立组织的质量方针和质量目标&nbsp;3) 确定实现质量目标必需的过程和职责&nbsp;4) 确定和提供实现质量目标必需的资源&nbsp;5) 规定测量每个过程的有效性和效率的方法&nbsp;6) 应用这些测量方法确定每个过程的有效性和效率&nbsp;7) 确定防止不合格并消除产生原因的措施&nbsp;8) 建立和应用持续改进质量管理体系的过程4、建立项目级激励制度5、理解质量成本（为取得信息系统产品所付出的所有努力的总成本）6、提高项目文档质量7、发展和遵从成熟度模型 人是决定项目成败的关键因素 项目人力资源管理包括组织、管理与领导项目团队的各个过程 项目人力资源计划：根据项目管理计划和实际需求，对项目角色、职责以及请示汇报关系进行确定、分配并分派。 制定人力资源计划的技术工具：1、组织结构图2、组织分解结构3、责任分配矩阵RAM：按期望的详细程度将工作分配给负责具体工作的组织、团队或个人4、人力资源模板：有助于减少疏漏重大职责，加快项目人力资源的编制5、非正式的人际网络 人力资源计划：关于如何定义、配备、管理、控制以及最终遣散项目人力资源的指南1、角色和职责&nbsp;1) 角色：说明某人负责项目某部分工作的一个名词。应清楚界定和记录各角色的职权、职责和边界&nbsp;2) 职权：使用项目资源、做出决策以及签字批准的权力&nbsp;3) 职责：为完成项目活动，项目团队成员应该履行的工作&nbsp;4) 能力：为完成项目活动，项目团队成员所需具备的技能和才干2、项目组织结构图：以图形方式展示项目团队成员及其报告关系3、人员配置管理计划&nbsp;1) 人员招募&nbsp;2) 资源日历&nbsp;3) 人员遣散计划&nbsp;4) 培训需要&nbsp;5) 认可与奖励&nbsp;6) 合规性&nbsp;7) 安全 组建项目团队：根据项目资源规划，获取完成项目工作所需要的人力资源 组建项目团队方法：1、事先分派2、谈判&nbsp;1) 职能经理&nbsp;2) 执行组织中的其他项目管理团队&nbsp;3) 外部组织、卖方、供应商、承包商等3、招募（外包）4、虚拟团队：有共同目标、在完成各自任务过程中很少见面或者没有时间能面对面工作的一些人员 项目经理：项目团队的领导者，所肩负的责任是对工作进行计划、组织和控制，领导团队准时、优质地完成全部工作，在不超过预算的情况下实现项目目标 项目经理的角色定位：&nbsp;1) 项目经理的根本职责是确保项目的全部工作在预算范围内按时、优质的完成，从而使客户满意&nbsp;2) 项目经理是项目的组织者、合作者&nbsp;3) 项目经理是项目的协调者、沟通者&nbsp;4) 项目经理是项目合同的管理者、市场经营者&nbsp;5) 项目经理是项目的领导人、决策人 招聘&nbsp;1) 从组织内部选择的内部招聘&nbsp;2) 从组织外部雇佣的外部招聘 项目经理应该建设、维护、激励、启发项目团队，努力建设一个完美的团队，以获得团队的高绩效，并达到项目目标 建设项目团队的目标：&nbsp;1) 提高团队成员的知识和技能，以提高他们完成项目可交付成果的能力，并降低成本、缩短工期和提高质量&nbsp;2) 提高团队成员之间的信任和认同感，以提高士气、减少冲突和增进团队协作&nbsp;3) 创建富有生气和凝聚力的团队文化，以提高个人和团队生产率，振奋团队精神，促进合作，并促进团队成员之间的交叉培训和辅导，以分享知识和经验 项目团队的发展阶段&nbsp;1) 形成期：团队成员收集有关项目的信息，谨慎研究学习适宜的举止行为&nbsp;2) 震荡期：团队的冲突和不和谐，应采用理性的无偏见的态度&nbsp;3) 正规期：矛盾程度低于磨合时期，项目规程得以改进和规范化，团队信任得以发展&nbsp;4) 表现期：项目团队积极工作，急于实现项目目标。工作绩效很高，有集体感和荣誉感 建设项目团队要发挥每个成员的积极性，发扬团队的团结合作精神，提高团队的绩效，以使项目成功，这是团队共同的奋斗目标 团队建设理论：1、需要层次理论&nbsp;1) 生理需要&nbsp;2) 安全需要&nbsp;3) 社交需要：归属与爱&nbsp;4) 尊重需要&nbsp;5) 自我实现需要 &nbsp;&nbsp; 3个假设：&nbsp;1) 人要生存，他的需要能够影响他的行为，只有未被满足的需要能够影响其行为，已被满足的需要不再影响其行为&nbsp;2) 人的需要按重要性从低到高排成金字塔形状&nbsp;3) 当人的某一级需要得到满足后，才会追求更高一级的需要，如此逐级上升，成为他工作的动机2、双因素理论&nbsp;1) 保健因素：与工作环境有关、能防止人们产生不满意感的一类因素&nbsp;2) 激励因素：与员工工作本身或工作内容有关的、能促使产生工作满意感的一类因素&nbsp;3、期望理论 一个目标对人的激励程度受两个因素影响&nbsp;1) 目标效价：实现该目标对个人有多大价值的主观判断&nbsp;2) 期望值：个人对实现该目标可能性大小的主观估计4、X理论和Y理论 &nbsp;X理论认为人们有消极工作源动力，Y理论认为人们有积极工作源动力 &nbsp;持X理论的管理者会趋向于设定严格的规章制度，以减低员工对工作的消极性，或给予员工奖励、激励和指导 &nbsp;持Y理论的管理者会趋向于对员工授予更大的权力，让员工有更大的发挥机会，以激发员工对工作的积极性5、领导与管理&nbsp;1) 领导行为理论&nbsp;&nbsp;a) 领导者关注的重点&nbsp;&nbsp;b) 领导者的决策方式：下属的参与程度，主要有专断型、民主型、放任型&nbsp;2) 领导权变理论：有效领导=F（领导者，被领导者，环境）6、影响和能力&nbsp;1) 激励&nbsp;2) 影响：权力，任务分配，预算支配，员工升职，薪金待遇，实施处罚，工作挑战，专门技术，友谊&nbsp;3) 权力：合法的权力，强制力，专家权力，奖励权力，感召权力&nbsp;4) 效率：&nbsp;&nbsp;a) 保持积极状态&nbsp;&nbsp;b) 从一开始就牢记结果&nbsp;&nbsp;c) 把最重要的事放在最重要的位置上&nbsp;&nbsp;d) 考虑双赢&nbsp;&nbsp;e) 首先去理解别人再被别人理解&nbsp;&nbsp;f) 获得协同效应&nbsp;&nbsp;g) 磨快锯子 建设项目团队的方法1、人际关系技能：通过了解项目团队成员的感情、预测其行动，了解其后顾之忧，并尽力帮助解决问题2、培训：包括旨在提高项目团队成员能力的全部活动3、团队建设活动：目的是帮助各团队成员更加有效地协同工作4、基本规则：对项目团队成员的可接受行为做出明确规定5、集中办公：将许多或全部最活跃的项目团队成员安排在同一个物理地点工作，以增强团队工作能力6、认可与奖励：对成员的优良行为给予认可与奖励 管理项目团队：跟踪个人和团队的绩效，提供反馈，解决问题和协调变更，以提高项目团队的绩效 绩效评估目的：澄清角色、责任，从团队成员处得到建设性的反馈，发现一些未知的和未解决的问题，制定个人的培训计划，为将来一段时间制定具体目标 项目的人力资源绩效考核流程：1、项目经理根据人力资源部提供的数据、行情、历史经验、专家评定，确定人员按天计算基准工资、公司管理系数、物资基准价格、服务的基准价格、劳动生产率基准，以组织制定项目的预算2、人力资源部门制定各岗位考评标准3、根据各项目经理的项目出工表确定员工的工作量&nbsp;1) 绩效评价参考人对照考评标准、预期计划、目标或岗位职责要求，对任务完成进度、质量、成本及季度工作中的优点和改进点进行评价&nbsp;2) 参考人评价完毕，员工工作量自动汇总到资源部门主管那里，后协调沟通&nbsp;3) 各大部门的人力资源管理委员会审计各部门考评结果及比例4、结果应用 冲突：一方感知到另一方对自己关心的事情会产生消极影响，而与另一方产生矛盾或对抗过程 项目冲突是组织冲突的一种特定表现形态，是项目内部或外部关系难以协调而导致矛盾激化和行为对抗。项目冲突管理：运用管理理论来解决项目中的冲突事件，引导冲突朝积极的方向发展，避免其负面影响&nbsp;1) 建设性冲突：冲突双方大的目标一致，在一定范围内所引发的争执&nbsp;2) 破坏性冲突：冲突双方的目标和解决途径不一致导致的 冲突能够激起大家对问题的讨论和思考，迫使项目团队去寻找新的方法和解决方案，激发项目组成员的积极性和创造力 冲突的特点：冲突是自然的，而且要找到一个解决方法；冲突是一个团队问题，而不是某人的个人问题；冲突的结局应关注于就事论事而不是就事论人，更不是人身攻击；冲突的解决应关注于现在而不是过去 冲突管理的解决方法1) 回避或撤出：把眼前的或潜在的冲突搁置起来，回避冲突2) 竞争或强制：同妥协相对立的解决方式，是以牺牲其他各方的观点为代价，强制采纳一方的观点。实质是“非赢即输”，一种积极解决冲突的方式3) 缓和与调解：实质是“求同存异”，强调冲突各方共同的战略目标，使他们关注一致的一面，而淡化不一致的一面。要求保持一种友好的气氛，但是回避了解决冲突的根源4) 妥协：在彼此之间的看法、观点的交集基础上建立共识，各方都做出一定的让步，冲突各方都有所得有所失。避免冲突、达成一致的有效策略。5) 面对和正视：直接面对冲突是克服分歧、解决冲突的有效途径，通过这种方法，团队成员直接正视问题、正视冲突，得到一种明确的结局。注重双赢，强调解决问题的根源，并通过各方的共同努力，寻找到解决冲突的最佳方法。 激励机制：1) 物质激励：员工基本需要的满足情况2) 环境激励：单位良好的规章制度、优越的办公环境等3) 成就激励：组织激励、榜样激励、目标激励等，以满足员工心理上的需求4) 能力激励：给员工提供培训的机会等，满足员工发展自己能力的需求 正确运用激励：1) 激励要合理：措施要适度，奖惩要公平2) 准确把握激励时机：激励越及时，越有利于将人们的激情推向高潮，使其创造力连续有效地发挥出来3) 正激励与负激励相结合。正激励是对员工符合组织目标的期望行为进行奖励。负激励是对员工违背组织目标的非期望行为进行惩罚4) 明确的激励：明确激励要做什么和怎么做。激励要公开直观。5) 按需激励：员工的需要因人而异，因时而异，只有满足最迫切需要的措施，效果才好，激励程度才大 项目管理团队激励团队成员的士气：1) 亲自向员工的接触工作表现表示感谢，亲自致谢或书面感谢2) 花些时间倾听员工的心声3) 对个人、组织的杰出表现提供明确的回馈4) 积极创造一个开放、信任及有趣的工作环境，激励新点子和积极的主动性5) 让每一位员工了解公司的收支情形，公司的新产品和市场竞争策略，以及讨论每位员工在公司所有计划中所扮演的角色6) 让员工参与决策，尤其是那些对其有影响的决定7) 肯定、奖励及升迁等，都应以个人工作表现及工作环境为基础8) 加强员工对于工作及组织的归属感9) 提供员工学习新知识及成长的机会，告诉员工在公司的目标下，管理者如何帮助其完成个人目标，建立与每位员工的伙伴关系10) 庆祝成功，无论是公司、部门或个人的优秀表现，都应举办士气激励大会或相关活动 沟通：人与人之间传递和沟通信息的过程 沟通的主旨：在于互动双方建立彼此相互了解的关系，相互回应，并期待能经由沟通的行为与过程相互接纳，以达成共识 项目干系人之间的沟通：1) 用户和开发商之间：需求的清晰表达、解决方案的描述、合同签订过程2) 团队和管理层之间：调研结果汇报、方案决策、组建团队、项目评审过程3) 开发团队内部：项目计划、技术方案的制定和变更4) 开发商和供货商之间：采购沟通、供货和验收过程5) 开发商和分包商之间：任务外包、提交和验收过程 信息系统项目成功有关因素：1) 用户参与2) 主管层的支持3) 需求的清晰表达 识别干系人：识别所有受项目影响的人员或组织，并记录其利益、参与情况和对项目成功的影响的过程 项目干系人：积极参与项目，或其利益可能受项目实施或完成的积极或消极影响的个人和组织 干系人分析：系统地收集和分析各种定量与定性信息，以便确定在项目中应该考虑哪些人的利益 干系人分析的步骤：1) 识别全部潜在项目干系人及其相关信息2) 识别每个干系人可能产生的影响或提供的支持，并分类，以便制定管理策略3) 评估关键干系人对不同情况可能做出的反应或应对，一边策划如何对他们施加影响，提高他们的支持和减轻他们的潜在负面影响 分类方法：1) 权力/权益方格2) 权力/影响方格3) 影响/作用方格4) 凸显模型 干系人登记册：识别干系人过程的主要输出1) 基本信息：姓名、职位、地点、在项目的角色、联系方式2) 评估信息：主要需求、主要期望、对项目的潜在影响3) 干系人分类：内部/外部、支持者/中立者/反对者 干系人管理策略1) 对项目有显著影响的关键干系人2) 希望每个干系人参与项目的程度3) 干系人分组以及按组别管理的措施 规划沟通：确定项目干系人的信息需求，并定义沟通方法的过程 有效果的沟通：用正确的格式、在正确的时间提供信息，并且使信息产生正确的影响有效率的沟通：只提供所需要的信息 用来确定项目沟通需求的信息：1) 组织结构图2) 项目组织以及干系人职责间的关系3) 项目所涉及的学科、部门以及专业4) 有多少人在什么地点参与项目5) 内部信息需求（横跨整个组织的沟通）6) 外部信息需求（与媒体、公众或承包商的沟通）7) 来自干系人登记册和干系人管理策略的干系人信息 影响项目因素：1) 信息需求的紧迫性2) 可用技术3) 预期的项目人员配备4) 项目的持续时间5) 项目环境 沟通是一种人与人之间的双向信息交流活动，所采用的方式应该是双方都能理解的通用符号和技巧，以保证信息的传送与接收畅通 沟通模型：1) 信息发送者2) 信息3) 信息接收者 发送者应该仔细地核对信息编码、确定发生信息的方法（沟通方法），并且要证实信息已经被理解了。接收者应该对信息进行仔细地解码并且确保对信息的正确理解 沟通模型关键要素：1) 编码：把思想或想法转化为他人能理解的语言2) 信息和反馈信息：编码过程所得到的结果3) 媒介：用来传递信息的方法4) 噪声：干扰信息传输和理解的一切因素5) 解码：把信息还原成有意义的思想或想法 沟通方法1) 交互式沟通：在双方或多方之间进行多向信息交换2) 推式沟通：把信息发送给需要了解信息的特定接收方3) 拉式沟通：要求接收方自主、自行地获取信息内容 正式沟通：通过项目组织明文规定的渠道进行信息传递和交流的方式1) 优点：沟通效果好2) 缺点：沟通速度慢 非正式沟通：在正式沟通渠道之外进行的信息传递和交流1) 沟通方便，沟通速度快，且能提供一些正式沟通难以获得的信息2) 容易失真 沟通管理计划：指导项目沟通1) 干系人的沟通需求2) 需要沟通的信息，包括语言、格式、内容、详细程度3) 发布相关信息的原因4) 发布所需信息的时限和频率5) 负责沟通相关信息的人员6) 有权发布机密信息的人员7) 将要接收信息的个人或小组8) 传递信息的技术或方法，如备忘录、电子邮件、新闻稿9) 为沟通活动分配的资源，包括时间和预算10) 在下层员工无法解决问题时的问题升级流程，用于规定问题上报时限和上报路径11) 随项目进展，对沟通管理计划进行更新与优化的方法12) 通用术语表13) 项目信息流向图、工作流程、报告清单、会议计划14) 沟通制约因素，通常来自特定的法律法规、技术要求和组织政策 发布信息：按计划向项目干系人提供相关信息的过程 发布信息的技术1) 沟通基本模型：需要考虑反馈回路和沟通障碍2) 媒介的选择3) 写作风格：主动被动语态、句子结构、用词选择4) 会议管理技术：准备议程和处理冲突5) 演示技术：形体语言和视觉辅助设计6) 促进技术：建立共识和克服障碍 发布信息的工具：1) 纸质文件发布工具、手工归档系统、新闻发布系统、共享电子数据库2) 电子通信和会议工具3) 项目管理工具 组织过程资产更新1) 干系人通知2) 项目报告3) 项目演示资料4) 项目记录5) 干系人的反馈意见6) 经验教训文档 管理干系人期望：为满足干系人的需要而与之沟通和协作，并解决所发生的问题的过程1) 通过与干系人谈判以及对干系人实现项目目标的意愿施加影响，来积极管理干系人的期望，提高干系人验收项目的可能性2) 处理目前还没有成为问题，但预计以后会成为问题的各种关注点。要及时发现和讨论这些关注点，并进行风险评估3) 澄清并解决已经识别的问题 项目客户关系管理PCRM：通过持续改进以提高客户满意度为中心，不断实现对项目质量、成本、进度的控制，建立适应客户不断变化需求的灵活的组织结构，以全面客户满意为目标，最终与客户建立长期良好的合作关系，实现双赢的管理方法 根据帕累托的80/20原则，项目组织80%的收益来自20%高忠诚度的客户。组织必须重视高忠诚度客户的价值，他们是项目组织基本利润来源的保证 报告绩效：收集并发布绩效信息的过程 偏差分析：一种事后审查，以便找出导致基准与实际绩效之间差异的原因1) 验证所收集的信息的质量，确保其完整性、与过去数据的可比性，以及与其他项目或状态信息相比较的可靠性2) 将实际信息与项目基准进行比较，确定偏差。3) 确定偏差对项目成本、进度以及其他方面的影响4) 如果可行，分析偏差的发展趋势，并记录关于偏差原因与影响领域的任何发现 预测：以截至目前的实际绩效为基础，来预估未来的项目绩效1) 时间序列方法：以历史数据为基础来估算未来结果2) 因果/计量经济学方法：先估计自变量的值，然后以此来预测因变量3) 判断方法：直觉判断、主观判断和概率估算的综合4) 其他方法：模拟预测、概率预测、总体预测 绩效报告：对收集到的信息进行组织与归纳，并通过与绩效测量基准的比较，来分析和展示绩效1) 对过去绩效的分析2) 当前的风险和问题状态3) 本阶段完成的工作4) 下一阶段需要完成的工作5) 本阶段批准的变更的汇总6) 必须审查和讨论的其他相关信息 绩效报告常用格式1) 横道图2) S曲线图3) 直方图4) 表格 绩效报告主要形式：1) 状态报告：描述项目在某一特定时间点所处的项目阶段2) 进展报告：描述项目团队在某一特定时间段的工作完成情况3) 项目预测：在历史资料和数据基础上，预测项目的将来状况与进展 状态评审会议：突出一些重要项目文件提供的信息，迫使项目组成员对他们的工作负责，以及对重要的项目问题进行面对面的讨论 项目信息系统PMIS：用于收集、综合和分析项目管理过程输出的工具和技术1) 计划：围绕质量、时间、成本三大目标，辅助完成项目计划工作2) 控制：提供一些控制手段，以领导和协调项目组织的各种要素 PMIS所具备功能：1) 预算和成本控制功能2) 排定任务日程功能3) 计划与进度安排功能4) 资源管理功能5) 监督和跟踪项目功能6) 可视化管理功能7) 报表管理功能8) 与其他专业应用软件交换信息的功能9) 处理项目群和子项目的功能10) 工作排序和信息筛选功能11) 文档信息安全性保护功能12) 用于预测分析功能 如何改进项目沟通（简答）1) 使用项目管理信息系统2) 建立沟通基础结构：一套工具、技术和原则，为项目信息传送提供一个基础。3) 使用项目沟通模板4) 把握项目沟通基本原则a) 沟通内外有别（对外意见要一致）b) 非正式的沟通有助于关系的融洽c) 采用对方能接受的沟通风格d) 沟通的升级原则：合理把握横向沟通和纵向沟通关系，有利于项目问题的解决e) 扫除沟通的障碍5) 发展更好的沟通技能：领导层帮助改善沟通6) 把握人际沟通风格：针对不同沟通风格的人，个性化定制，采用对方喜欢的方式去沟通，就会取得好的沟通效果a) 理想型：关注“事件对谁有益，能从中获得何种成就感”b) 实践型：关注“事件的老板是谁，利益是什么，最核心的目标是什么”c) 亲和型：擅长在沟通中创造一个融洽的氛围，但对沟通表现出跳跃型，让人不明白其真正想表达的中心思想d) 理性型：做事比较稳重，往往需要在掌握足够信息后，经过复杂的数据运算，才能得出结论7) 进行良好的冲突管理冲突管理：利用沟通技能创造性地处理项目冲突的艺术冲突管理作用：引导冲突的结果向积极的协作的而非破坏性的方向发展8) 召开高效的会议a) 事先制定一个例会制度b) 放弃可开可不开的会议c) 明确会议的目的和期望结果d) 发布会议通知e) 在会议之前将会议资料发到参会人员f) 可以借助视频设备g) 明确会议规则h) 会议后要总结，提炼结论i) 会议要有纪要j) 做好会议的后勤保障 风险表达了一种概率，具有偶发性 风险的两个基本属性1) 随机性：风险事件的发生及其后果都具有偶然性2) 相对性：风险总是相对项目活动主题而言的，同样的风险对于不同的主体有不同的影响。 对风险的承受能力因素影响：1) 收益的大小2) 投入的大小3) 项目活动主体的地位和拥有的资源项目风险特点：1) 风险存在的客观性和普遍性：不以人的意志而转移并超越主观意识的客观存在，无处不在无时没有的。2) 某一具体风险发生的偶然性和大量风险发生的必然性3) 风险的可变性4) 风险的多样性和多层次性 风险分类1) 风险后果：纯粹风险、投机风险2) 风险来源：自然风险、人为风险3) 可管理：可管理风险、不可管理风险4) 影响范围：局部风险、总体风险5) 可预测性：已知风险、可预测风险、不可预测风险 信息系统项目风险：1) 项目风险：潜在的预算、进度、人员、资源、用户和需求方面问题，，以及它们对项目的影响2) 技术风险：潜在的设计、实现、接口、测试和维护方面的问题3) 商业风险：威胁到产品的生产能力a) 市场风险：开发的产品虽然很优秀但不是市场真正所想要的b) 策略风险：开发的产品不再符合公司的整个组织的产品战略c) 销售风险：开发了销售部门不清楚如何推销的产品d) 管理风险：由于重点转移或专业人员变动而失去上级管理部门的支持e) 预算风险：没有得到预算或人员的保证 风险分解结构RBS：按风险类别和子类别来排列已识别的项目风险的一种层次结构，用来显示潜在风险的所属领域和产生原因 规划风险管理：定义如何实施项目风险管理活动的过程 规划会议的主要工作：1) 确定实施风险管理活动的总体计划2) 确定用于风险管理的成本种类和进度活动，并将其分别纳入项目的预算和进度计划中3) 建立或评审风险应急储备的使用方法4) 分配风险管理的职责5) 根据具体项目的需要，剪裁组织中有关风险类别和术语定义等的通用模板 风险管理计划：描述如何安排与实施项目风险管理1) 方法论：确定项目风险管理将使用的方法、工具和数据来源2) 角色与职责：确定风险管理计划中每项活动的领导者和支持者，以及风险管理团队的成员，并明确其职责3) 预算：分配资源，估算风险管理所需的资金，将其纳入成本绩效基准，并建立应急储备的使用方案4) 时间安排：确定在项目生命周期中实施风险管理过程的时间和频率5) 风险类别：提供了一个框架，确保在同一细节水平上全面、系统地识别各种风险，并提高识别风险过程的效果和质量6) 风险概率和影响的定义7) 概率影响矩阵：根据风险可能对项目目标产生的影响，对风险进行优先排序8) 修订的干系人承受力：在规划风险管理过程中对干系人的承受力进行修订，以适应具体项目的情况9) 报告格式：用于规定将如何对风险管理过程的结果进行记录、分析和沟通10) 跟踪：规定将如何记录风险活动 识别风险：判断哪些风险会影响项目并记录其特征的过程（简答） 识别风险的技术：1) 文档审查：对项目文档进行结构化审查2) 信息收集技术a) 头脑风暴：目的是获得一份综合的项目风险清单b) 德尔菲技术：组织专家就某个专题达成一致意见的一种方法c) 访谈：有经验的项目参与者、干系人或相关主题专家d) 根本原因分析：发现问题，找到其深层原因并制定预防措施的一种特定技术3) 核对表分析：根据以往类似项目或从其他渠道积累的历史信息与知识，编制风险识别核对表，也可用RBS的底层作为风险核对表4) 假设分析：检验假设条件在项目中的有效性，并识别因其中的错误、变化、矛盾或片面性所致的项目风险5) 图解技术a) 因果图（石川图、鱼骨图）：用于识别风险的起因b) 系统（过程）流程图：显示系统各要素之间的相互联系以及因果传导机制c) 影响图：用图形方法表示变量与结果之间的因果关系、事件时间顺序以及其他关系6) SWOT分析：从项目的每一个优势S、劣势W、机会O和威胁T出发，对项目进行考察，把产生于内部的风险都包括在内，从而更全面地考虑风险7) 专家判断 风险登记册：1) 已识别的风险清单2) 潜在应对措施清单 实施定性风险分析：评估并综合分析风险的发生概率和影响，对风险进行优先排序，从而为后续分析或行动提供基础的过程 定性风险分析的方法:1) 风险概率和影响评估a) 风险概率评估：旨在调查每个具体风险发生的可能性b) 风险影响评估：旨在调查风险对项目目标的潜在影响2) 概率影响矩阵：基于风险评级结果，对风险进行优先排序，以便进一步进行定量分析和风险应对3) 风险数据质量评估：评估有关风险数据对风险管理的有用程度的一种技术4) 风险紧迫性评估：把近期就需应对的风险当作更紧急的风险 更新风险登记册：1) 项目风险的相对排序或优先级清单2) 按类别分类的风险3) 风险成因或需特别关注的项目领域4) 近期就需应对的风险清单5) 需进一步分析与应对的风险清单6) 低优先级风险观察清单7) 定性风险分析结果的趋势 实施定量风险分析：就已识别风险对项目整体目标的影响进行定量分析的过程1) 数据收集和表现技术：访问和概率分析2) 预期货币价值分析：当某些情况在未来可能发生、也可能不发生时，计算平均结果的一种统计方法（决策树）3) 敏感性分析：有助于确定哪些风险对项目具有最大的潜在影响（龙卷风图）4) 建模和模拟：使用一个模型，计算项目各细节方面的不确定性对项目目标的潜在影响（蒙特卡洛技术）5) 评估结果（更新风险登记册）：a) 项目的概率分析b) 实现成本和时间目标的概率c) 量化风险优先级d) 定量风险分析结果的趋势 规划风险应对：针对项目目标，制定提高机会、降低威胁的方案和措施的过程 消极风险或威胁的应对策略：1) 回避：改变项目管理计划，以完全消除威胁2) 转移：将某风险的部分或全部消极影响连同应对责任转移给第三方3) 减轻：将不利风险事件的概率和/或影响降低到可接受的临界值范围内4) 接受：项目团队已决定不为处理某风险而变更项目管理计划，或者无法找到任何其他的合理应对策略 积极风险或机会的应对策略1) 开拓：消除与某个特定积极风险相关的不确定性，确保机会肯定出现2) 分享：将应对机会的部分或全部责任分配给最能为项目利益抓住该机会的第三方3) 提高：识别那些会影响积极风险发生的关键因素，并使这些因素最大化，可以提高机会发生的概率4) 接受：当机会发生时乐于利用，但不主动追求 监控风险：在整个项目中，实施风险应对计划、跟踪已识别风险、监测残余风险、识别新风险和评估风险过程有效性的过程1) 风险再评估：识别新风险，对现有风险进行再评估以及删除已过时的风险2) 风险审计：检查并记录风险 应对措施在处理已识别风险及其根源方面的有效性，以及风险管理过程的有效性3) 偏差和趋势分析4) 技术绩效测量：把项目执行期间所取得的技术成果与项目管理计划所要求的技术成果进行比较5) 储备分析：在项目的任何时点比较胜于应急储备与剩余风险量，从而确定剩余储备是否仍然合理6) 状态审查会 监控风险目的确定：1) 项目的假设条件是否仍然成立2) 某个已评估过的风险是否发生了变化，或已经消失3) 风险管理政策和程序是否已得到遵守4) 根据当前的风险评估，是否需要调整成本或进度应急储备；学习新知识及成长的机会]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息系统分析与设计]]></title>
    <url>%2F2018%2F01%2F07%2F%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[第一章：系统开发生命周期（System Development Life Cycle）：系统开发人员进行信息系统分析与设计所采用的系统方法，一种阶段化的信息系统分析与设计方法，基本思路是按照 系统开发人员和用户的特定活动来开发信息系统 信息系统：简称计算机系统，是由人、计算机硬件、软件、通信网络和数据资源组成的一类人机系统。目的是借助计算机硬件、软件、通信网络等，及时、准确地收集、加工、存储、传输和提供决策所需的适用信息，实现企业或其他机构中各项活动的计划、组织、调节和控制 计算机的作用：长期保存历史数据人的作用：根据经验和知识进行模糊推理人机结合作用：加工数据、产生信息 信息系统的基本结构⑴总体结构：系统的信息源、信息处理器、信息用户和信息管理者⑵物理结构：系统的硬件、软件、数据等硬资源和系统的管理理论、方法、标准等软资源⑶层次结构：战略层、战术层和业务层⑷功能结构：按照各部门的业务功能建立关联的子系统⑸综合结构：层次结构+功能结构。纵向综合、横向综合、纵横综合 软件过程模型： 瀑布模型：按工序将问题化简，不适应用户需求的变化基本活动： 制定计划 需求分析 系统分析 程序设计 软件测试 运行维护 模型：不适应用户需求变化 敏捷开发模型：适用于高性能高风险系统 美国Jeffrey A.Hoffer教授信息系统分析与设计是一项复杂、有挑战性、刺激性的组织过程，业务团队和系统专家用它来开发和维护基于计算机的信息系统 美国Alan Dennis教授的观点开发一个信息系统在许多方面与建造一个房子相似：第一步，提出一座房子建造的基本需求；第二步，将房子建造的基本需求转变成简单的草图展示给用户看，并不断细化，直到用户基本满意为止；第三步，设计出描述这座房子更为详尽的一系列建造蓝图；第四步，按照这座房子的设计蓝图建造房子，在此过程中允许用户做出一些更改 信息系统开发周期基本阶段： 项目规划阶段 系统分析阶段 系统设计阶段 系统实现阶段 C/S模式：客户机/服务器模式，客户请求服务，服务器提供服务的处理方式。客户机和服务器常常分别处于相距较远的两台计算机上，客户机完成数据处理，数据表示以及用户接口功能，服务器完成DBMS的核心功能 B/S模式：浏览器/服务器模式。浏览器通过Web服务器同数据库进行数据交互 云计算模式:云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问，进入可配置计算资源共享池，这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互 云计算提供的资源服务：软件即服务、平台即服务、基础设施及服务 1234C/S模式全称：Client/ Server,客户机/服务器模式B/S模式全称：Browser/ Server, 浏览器/服务器模式CASE的英文全称Computer Aided Software Engineering，中文全称计算机辅助软件工程OOIE的英文全称Object-Oriented Information Engineering，中文全称面向对象信息工程 C/S、B/S优缺点1、C/S 优点 应用服务器运行数据负荷较轻 数据的储存管理功能较为透明 缺点 移植困难 不易扩展 维护与升级麻烦 2、B/S 优点 系统的扩展非常容易 维护和升级方式简单 成本降低，选择更多 缺点：应用服务器运行数据负荷较重 应用题：编辑并测试起泡法排序（P12）系统开发方法软件工程方法： 结构化方法（自顶向下，逐步求精） 1.优点1. 严格区分系统开发的阶段性 2. 自顶向下的分析与设计和自底向上逐步实施相结合 3. 用户至上 4. 符合实际，客观化和科学化 5. 充分预料可能发生的变化 6. 系统开发过程工程化，文档资料标准化 缺点 开发周期过长 文档耗费大量时间和资金，且很难保持最新 原型法 面向对象方法 系统调查和需求分析 面向对象分析OOA 面向对象设计OOD 面向对象程序实现 CASE方法 构件方法CBSD 角色职责（随机一个）： 如针对个人风采网站，项目经理。项目总体设计，制定和监督开发进度，制定相应的开发规范，负责各个环节的评审工作，协调各个成员（小组）之间开发，同时负责成本估算和项目开发预算，确保项目在预定时间和预算内完成 系统分析员：具有高级工程师的实际业务水平 程序员：承担单元测试职责 系统培训人员：系统实现阶段的主要角色 第二章网络图绘制（PERT/CPM）：P25、P39 1234任务标识号或名称 工期（工作日）最早开工时间 最早完工时间最迟开工时间 最迟完工时间总时差：XXX（工作日） 系统需求：创建新系统的业务原因和新系统预期带来的价值 信息系统项目：包括开发新的信息系统，加强现有的信息系统，升级或更新公司的信息技术基础架构等，作为实现组织战略目标的手段而建设 项目管理：在项目活动中应用一系列知识、技能、工具和技术，以满足或超过项目干系人对项目的要求和期望 可行性研究：用最小的代价在尽可能短的时间内对问题进行客观分析，确定问题是否能够解决，为以后的行动方针提出最适当的提议 技术可行性：围绕企业中现有硬件、软件能力，以及计算机硬件、软件行业的水平展开的，即分析所提出的需求在现有技术资源条件下是否能够实现。 经济可行性：可行性研究的重要组成部分，核心是成本/效益分析 甘特图：以图示的方式通过活动列表和时间刻度形象地表示出任何特定项目的活动顺序与持续时间。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况 12BSP的英文全称Business System Planning，中文全称企业系统规划法WBS的英文全称Work Breakdown Structure，中文全称工作分解结构 GB/T8567-2006是中国制订的计算机软件文档编制规范 美国项目管理协会PMI：项目是为了创造某一独特的产品或服务所做的一次性努力 信息系统项目特点 目标性 一次性（时限性） 冲突性 渐进明细性 不确定性 约束性 项目实施管理 开发管理 测试管理 运行管理 评价管理 错误率：系统分析与设计最高、文档及其他错误相对较低 质量控制 严格挑选系统开发组成员 加强培训工作 正确选择系统开发模式与方法 建立质量检查制度 采用项目监理 进行集体评议 初步调查的目标和内容（原则需了解） 目标 掌握用户的概况 对用户提出的各种问题和初始要求进行识别 明确新系统的初步目标、为系统可行性研究提供基础数据 原则 自顶向下全面展开 分析管理部门存在的道理、环境条件、工作过程 工程化的工作方式 全面铺开与重点调查结合 主动沟通与亲和友善的工作方式 内容 组织概况 组织环境 现行系统概况 各方面对新系统的态度 系统研制工作的资源情况 信息系统规划方法： 企业系统规划法BSP：为了明确需要进一步开发的信息系统项目的目标范围 关键成功因素法：通过分析找出使得企业成功的关键因素，再围绕这些关键因素来确定系统的需求，并进行规划以获得良好的绩效，实现企业的目标 战略目标集转化法SST：将整个战略目标看成由组织使命、目标、战略和其他战略变量组成的一个“信息集合”。（把企业组织的战略目标转化为信息系统的战略目标） 可行性研究内容 技术可行性：分析所提出的需求在现有技术资源条件下是否能够实现 经济可行性研究：成本/效益分析 管理可行性研究：主管领导态度、管理方面条件、行为的可行性研究 法律可行性研究：系统开发可能导致的侵权、违法和责任 可行性研究步骤 成立专门的研究小组 用户信息需求分析 提出所有可能的系统方案 评价备选系统的性能及成本效益情况 选择最优方案 可行性研究报告准备 对可行性报告，要组织专家、领导和管理者进行评审 DBA：系统需求要素的新系统提案人 关键路径法CPM 第三章用例图P47、序列图P63、协作图P64 信息系统分析阶段的主要任务系统分析人员在对企业或组织的原系统进行详细调查的基础上，详细了解用户的需求，分析新系统的业务处理过程和数据处理过程，在此基础上构建新系统的逻辑模型 详细调查的原则 事先制订计划 深入沟通交流 保密性原则 系统性原则 经济性原则 详细调查方法 典型调查 重点调查 个案调查（独特性） 原型法 详细调查内容 组织结构调查 需求调查 业务调查：可用UML的活动图描述业务流程 UML融合了OMT、Booch、Coad-Yourdon和OOSE等方法中的基本概念，始于1997的一个对象管理组织OMG标准 通过信息系统的详细调查与需求分析，弄清信息系统是“如何做”的问题 面向对象系统需求分析建模的主要工具：用例图 包含：用例可以简单的包含其他用例的行为，并把它所包含的用例行为作为自己行为的一部分 扩展：将基础用例中一段相对独立并且可选的动作，用新的用例加以封装，再让它从基础用例中声明的扩展点上进行扩展，从而使基础用例行为更简练和目标更集中 泛化：用例可以被特化形成多个子用例 绘制序列图： 识别参与交互对象 确定系统对象的交互过程 为每个对象设置生命线（在交互过程中被创建和撤销） 从引发交互过程的初始消息开始，在生命线之间自顶向下依次画出随后的个别消息 如果需要表示消息的嵌套或表示时间，则采用控制焦点；需要说明时间约束，则在消息旁加上说明 绘制协作图： 识别参与交互过程的对象 确定对象之间的交互过程 如果需要，为每个对象设置初始特性 确定对象之间的链，以及沿着链的消息 从引发交互过程的初始消息开始，将随后的每个消息附在相应的链上 根据需要表示消息的嵌套 根据需要说明消息的时间约束 根据需要为每个消息附上前置条件和后置条件 系统需求分析建模过程 系统需求描述 发现和确定角色 发现和确定用例 绘制用例图及进行用例描述 典型调查:指从调查对象的总体中选取一个或几个具有代表性的单位，如个人、群体、部门、组织等等，进行全面、深入的调查。其目的是通过直接地、深入地调查研究个别典型，来认识同类事物的一般属性和规律 功能需求：系统面向实际应用时所应具备的各项功能 数据需求：在完成业务室所提供给信息系统关于被处理数据的描述和数据采集的要求 性能需求：信息系统应该满足的效率、处理方式、可靠性、安全性、适应性等技术要求 12OOA的英文全称Object-Oriented Approach，中文全称面向对象方法UML的英文全称Unified Modeling Language，中文全称统一建模语言 用例之间可以抽象出包含、扩展、泛化等三种关系 最常见的类之间的关系有泛化关系、依赖关系、实现关系、关联关系 等四种 面向对象系统分析建模的基本任务 进行面向对象的系统需求分析建模 在系统需求分析建模的基础上，继续识别待开发系统应用领域的对象，分析对象间的关系，建立符合系统需求的两种模型：对象/类静态模型和对象/类动态模型 UML通过三类模型描述拟建立的新系统逻辑模型 系统需求分析模型（用例图） 系统静态结构模型（类图、对象图、包图） 系统动态行为模型（协作图、活动图、状态图、序列图） 第四章ER图P67、界面设计P68、数据库操作P84 界面设计原则 基于用户需求，适合系统功能 重视可读性和可理解性 合理利用颜色、图像来达成内容与形式的统一动画效果 加强易用性和容错性 界面设计内容 用户界面框架设计 用户界面元素设计 系统信息显示设计 系统为用户提供较为详尽的帮助 ER图转换关系模型：实体名、多对多、一对多、一对一、相同码（P82填空） 系统总体结构设计 网络的集成与设计 系统体系结构设计 大型的关系型数据库管理系统软件：Oracle、DB2、Informix、Sybase 云存储系统的结构模型：存储层、基础管理层、应用接口层、访问层 系统逻辑体系结构（包图）： 用户界面包 业务处理包 数据访问包 权限管理包 异常处理包 系统物理体系结构： 系统构件图 系统部署图 代码 顺序码（序列码）：用连续数字作为每个实体的标识 重复码：采用与原来手工系统相同的编码 成组码（分组码）：将代码分为几段，每段表示一种含义，每段都由连续数字组成 表意码（助记码）：将表示实体特征的文字、数字或记号直接作为编码 专用码：具有特殊用途的编码 层次码：以分类对象的从属层次关系为排列顺序的一种代码 自检码：检测代码正确性 代码设计基本原则 唯一性 简单性 易识别性 可扩充性 合理性 规范性 系统性 代码设计步骤 确定代码对象 考查是否已有标准代码 根据代码的使用范围，使用时间和实际情况选择代码的类型 考虑检错功能 编写代码表 耦合度：描述了两个子系统之间依赖关系的程度 聚合度：描述了子系统内部多个彼此相关的对象的依赖程度 面向对象数据库优势 更易于掌握 支持复杂应用 存储大型数据结构 直接引用对象 自检码：本体码+附加码（校验码） 校验码：加权取余 代码表：文件到表，清单（P88） 代码：信息编码，是人为确定的用以代表客观事物（实体）名称、属性或状态等的有序符号，是实体明确的、唯一的标识 ER图：描述现实世界概念结构模型的有效方法。是表示概念模型的一种方式，用矩形表示实体型，矩形框内写明实体名;用椭圆表示实体的属性，并用无向边将其与相应的实体型连接起来;用菱形表示实体型之间的联系，在菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型(1:1,1:n或m:n)。 文档库：一个文件夹，其中共享文件的集合而且文件经常使用同一模板。库中的每个文件都与该库的内容列表中显示的用户定义信息相关联 数据库：长期存储在计算机内的，有组织，可共享的数据的集合。数据库中的数据按一定的数学模型组织、描述和存储，具有较小的冗余，较高的数据独立性和易扩展性，并可为各种用户共享 SQL Server：一个全面的数据库平台，使用集成的商业智能（BI）工具提供了企业级的数据管理。为关系型数据和结构化数据提供了更安全可靠的存储功能，使得可以构建和管理用于业务的高可用和高性能的数据应用程序 MYSQL：一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库里，增加了速度并提高了灵活性 系统设计阶段的主要工作可以划分为系统总体结构设计和 系统详细设计两个方面 123OOD的英文全称Object Oriented Design，中文全称面向对象设计CBSE的英文全称Component-based software engineering，中文全称基于组件的软件工程DBMS的英文全称database management system，中文全称数据库管理系统 数据库系统组成 数据库 硬件：构成计算机系统的各种物理设备 软件：操作系统、数据库管理系统及应用程序 人员：系统分析员和数据库设计人员、应用程序员、最终用户 数据库设计的基本要求 使整个系统可以迅速、方便、准确地调用和管理所需的数据 要从系统观点出发，根据用户需要设计基本数据库和中间数据库的结构，并对系统的应用程序提供透明的应用程序结构，降低数据和应用程序之间的耦合性 建立一个合适的数据模型： 满足用户需求 满足某个数据库管理系统的要求 具有较高的范式 第五章等价类划分（P106） 程序设计的基本要求 正确性：对程序设计质量的最基本要求 可靠性：程序正常工作的能力 可阅读性：层次清楚、简洁明了、便于阅读 可维护性 高效性 Java Web技术：用Java技术来解决相关web互联网领域的技术总和 JSP：一种动态网页技术标准。在传统的网页HTML文件中加入Java 程序片段和JSP标签 设备冗余技术：在系统中有两套硬件设备，以双工或双机方式工作，用冗余的设备来防止万一发生的硬件故障 信息系统审计：一个通过收集和评价审计证据，对信息系统是否能够保护资产的安全、维护数据的完整、使被审计单位的目标得以有效地实现、使组织的资源得到高效地使用等方面作出判断的过程 123MVC是模型Model、视图View、控制Controller 的缩写CMMI的英文全称Capability Maturity Model Integration，中文全称能力成熟度综合模型PCMM的英文全称People Capability Maturity Model，中文全称人力资源能力成熟度模型 软件测试的目标：尽可能多地发现错误 软件测试原则 软件测试应纳入到软件开发的各个阶段的技术评审工作中 测试用例应由测试输入数据和与之对应的预期输出结果这两部分组成 测试工作应尽量避免完全由原开发软件的个人或小组来承担 在设计测试用例时，应当包括合理的输入条件和不合理的输入条件 充分注意测试中的群集现象 严格执行测试计划 应当对每一个测试结果做全面检查 妥善保存测试计划，测试用例，出错统计和最终分析报告，为维护提供方便 Java Servlet是JSP的技术基础 在Java Web技术中，“模型层”的角色可以使用Java Bean来实现。 软件测试的基本步骤 单元（模块）测试：模块接口测试 集成测试：对系统的接口及集成后的功能进行正确校验的测试工作 确认测试（有效性测试）：验证软件的功能和性能及其特性是否与用户的要求一致 系统测试：对计算机系统进行一系列的组装测试和确认测试 验收测试：确保软件准备就绪，并且可以让最终用户将其用于执行软件的既定功能和任务 软件测试的基本过程（画图如P103） 拟定测试计划 编制测试大纲 设计和生成测试用例 实施测试 生成测试分析报告 验收测试的工作流程（画图如P104） 系统测试方法： 人工测试（代码复审）：个人复查、走查、会审 机器测试： 黑盒测试：等价分类、边界值分析、对比测试 白盒测试：基本路径测试、逻辑覆盖测试、面向对象测试 系统排错（系统调试）：查找、分析和纠正软件中错误的过程 确定程序中可疑错误的确切性质和位置 对程序设计、程序编码进行修改，排除错误 系统排错方法 强行排错法 回溯法排错 原因排除法 对分查找法：注入“正确值” 归纳法：收集有关数据、组织数据、提出假设、证明假设 演绎法：列举假设，排除不正确的假设，改进余下假设，证明余下假设 系统说明文件： 系统一般性文件：用户手册、系统规程、特殊说明 系统开发报告：系统分析说明书、系统设计说明书、系统实施说明、系统利益分析报告 系统说明书 操作流程：系统规程、系统的操作顺序、系统使用说明书 培训人员：事务管理人员、系统操作员、系统维护人员 系统转换方式：直接转换、并行转换、试点后转换、逐步转换 系统维护内容 数据的维护 代码的维护 硬件与系统软件的维护 突发事件的处理 应用软件的维护：完善性维护、适应性维护、更正性维护、预防性维护 在应用软件整个维护阶段所花费的工作中，完善性维护所占比重最大 整体界面测试的工作是系统测试 系统维护过程：变更请求、领导审批、分配任务、系统分布、验收、变更实现 IDEAL模型组织改进模型，作为启动、规划和指导改进行动和一种路标，定义了一个系统化的五阶段持续改进 启动：明确改进的动机，建立改进的支持和责任 诊断：弄清现行过程的状态，确认要解决的问题 建立：针对评估发现的薄弱环节，选择和规划详细的改进活动 行动：投入必要的资源，设计、试验、执行和制度化改进 推进：了解改进的成效和存在的问题，确认在IDEAL活动中的改进 进行输入界面设计：HTML的表单对象 进行输出界面设计：HTML的表格对象 业务网站不属于软件作品的半成品 状态图:为一个类、对象、子系统或整个系统等进行动态行为建模 鲁大师：检查实验中计算机硬件配置信息的工具 信息系统项目团队协同创新体系：目标体系、管理体系、保障体系、内容体系、评价体系 userRegister.jsp输入控制对象是Form Java在客户端的应用有Java Applet 关联关系：UML用例图中描述参与者与用例之间关系 泛化关系：UML用例图中描述参与者之间关系 Java Web技术访问MySQL数据库的TCP端口是3306，而访问SQL Server数据库的是1433 罗伯特·卡茨模型：有效的管理者必须具备三种技能，技术技能（基层）、人际技能、概念技能（高层） 数字化企业关键角色： 总经理CEO 首席信息官CIO 采购总监P.D. 生产总监P.M. 市场总监CMO 财务总监CFO 人事总监HRD 信息中心主任 首席安全主管CSO 首席隐私保密官CPO 首席知识官CKO 实战演练运作和协调机构：指挥中心、研讨厅、市场管理机构 12345678910111213对象 范围 类型 位数 校验位 期限 结构 示例 备注成员编号 校内 层次码 11 无 无 前2位数是指年级，... 15251101181 姓名 性别 职务 照片 QQ号 身份证号 注册界面文件 注册功能实现文件 登录界面文件 登录功能实现文件 增加档案界面文件 [略][略][略]]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2017%2F11%2F07%2F%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%91%98%2F</url>
    <content type="text"><![CDATA[计算机网络的演变过程 具有通信功能的单机系统阶段 具有通信功能的多机系统阶段 以共享资源为主的计算机网络阶段 以局域网络及其互联为主要支撑环境的分布式计算机阶段 互联网应用高速普及，局域网与广域网应用逐渐融合的阶段 计算机网络的基本组成： 硬件系统（网络设备）： 网络服务器 各用户主机 网络设备集中连接的集线器或者交换机 接口卡 拨号或其他接入方式的终端设备 连接不同网络的网桥或者路由器 软件系统： 网络通信协议：TCP/IP、IPX/SPX、PPP、SNMP、HTTP、FTP 网络操作系统：UNIX、Windows 2000 Server/Server 2003 网络应用软件 计算机网络的主要作用： 数据通信：实现计算机与终端、计算机与计算机间的数据传输。 资源共享：通过计算机局域网，网络中各计算机上的资源可实现共享，从而节省开支，提高工作效率 集中管理：网络上各用户的数据集中存在一台服务器上，可通过设置不同用户的访问权限和数据容灾策略，确保数据的安全访问与使用 远程传输：相聚很远的用户可以互相传输数据信息，互相交流，协同工作 分布式处理：对于大型的课题，可以分为许许多多的小课题，由不同的计算机分别完成，然后再集中起来解决问题 负载均衡：把复杂的工作均匀地分配给网络上的各台计算机上进行 按网络的分布范围分类： 局域网LAN特点： 私有服务：完全出于私用，不会为无关人员提供服务 分布范围较小：一般采用双绞线作为传输介质，信号在单段双绞线上的最远有效传输距离为100m，大型局域网使用同轴电缆和光纤的传输距离在2km范围以内 结构简单，布线容易：网络结构相对较为简单，只需满足自身的网络应用需求 网络速度较快： 城域网MAN： 在一个较大的地理区域内提供数据、声音和图像的传输 提供公共服务 广域网WAN： 联网设备分布范围广 成本昂贵 提供公共服务，也有专用服务 按数据的交换方式分类： 电路交换网：在用户开始通信前，先申请建立一条从发送端到接收端的物理信道，并且在双方通信期间始终占用该信道 报文交换网：把要发送的数据及目的地址包含在一个完整的报文内，报文的长度不受限制。报文交换采用存储-转发原理，每个中间节点要为途径的报文选择适当的路径，使其能最终到达目的端。 分组交换网：在通信前，发送端先把要发送的数据划分为一个个等长的单位（即分组），这些分组逐个由各中间节点采用“存储-转发”方式进行传输，最终到达目的端。 按网络的传输介质： 有线网： 双绞线网 同轴电缆网 光纤网 无线网 无线局域网WLAN 蓝牙网 红外线网 按网络的通信方式： 点对点传播方式网：数据以点到点的方式在计算机或通信设备中传输 广播式传播结构网：数据在公用介质中传输 按网络的服务方式： 对等网：不要求专用服务器，每台客户机都可以与其他各台客户机对话，共享彼此的信息资源和硬件资源 客户机/服务器（C/S）：服务器指专门提供服务的高性能计算机或专用设备，客户机指用户计算机 网络拓扑结构：从逻辑上表示出对网络服务器、工作站的网络配置和互相之间的连接方式，在一定程度上可以说是指网络电缆构成的几何形状 有线局域网拓扑结构： 星形拓扑结构：以中央节点为中心，然后再与各节点连接而形成的（主要应用以太局域网） 中央节点的主要功能： 为需要通信的设备建立物理连接 在两台设备通信过程中维持这一通道 在完成通信或通信不成功时，拆除通道 优点： 网络结构简单 便于管理、集中控制 网络成本低，组网容易 网络带宽宽，传输速率高 延迟时间短，误码率低 缺点： 网络共享能力较差 通信线路利用率不高 中央节点负担过重 环形拓扑结构：环形网中各节点通过环路接口连在一条首尾相连（真正的物理连接）的闭合环形通信线路中 优点： 网络路径选择和网络组建简单 投资成本低 缺点： 连接用户数非常少 传输速度慢 传输效率低 维护困难 扩展性能差 总线型拓扑结构：用一条称为中央总线的主电缆（通常为同轴电缆或光纤），将相互之间以线性方式连接的工作站连接起来 终接器：与地连接，以抵消两端的信号反射 优点： 通信费用少 总线网络的扩展非常方便 高可靠性 较小的时延 缺点： 故障诊断困难 故障隔离比较困难 网络效率和传输性能不高 不易扩展 网络覆盖范围受到限制 树形拓扑结构：在网络结构形状上类似于树的“树干-树枝-树叶”分层结构，结合了星形结构网络的易扩展性和高连接速率，以及总线型的传输距离长 网状拓扑结构：网络的每台设备之间均有点到点的链路连接，任一个节点至少有两条线路与其他节点相连 无线局域网的拓扑结构： Ad-Hoc模式：点对点连接方式，连接性能较差，网络结构简单 基于AP的Infractructure结构：各无线用户需要安装无线网卡，还需要一个用于集中连接各无线用户的无线AP 优点： 网络易于扩展 便于集中管理 能提供用户身份验证 开放系统互联OSI：网络系统结构—七层参考模型 网络通信功能的七个层次 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 低三层：负责创建网络通信连接的链路 高四层：具体负责端到端的数据通信 OSI参考模型对各个层次的划分遵循下列原则： 同一层中的各网络节点都有相同的层次结构，具有同样的功能 同一节点内相邻层之间通过接口（可逻辑接口）进行通信 七层结构中的每一层使用下一层提供的服务，并向其上层提供服务 不同节点的同等层按照协议实现对等层之间的通信 封装：当数据沿着OSI模型的各层向下传递时，它就会被增加上数据报头、数据报尾和其他信息 通信步骤： 创建数据（应用层、表示层、会话层） 为端到端的传输将数据打包（传输层） 在报头上附加网络地址（网络层） 附加本地地址（MAC地址）到数据链路报头（数据链路层） 为进行传输而转换为比特（物理层） 解封装： 读取物理地址和由直接相连的对等数据链路层所提供的控制信息 从该帧剥离此控制信息并由此创建一个数据报 遵照在帧的控制部分中出现的内容把数据报向上传送到相邻层]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库技术]]></title>
    <url>%2F2017%2F09%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[软件工程：为了提高软件质量，加快软件开发进度，降低开发费用。即用工程的概念、原理、技术和方法对软件生产、开发的全过程进行跟踪和管理。 软件开发方法：1、瀑布模型：&nbsp;&nbsp;⑴项目规划&nbsp;&nbsp;⑵系统分析&nbsp;&nbsp;⑶总体设计&nbsp;&nbsp;⑷详细设计&nbsp;&nbsp;⑸编码调试与集成测试&nbsp;&nbsp;⑹运行维护2、快速原型模型：&nbsp;&nbsp;⑴快速分析&nbsp;&nbsp;⑵设计构造原型&nbsp;&nbsp;⑶运行原型&nbsp;&nbsp;⑷评价原型&nbsp;&nbsp;⑸改进原型3、螺旋模型：&nbsp;&nbsp;⑴项目规划&nbsp;&nbsp;⑵风险评估&nbsp;&nbsp;⑶工程实现&nbsp;&nbsp;⑷用户评估 规划与分析：（一）系统规划与定义： &nbsp;&nbsp;&nbsp;1、任务陈述 &nbsp;&nbsp;&nbsp;2、确定任务目标 &nbsp;&nbsp;&nbsp;3、确定系统范围与边界 &nbsp;&nbsp;&nbsp;4、确定用户视图（二）可行性分析： &nbsp;&nbsp;&nbsp;1、经济可行性 &nbsp;&nbsp;&nbsp;2、技术可行性 &nbsp;&nbsp;&nbsp;3、操作可行性 &nbsp;&nbsp;&nbsp;4、开发方案选择（三）项目规划 &nbsp;&nbsp;&nbsp;需求分析：&nbsp;&nbsp;&nbsp;1、 数据需求分析：数据字典通过对数据项和数据结构的定义来描述数据流和数据存储的逻辑内容&nbsp;&nbsp;&nbsp;2、功能需求分析：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑴数据处理需求分析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵业务规则需求分析&nbsp;&nbsp;&nbsp;3、性能需求分析 &nbsp;&nbsp;&nbsp;指标： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑴数据操作（访问）响应时间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵系统吞吐量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶允许并发访问的最大用户数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑷每TPS代价值 &nbsp;&nbsp;&nbsp;性能的主要因素： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑴系统硬件资源&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵网络通信设备性能&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶操作系统环境&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑷数据库的逻辑设计和物理设计质量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑸DBMS的配置和性能&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑹数据库应用程序自身&nbsp;&nbsp;&nbsp;4、其他需求分析：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑴存储需求分析：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①初始数据库大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②数据库增长速度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵安全性需求分析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶备份和恢复需求分析 &nbsp;&nbsp;&nbsp;系统设计&nbsp;&nbsp;&nbsp;1、概念设计：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑴数据库概念模型设计&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵系统总体设计&nbsp;&nbsp;&nbsp;2、逻辑设计：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑴数据库逻辑结构设计&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵应用程序概要设计&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶数据库事务概要设计&nbsp;&nbsp;&nbsp;3、物理设计：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑴数据库物理结构设计&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵数据库事务详细设计&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶应用程序详细设计 &nbsp;&nbsp;&nbsp;实现与部署：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑴建立数据库结构&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵数据加载&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶事务和应用程序的编码及测试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑷系统集成&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑸测试与试运行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑹系统部署 &nbsp;&nbsp;&nbsp;运行管理与维护：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑴日常维护&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵监控与分析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶性能优化调整&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑷系统进化 DBAS生命周期模型：规划与分析-&gt;需求分析-&gt;系统设计-&gt;系统实现和部署-&gt;运行维护 需求分析：对待开发的系统要做什么，完成什么功能的全面描述 需求获取困难：&nbsp;&nbsp;①软件功能复杂&nbsp;&nbsp;②需求的可变性&nbsp;&nbsp;③软件产品的不可见性 需求获取的方法：&nbsp;&nbsp;①面谈&nbsp;&nbsp;②实地观察&nbsp;&nbsp;③问卷调查&nbsp;&nbsp;④查阅资料 需求分析过程：&nbsp;⑴标识问题&nbsp;⑵建立需求模型&nbsp;⑶描述需求&nbsp;⑷确认需求 需求分析方法1、DFD： &nbsp;⑴数据流、处理、数据存储、外部项&nbsp;⑵建模过程：&nbsp;&nbsp;&nbsp;&nbsp;①明确目标，确定系统范围 &nbsp;&nbsp;&nbsp;&nbsp;②建立顶层DFD图 &nbsp;&nbsp;&nbsp;&nbsp;③构建第一层DFD分解图 &nbsp;&nbsp;&nbsp;&nbsp;④开发DFD层次结构图 &nbsp;&nbsp;&nbsp;&nbsp;⑤检查确认DFD图 2、IDEF0：箭头、活动（强调数据约束） 数据库结构设计概念设计：1、依据：需求分析阶段的文档 2、过程：⑴明确建模目标 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵定义实体集 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶定义联系 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑷建立信息模型 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑸确定实体集属性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑹对信息模型进行集成与优化 数据建模方法： 1、ER建模方法 2、IDEF1X建模方法逻辑设计：把数据库概念设计的结果（ER模型），转换为具体的数据库管理系统支持的数据模型 索引技术：&nbsp;&nbsp;⑴有序索引 &nbsp;&nbsp;⑵散列技术 物理设计：&nbsp;&nbsp;⑴数据库逻辑模式描述：&nbsp;&nbsp;&nbsp;&nbsp;①面向目标数据库描述基本表和视图&nbsp;&nbsp;&nbsp;&nbsp;②设计基本表业务规则 &nbsp;&nbsp;⑵文件组织与存取设计 &nbsp;&nbsp;⑶数据分布设计： &nbsp;&nbsp;&nbsp;&nbsp;①不同类型数据的物理分布 &nbsp;&nbsp;&nbsp;&nbsp;②应用数据的划分与分布 &nbsp;&nbsp;&nbsp;&nbsp;③派生属性数据分布 &nbsp;&nbsp;&nbsp;&nbsp;④关系模式的去规范化 &nbsp;&nbsp;⑷确定系统配置 &nbsp;&nbsp;⑸物理模式评估 软件设计： 1、概要设计：建立软件系统的总体结构和模块间的关系，定义各功能模块的接口，设计全局数据库或数据结构，规定设计约束，指定测试计划 2、详细设计：细化概要设计产生的功能模块，形成可编程的程序模块 DBAS总体设计： DBAS体系结构设计：&nbsp;&nbsp;⑴客户/服务器体系结构&nbsp;&nbsp;⑵浏览器/服务器结构：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①表示层位于客户端&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②功能层位于Web应用服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③数据层位于数据库服务器 DBAS软件总体设计 软硬件选型与配置设计 业务规则初步设计 DBAS功能概要设计：1、表示层概要设计 2、业务逻辑层概要设计 3、数据访问层概要设计 DBAS功能详细设计：1、 表示层详细设计（原型迭代法）： &nbsp;&nbsp;①初步设计 &nbsp;&nbsp;②用户界面细节设计 &nbsp;&nbsp;③原型设计与改进 2、业务逻辑层详细设计 数据安全设计：1、数据库的安全性保护： &nbsp;&nbsp;①用户身份鉴别 &nbsp;&nbsp;②权限控制 &nbsp;&nbsp;③视图机制 2、数据库的完整性保护 3、数据库的并发控制： &nbsp;&nbsp;①按同一顺序访问资源 &nbsp;&nbsp;②避免事务中的用户交互 &nbsp;&nbsp;③采用小事务模式，尽量缩短事务的长度，减少占有锁的时间 &nbsp;&nbsp;④尽量使用记录级别的锁（行锁） &nbsp;&nbsp;⑤使用绑定连接 4、数据库的备份与恢复： &nbsp;&nbsp;①双机热备 &nbsp;&nbsp;②数据转储 &nbsp;&nbsp;③数据加密存储 5、数据加密传输： &nbsp;&nbsp;①数字安全证书&nbsp;&nbsp;②对称密钥加密&nbsp;&nbsp;③数字签名&nbsp;&nbsp;④数字信封 环境安全设计：1、漏洞与补丁 2、计算机病毒防护:⑴安装杀毒软件，定期查杀病毒 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵计算机实时监控 3、网络环境安全：⑴防火墙 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵入侵检测系统 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶网络隔离 4、物理环境安全 DBAS实施：1、创建数据库： &nbsp;&nbsp;⑴初始空间大小 &nbsp;&nbsp;⑵数据库增量大小 &nbsp;&nbsp;⑶访问性能 2、数据装载： &nbsp;&nbsp;⑴筛选数据 &nbsp;&nbsp;⑵转换数据格式 &nbsp;&nbsp;⑶输入数据 &nbsp;&nbsp;⑷校验数据 3、编写与调试应用程序 4、数据库系统试运行： &nbsp;&nbsp;⑴功能测试&nbsp;&nbsp;⑵性能测试 统一建模语言UML：1、元元模型层：事物 2、元模型层：基本元素 3、模型层：模型 4、用户模型层：UML模型的实例 视图：对系统的模型在某方面的投影 业务流程与活动图： &nbsp;&nbsp;&nbsp;&nbsp;活动图主要用于描述系统、用例和程序模块中逻辑流程的先后执行次序，并行次序 在一张活动图中，必须有且只能有一个起始点，可以有多个结束点 系统需求与用例图用例模型：把满足用户需求的所有功能表示出来的工具⑴用例：所有动作的集合 &nbsp;&nbsp;&nbsp;①扩展关系 &nbsp;&nbsp;&nbsp;②使用关系 &nbsp;&nbsp;&nbsp;③组合关系 ⑵角色：与系统进行交互的外部实体 ⑶系统：抽象地表示能够实现的所有基本功能 系统结构与类图（系统可以有多个类图）类图：问题领域的概念模型 ⑴属性：①可见性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②名称 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③类型 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④缺省值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤约束性 ⑵操作：①可见性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②名称 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③参数表 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④返回类型表达式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤约束性 ⑶关系：①关联关系：聚集（特殊关联） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②继承关系 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③依赖关系 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④精化关系 系统结构与顺序图 &nbsp;&nbsp;顺序图：描述系统内对象之间的消息发送和接收序列系统结构与通信图： &nbsp;&nbsp;通信图（协作图）：展示对象之间的联系以及对象间发送和接收的消息微观设计与对象图： &nbsp;&nbsp;对象图：系统在某一时间点的“快照”微观设计与状态机图： &nbsp;&nbsp;状态图：陈述系统中有关事件或对象的状态转移微观设计与时间图： &nbsp;&nbsp;时间图：描述时间对状态变化的影响宏观设计与包图： &nbsp;&nbsp;包图：表明包以及包之间的关系的类图 &nbsp;&nbsp;包的可见性：私有、保护、公有和实现宏观设计与交互概述图： &nbsp;&nbsp;交互概述图：把不同的交互图组合在同一张图来表达宏观设计与复合结构图： &nbsp;&nbsp;复合结构图：绘制要开发的系统与外部系统间的关系系统实现与组件图： &nbsp;&nbsp;组件图：逻辑设计中定义的概念和功能在物理架构中的实现图系统实现与部署图： &nbsp;&nbsp;部署图（配置图）：描述系统中硬件和软件的物理配置情况和系统体系结构 高级数据查询：1、使用top限制结果集 2、使用case函数：⑴简单case函数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ⑵搜索case函数 3、将查询结果保存到新表中：select into子句 4、查询结果的运算：⑴并运算：union &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵交运算：intersect &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶差运算：except 5、相关子查询：必须包含SELECT子句和FROM子句，并可以根据需要选择WHERE子句、GROUP BY子句和HAVING子句 6、开窗函数：over子句前 数据库及数据库对象SQL Server数据库管理系统：⑴系统数据库：自动创建和维护的 &nbsp;&nbsp;①master：记录SQL Server实例的所有系统级信息 &nbsp;&nbsp;②msdb：保存关于调度报警、作业、操作员等信息 &nbsp;&nbsp;③model：用作SQL Server实例上创建的所有数据库的模板 &nbsp;&nbsp;④tempdb：临时数据库，用于保存临时对象或中间结果集 &nbsp;&nbsp;⑤Resource：只读数据库，包含SQL Server的所有系统对象 ⑵用户数据库：保存与用户的业务有关的数据 操作系统文件：1、数据文件：存放数据库数据&nbsp;&nbsp;⑴主要数据文件（.mdf）：有且只能有一个&nbsp;&nbsp;⑵次要数据文件（.ndf）：可不包含，可包含多个 2、事务日志文件（.ldf）：用于存放恢复数据库的所有日志信息，至少一个 3、数据库空间分配原则： &nbsp;&nbsp;①在创建用户数据库时，model数据库自动被复制到新建用户数据库，且复制到主要数据文件 &nbsp;&nbsp;②行不能跨页存储 数据库文件组：1、主文件组：系统表的所有页均分配在主文件组中 2、用户定义文件组： &amp;nbsp;&amp;nbsp;①日志空间与数据空间是分开管理的 &amp;nbsp;&amp;nbsp;②一个文件不可以是多个文件组的成员 数据库文件的属性：1、文件名及其位置：逻辑/物理文件名 2、初始大小：主要数据文件的初始大小不能小于model数据库主要数据文件的大小 3、增长方式：默认自动增长 4、最大大小（文件增长的最大空间限制）：默认无限制 修改数据库：1、扩大数据库空间： &nbsp;&nbsp;⑴扩大数据库中已有文件的大小 &nbsp;&nbsp;⑵为数据库添加新的文件 2、收缩数据库空间： &nbsp;&nbsp;⑴收缩整个数据库的大小 &nbsp;&nbsp;⑵收缩指定文件的大小 &nbsp;&nbsp;&nbsp;&nbsp;收缩数据库：释放数据库中未使用的空间，并将释放的空间交还给操作系统 &nbsp;&nbsp;&nbsp;&nbsp;文件的收缩都是从末尾开始的 3、添加和删除数据库文件： &nbsp;&nbsp;⑴添加文件 &nbsp;&nbsp;⑵删除文件：只有当文件完全为空时，才可以从数据库中删除文件 分离和附加数据库（实现将数据库从一台数据库服务器移动到另一台数据库服务器）1、分离数据库：将数据库从SQL Server实例中删除，但不删除数据库的数据文件和日志文件。即让数据库的文件不受数据库管理系统的管理 2、附加数据库：将分离的数据库重新附加到数据库管理系统中。必须指定主要数据文件的物理存储位置和文件名 架构：一个数据库可以包含一个或多个架构 分区表：1、将表中的数据按水平方式划分成不同的子集2、适合分区：&nbsp;&nbsp;&nbsp;&nbsp;⑴包含以多种不用方式使用的大量数据 &nbsp;&nbsp;&nbsp;&nbsp;⑵数据是分段的 3、创建分区表： &nbsp;&nbsp;&nbsp;&nbsp;⑴创建分区函数 &nbsp;&nbsp;&nbsp;&nbsp;⑵创建分区方案 &nbsp;&nbsp;&nbsp;&nbsp;⑶使用分区方案创建表 索引：为了加快数据的查询速度&nbsp;&nbsp;1、unique：唯一索引不允许两行具有相同的索引键值 &nbsp;&nbsp;2、clustered：创建聚集索引 &nbsp;&nbsp;3、先创建聚集索引，再创建非聚集索引 索引视图（物化视图）：建有唯一聚集索引的视图1、适合： &nbsp;&nbsp;⑴处理大量行的连接和聚合 &nbsp;&nbsp;⑵许多查询经常执行的连接和聚合操作 2、不适合： &nbsp;&nbsp;⑴具有大量写操作的OLTP系统 &nbsp;&nbsp;⑵具有大量更新操作的数据库 &nbsp;&nbsp;⑶不涉及聚合或连接的查询 &nbsp;&nbsp;⑷GROUP BY列具有高基数度的数据聚合 3、定义索引视图： &nbsp;&nbsp;⑴只能引用基本表 &nbsp;&nbsp;⑵引用的所有基本表必须与视图位于同一个数据库中，所有者相同 &nbsp;&nbsp;⑶必须使用SCHEMABINDING选项创建视图 &nbsp;&nbsp;⑷视图中的表达式引用的所有函数必须是确定的 &nbsp;&nbsp;⑸对视图创建的第一个索引必须是唯一聚集索引 存储过程：存储在数据库中供所有用户程序调用的子程序&nbsp;&nbsp;①在客户端存储代码 &nbsp;&nbsp;②以子程序的形式将程序模块存储在数据库中 使用存储过程的好处有：&nbsp;&nbsp;⑴允许模块化程序设计 &nbsp;&nbsp;⑵改善性能 &nbsp;&nbsp;⑶减少网络流量 &nbsp;&nbsp;⑷增强应用程序的安全性 参数的传递方式：&nbsp;&nbsp;①按参数位置传递值 &nbsp;&nbsp;②按参数名传递值 用户定义函数：1、标量函数：只返回单个数据值。调用时提供函数拥有者名和函数名 2、表值函数：返回一个表。 &nbsp;&nbsp;&nbsp;&nbsp;①内联表值函数：一个查询语句的结果，调用时需放在from子句部分 &nbsp;&nbsp;&nbsp;&nbsp;②语句表值函数：视图和存储过程的组合，调用时放在from子句部分 触发器：不需要由用户来直接调用，在对表中的数据进行update、insert或delete操作时自动触发执行的 触发器适用场合：&nbsp;&nbsp;⑴完成比check约束更复杂的数据约束 &nbsp;&nbsp;⑵为保证数据库性能而维护的非规范化数据 &nbsp;&nbsp;⑶可实现复杂的商业规则 &nbsp;&nbsp;⑷可评估数据修改前后的表状态，并根据其差异采取对策 触发器类型：&nbsp;&nbsp;⑴DML触发器：DML事件 &nbsp;&nbsp;⑵DDL触发器：DDL事件 &nbsp;&nbsp;⑶登录触发器：LOGIN事件 创建触发器：&nbsp;&nbsp;⑴在一个表中可建立多个名称不同、类型各异的触发器 &nbsp;&nbsp;⑵可使用if update子句来测试insert和update语句是否对指定字段有影响 &nbsp;&nbsp;⑶通常不要在触发器中返回任何结果 后触发器：使用for或after定义的、只有在引发触发器执行的语句中的操作都已成功执行，并且所有的约束检查也成功完成后，才执行触发器 check约束只能实现同一个表中列之间的取值约束 前触发器：使用instead定义的、指定执行触发器而不是SQL语句，从而替代引发语句 游标：1、游标结果集：定义游标的select语句返回的结果的集合 2、游标当前行指针：指向该结果集中的某一行的指针 游标的特点：&nbsp;&nbsp;⑴允许定位结果集中的特定行 &nbsp;&nbsp;⑵允许从结果集的当前位置检索一行或多行 &nbsp;&nbsp;⑶支持对结果集中当前行的数据进行修改 &nbsp;&nbsp;⑷为由其他用户对显示在结果集中的数据所做的更改提供不同级别的可见性文件 使用游标：&nbsp;&nbsp;⑴声明游标：定义服务器端游标的特性 &nbsp;&nbsp;⑵打开游标：open &nbsp;&nbsp;⑶提取数据：fetch语句，从游标结果集中按行提取 &nbsp;&nbsp;⑷关闭游标：close &nbsp;&nbsp;⑸释放游标：deallocate 安全管理&nbsp;&nbsp;安全性：保护数据以防止不合法用户故意造成的破坏&nbsp;&nbsp;完整性：保护数据以防止合法用户无意中造成的破坏 数据库安全控制的目标：保护数据免受意外或故意的丢失、破坏或滥用 全面的数据库安全计划情况：&nbsp;&nbsp;⑴可用性的损失 &nbsp;&nbsp;⑵机密性数据的损失 &nbsp;&nbsp;⑶私密性数据的损失 &nbsp;&nbsp;⑷偷窃和欺诈 &nbsp;&nbsp;⑸意外的损害 授权：将合法访问数据库或数据库对象的权限授予用户认证：一种鉴定用户身份的机制 自主存取控制：用户对不同的数据对象具有不同的存取权限（通过授权机制来有效控制对敏感数据的存取） 1、对数据库管理系统进行维护的权限 2、对数据库中的对象和数据进行操作的权限 &nbsp;&nbsp;①对数据库对象的操作权限：语句权限 &nbsp;&nbsp;②对数据库数据的操作权限：对象权限 3、隐含权限：用户自动具有的权限，不能被更改 4、用户分类： &nbsp;&nbsp;⑴系统管理员 &nbsp;&nbsp;⑵数据库对象拥有者 &nbsp;&nbsp;⑶普通用户 强制存取控制：每一个数据对象被标以一定的密级，每一个用户也被授予一个许可证级别1、主体：系统中的活动实体，包括DBMS所管理的实际用户，和代表用户的各个进程 2、客体：系统中的被动实体，受主体操纵的，包括文件、基本表、索引、视图等 3、敏感度标记： &nbsp;&nbsp;①绝密Top Secret&nbsp;&nbsp;②秘密Secret&nbsp;&nbsp;③可信Confidential&nbsp;&nbsp;④公开Public &nbsp;&nbsp;&nbsp;&nbsp;⑴主体：许可证级别 &nbsp;&nbsp;&nbsp;&nbsp;⑵客体：密级 审计跟踪：特殊的文件或数据库，自动记录用户对常规数据的所有操作 统计数据库：允许用户查询聚合类型的信息 任意两个查询的相交数据项不能超过M个 身份验证模式：1、Windows身份验证模式 2、混合身份验证模式 默认情况下，新建立的数据库只有一个用户：dbo，它是数据库拥有者 角色：系统管理员只需对权限的种类进行划分，然后将不同的权限授予不同的角色，而不必关心有哪些具体的用户⑴①系统角色 &nbsp;&nbsp;&nbsp;②用户定义角色⑵①固定服务器角色：完成特定服务器级管理活动 &nbsp;&nbsp;&nbsp;②固定数据库角色：用户不能添加删除或更改固定数据库角色，但可以将数据库用户添加到固定数据库角色中 Oracle数据库：1、用户：&nbsp;&nbsp;①DBA用户：在数据库系统安装时由DBMS自动创建生成的，sys、system，拥有全部的系统特权 &nbsp;&nbsp;②普通用户：由DBA用户或具有相应特权的用户创建 2、默认角色： &nbsp;&nbsp;①Connect：不能在数据库中建立任何对象，但可以查询数据字典及访问有权限的数据库对象 &nbsp;&nbsp;②Resource：在数据库中建立关系表、视图、序列、索引、聚集、存储过程、存储函数、触发器、数据库链路 &nbsp;&nbsp;③DBA：拥有Oracle预定义的所有系统特权 数据库运行维护与优化数据库运行维护基本工作：1、数据库的转储与恢复2、数据库的安全性，完整性控制3、检测并改善数据库的性能4、数据库的重组和重构 运行状态监控与分析:1、自动监控机制2、手动监控机制：⑴对数据库构架体系的监控⑵对数据库性能的监控 数据库的存储结构：&nbsp;&nbsp;①逻辑存储结构&nbsp;&nbsp;②物理存储结构 对空间的管理：&nbsp;&nbsp;①创建数据库空间&nbsp;&nbsp;②更改空间大小&nbsp;&nbsp;③删除空间&nbsp;&nbsp;④修改空间状态&nbsp;&nbsp;⑤新建、移动、关联数据文件 数据库性能优化：&nbsp;&nbsp;①数据库运行环境&nbsp;&nbsp;②数据库参数调整&nbsp;&nbsp;③模式调整&nbsp;&nbsp;④数据库存储优化&nbsp;&nbsp;⑤查询优化 数据库运行环境与参数调整1、外部调整：&nbsp;&nbsp;①CPU&nbsp;&nbsp;②网络2、调整内存分配3、调整磁盘I/O4、调整竞争：&nbsp;&nbsp;①调整参数以控制连接到数据库的最大进程数&nbsp;&nbsp;②减少调度进程的竞争&nbsp;&nbsp;③减少多线程服务进程竞争&nbsp;&nbsp;④减少重做日志缓冲区竞争&nbsp;&nbsp;⑤减少回滚段竞争 模式调整与优化反规范化：将规范化的关系转换为非规范化的关系的过程&nbsp;&nbsp;1、增加派生性冗余列&nbsp;&nbsp;2、增加冗余列&nbsp;&nbsp;3、重新组表&nbsp;&nbsp;4、分割表&nbsp;&nbsp;5、新增汇总表 存储优化：1、物化视图：预先计算并保存表连接或聚集等耗时较多的操作结果，可进行远程数据的本地复制（快照：主要用于实施数据库间的同步）2、聚集&nbsp;&nbsp;①聚集码：多表中相关的列&nbsp;&nbsp;②聚集索引：为聚集对象建立的 索引的物理设计决策;1、是否为一个属性建立索引2、在哪些属性上建立索引3、是否建立聚簇索引4、使用散列索引还是树索引 索引使用原则：1、经常在查询中作为条件被使用的列2、频繁进行排序或分组的列3、一个列的值域很大4、有多个待排序的列，建立复合索引5、可以使用系统工具来检查索引的完整性，必要时进行修复6、删除并重建索引可以提高索引速度 调优的目的是动态地评估需求 过多的插入操作会导致聚簇索引的溢出 优化查询的常用方法：1、合理使用索引2、避免或简化排序：简化或避免对大型表进行重复的排序3、消除对大型表数据的顺序存放4、避免复杂的正则表达式5、使用临时表加速查询6、用排序来取代非顺序磁盘存取7、不充分的连接条件8、存储过程9、不要随意使用游标10、事务处理 故障管理：故障类型：1、事务内部的故障：&nbsp;&nbsp;⑴预期的事务内部故障：可以通过事务程序本身发现的事务内部故障&nbsp;&nbsp;⑵非预期的事务内部故障：不能由事务程序处理的 2、系统故障（软故障）：数据库在运行过程中，由于硬件故障、数据库软件及操作系统的漏洞、突然停电等情况，导致系统停止运转。将导致易失性存储器内容的丢失，而非易失性存储器内容仍然完好。 3、介质故障（硬故障）：指数据库在运行过程中，由于磁头碰撞、磁盘损坏、强磁干扰、天灾人祸等情况，使得数据库中的数据部分或全部丢失的一类故障 容错对策： &nbsp;&nbsp;⑴软件容错：使用数据库备份及事务日志文件，通过恢复技术，恢复数据库到备份结束时的状态&nbsp;&nbsp;⑵硬件容错：&nbsp;&nbsp;&nbsp;&nbsp;①采用双物理存储设备 &nbsp;&nbsp;&nbsp;&nbsp;②设计两套相同的数据库系统，通过数据库软件机制，同步变化数据 4、计算机病毒故障： &nbsp;&nbsp;①使用杀毒软件进行查杀 &nbsp;&nbsp;②用数据库备份文件，以软件容错的方式恢复数据库文件 故障：&nbsp;&nbsp;⑴对数据库本身的破坏&nbsp;&nbsp;⑵对数据库中数据的破坏 恢复的基本原理——————-冗余 数据库恢复：在故障发生时，能够利用存储在系统其他地方的冗余数据 ，来重建数据库中被破坏的或不正确的数据，把数据库从错误状态恢复到某一已知的正确状态，从而重新建立一个完整的数据库。 恢复机制：⑴如何建立冗余数据 ⑵如何利用冗余数据实施数据库恢复 数据转储（数据备份）：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库管理员DBA或数据库管理系统定期复制数据库，并将复制得到的数据存放到其他介质中的过程 静态转储：系统不能运行其他事务，不允许在转储期间对数据库有任何存取、修改活动。动态转储：允许转储操作和用户事务并发执行 数据转储机制：1、完全转储：对数据库中所有数据进行转储 2、增量转储：只复制上次转储后发生变化的文件或数据块 3、差量转储：对最近一次数据库完全转储以来发生的数据变化进行转储，恢复速度比增量转储快 多种转储方法结合使用⑴仅使用完全转储⑵完全转储加增量转储：每隔一段时间进行一次完全转储，在完全转储中间执行多次增量转储⑶完全转储加差量转储 ==日志文件：记录每个事务对数据库的修改操作== 日志文件作用：1、事务故障恢复和系统故障恢复必须使用日志文件 &nbsp;&nbsp;⑴故障恢复的两个基本操作：撤销事务UNDO、重做事务REDO&nbsp;&nbsp;⑵事务故障恢复：把相应的事务作撤销操作UNDO&nbsp;&nbsp;⑶系统故障恢复：&nbsp;&nbsp;&nbsp;&nbsp;①没有COMMIT或者ROLLBACK，撤销&nbsp;&nbsp;&nbsp;&nbsp;②既有BEGIN TRANSACTION记录，又有COMMIT记录 2、在动态转储方式中必须建立日志文件 3、在静态转储方式中，也可以使用日志文件 日志文件的格式：1、以记录为单位的日志文件 &amp;nbsp;&amp;nbsp;⑴开始标记 &nbsp;&nbsp;⑵结束标记&nbsp;&nbsp;⑶所有修改操作2、以数据块为单位的日志文件 &nbsp;&nbsp;⑴事务标识 &nbsp;&nbsp;⑵被更新的数据块 日志记录：&nbsp;&nbsp;①事务标识&nbsp;&nbsp;②操作对象&nbsp;&nbsp;③更新前数据的旧值&nbsp;&nbsp;④更新后数据的新值 登记日志文件的原则：1、登记的次序严格按并行事务执行的时间次序 2、必须先写日志文件，后写数据库 检查点的作用：最大限度的减少了数据库完全恢复时所必须执行的日志部分，让恢复子系统在登录日志文件期间动态地维护日志。 检查点记录内容：&nbsp;&nbsp;①建立检查点时刻所有正在执行的事务清单 &nbsp;&nbsp;②这些事务最近一个日志记录的地址 动态维护日志文件：&nbsp;&nbsp;①建立检查点 &nbsp;&nbsp;②保存数据库状态 写入数据库时间：在这个检查点建立之前或者这个检查点建立之时 基于检查点的恢复步骤：⑴从“重新开始文件”中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录⑵由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST &nbsp;&nbsp;&nbsp;&nbsp;两个事务清单： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①UNDO-LIST &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②REDO-LIST⑶从检查点开始正向扫描日志文件，直至日志文件结束⑷对UNDO-LIST中每个事务执行UNDO操作，对REDO-LIST中的每个事务执行REDO操作 ==廉价冗余磁盘阵列RAID系统：具有设备虚拟化的能力== RAID的冗余技术：1、镜像冗余：把所有的数据复制到其他的设备上或其他地方2、校验冗余：通过对成员磁盘上的数据执行异或XOR操作，得到其校验值，并存放在另外的校验磁盘上 服务器容错技术：为了解决服务器硬件异常问题而出现的解决方案 服务器接管过程：当运行服务器出现故障时，备用服务器将自身角色转换为运行服务器，接管原有运行服务器的资源&nbsp;&nbsp;接管资源：&nbsp;&nbsp;&nbsp;&nbsp;⑴共享存储资源 &nbsp;&nbsp;&nbsp;&nbsp;⑵服务器IP地址 脑裂：备用服务器由于无法连接到运行服务器，认为运行服务器异常，启动接管过程，强行接管服务器IP地址和共享存储。 数据库镜像：提高数据库可用性的解决方案。根据DBA的要求，自动把整个数据库或其中的关键数据复制到另一个磁盘上 数据库镜像优点：1、数据库镜像提供完整或接近完整的数据冗余，增强数据保护功能 2、发生灾难时，数据库镜像可快速使数据库的备用副本提供服务，使数据不会丢失，提高数据库的可用性 3、提高镜像数据库在升级期间的可用性 数据库镜像的基本架构：1、双机互备援模式：两台主机均为工作机 2、双机热备份模式：一台主机为工作机，另一台主机为备份机 工作方式：在任何给定的时间，都是一个扮演主体角色，另一个扮演镜像角色 由于数据库镜像是通过复制数据实现的，频繁地复制数据自然会降低系统运行效率，因此在实际应用中，用户往往只选择对关键数据和日志文件进行镜像，而不是对整个数据库进行镜像。 SQL Server数据库镜像是将数据库镜像事务处理从一个SQL Server数据库移动到不同SQL Server环境中的另一个SQL Server数据库中。 数据库镜像的三种实现方式：1、高可用性 2、高保护 3、高性能 备份数据库：将数据库中的数据以及保证数据库系统正常运行的有关信息保存起来，以备系统出现问题时恢复数据库时使用 备份数据库的主要目的是为了防止数据丢失 造成数据丢失的原因：1、存储介质故障 2、用户的操作错误 3、服务器故障 4、由于病毒的侵害而造成的数据丢失或损坏 5、由于自然灾害而造成的数据丢失或损坏 备份数据库的作用：1、利用数据库的备份恢复数据库，从而将数据恢复到正确的状态 2、进行数据转移 恢复数据库：数据库系统在出现故障时利用先前建立的冗余数据（备份副本）把数据库恢复到某个正确、一致的状态的过程。 故障恢复类型：⑴介质故障恢复⑵非介质故障恢复 恢复模式：控制对事务日志的维护1、简单恢复模式：最大限度地减少事务日志的管理开销，备份间隔应尽可能短，以防止数据大量丢失。 2、完整恢复模式：完整地记录所有的事务，并将事务日志记录保留到对其备份完毕为止。 3、大容量日志恢复模式： &nbsp;&nbsp;①只对大容量操作进行最小记录，使事务日志不会被大容量加载操作所填充&nbsp;&nbsp;②保护大容量操作不受媒体故障的危害，提供最佳性能并占用最小日志空间 最好立刻进行备份的时刻：1、创建数据库后，或者在数据库中批量加载了数据之后 2、创建索引后 3、执行了清理事务日志的操作之后 4、执行了大容量数据操作后 备份方式：⑴永久备份设备：先建立备份设备，然后再将数据库备份到备份设备⑵临时备份设备：直接将数据库备份到物理文件上 备份类型：1、数据库备份：&nbsp;&nbsp;⑴完整数据库备份：将备份特定数据库中的所有数据，以及可以恢复这些数据的足够的日志&nbsp;&nbsp;⑵差异数据库备份：备份从最近的完整的备份之后数据库的全部变化内容。比完整数据库备份占用的空间小，且执行速度快，但会增加备份的复杂程度&nbsp;&nbsp;&nbsp;&nbsp;遵循原则：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①在每次完整数据库备份后，定期安排差异数据库备份 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②在确保差异备份不会太大的情况下，定期安排新的完整数据库备份 2、文件备份： &nbsp;&nbsp;⑴文件备份：一个或多个文件或文件组中所有数据的完整备份&nbsp;&nbsp;⑵差异文件备份 3、事务日志备份：仅用于完整恢复模式和大容量日志恢复模式 &nbsp;&nbsp;⑴纯日志备份&nbsp;&nbsp;⑵大容量操作日志备份&nbsp;&nbsp;⑶结尾日志备份 常用备份类型：1、完整数据库备份 2、完整数据库备份加日志备份 3、完整数据库备份加差异数据库备份再加日志备份 SQL Server支持以下级别恢复：1、数据库：还原和恢复整个数据库 2、数据文件：还原和恢复一个数据文件或一组文件 恢复数据库的顺序：1、还原最新完整数据库备份而不恢复数据库 2、如果存在差异备份，则还原最新的差异备份而不恢复数据库 3、从最后一次还原备份后创建的第一个事务日志备份开始，使用NORECOVERY选项一次还原日志 4、恢复数据库 Oracle数据库故障类型：1、SQL语句错误 2、进程失效 3、实例失效 4、网络失效 5、用户错误 6、介质失效 EXP导出工具模式：&nbsp;&nbsp;①用户模式&nbsp;&nbsp;②表模式&nbsp;&nbsp;③整个数据库 物理备份：对数据库物理文件所实施的备份1、用户管理的备份 2、Recover Manage（简称RMAN）备份： 3、第三方备份软件 RMAN组件：1、Target Database目标数据库 2、Server Session服务器会话 3、服务器进程4、Channel通道5、recovery catalog恢复目录6、MML媒体管理库 RMAN工具使用：1、开始或退出RMAN 2、配置RMAN持久设置环境 3、备份数据库 &nbsp;&nbsp;①备份数据库文件&nbsp;&nbsp;②备份个别数据库文件 4、增量备份 5、备份的校验 恢复数据库：1、恢复整个数据库 2、恢复当前表空间 3、恢复当前文件 4、恢复个别数据块 5、RMAN操作报告 分布式数据库系统是物理上分散、逻辑上集中的数据库系统 分布式数据库的目标：&nbsp;&nbsp;①本地自治 &nbsp;&nbsp;②非集中式管理 &nbsp;&nbsp;③高可用性 &nbsp;&nbsp;④位置独立性 &nbsp;&nbsp;⑤数据分片独立性 &nbsp;&nbsp;⑥数据复制独立性 &nbsp;&nbsp;⑦分布式查询处理 &nbsp;&nbsp;⑧分布式事务管理 &nbsp;&nbsp;⑨硬件独立性 &nbsp;&nbsp;⑩操作系统独立性 &nbsp;&nbsp;⑾网络独立性 &nbsp;&nbsp;⑿数据库管理系统独立性 ==数据分布策略：先数据分片，再数据分配== 数据分片：将关系划分为多个片段1、水平分片 2、垂直分片 3、导出分片 4、混合分片 数据分配：1、集中式 2、分割式 3、全复制式 4、混合式 分布式数据库系统的体系结构：1、分布式数据库的参考模式结构： &nbsp;&nbsp;⑴全局外模式：全局应用的用户视图 &nbsp;&nbsp;⑵全局概念模式：描述全体数据的逻辑结构和特征 &nbsp;&nbsp;⑶分片模式 &nbsp;&nbsp;⑷分配模式 &nbsp;&nbsp;⑸局部概念模式 &nbsp;&nbsp;⑹局部内模式 2、分布透明性 &nbsp;&nbsp;⑴分片透明性 &nbsp;&nbsp;⑵位置透明性 &nbsp;&nbsp;⑶局部数据模型透明性 3、分布式数据库管理系统 &nbsp;&nbsp;⑴全局数据库管理系统GDBMS：核心 &nbsp;&nbsp;⑵全局数据字典GDD：提供系统的各种描述、管理和控制信息 &nbsp;&nbsp;⑶局部数据库管理系统LDBMS：负责创建和管理局部数据库 &nbsp;&nbsp;⑷通信管理CM：在各个场地之间传送数据和消息 查询代价：&nbsp;&nbsp;⑴CPU代价 &nbsp;&nbsp;⑵I/O代价 分布式查询优化策略：&nbsp;&nbsp;⑴操作执行的顺序 &nbsp;&nbsp;⑵操作的执行算法 &nbsp;&nbsp;⑶不同场地间数据流动的顺序 导致数据传输量大的主要原因：数据间的连接操作和并操作 针对连接的优化策略：&nbsp;&nbsp;⑴基于半连接的优化策略 &nbsp;&nbsp;⑵基于连接的优化策略 分布式事务管理：&nbsp;&nbsp;⑴恢复控制 &nbsp;&nbsp;⑵并发控制 并行数据库体系结构：1、共享内存结构：所有的处理机通过互联网共享一个公共的主存储器 2、共享磁盘结构：所有的处理机拥有独立的主存储器，通过互联网共享磁盘 3、无共享结构：每个处理机拥有独立的主存储器，不共享任何资源 &nbsp;&nbsp;①支持并行数据库系统的最好并行结构&nbsp;&nbsp;②通信的代价和非本地磁盘访问的代价高 4、层次结构：顶层有若干节点组成的无共享结构，底层是共享内存或共享磁盘结构 一维数据划分：根据关系的某一个属性的值来划分整个关系&nbsp;&nbsp;①轮转法 &nbsp;&nbsp;②散列划分 &nbsp;&nbsp;③范围划分 并行算法：1、并行排序：&nbsp;&nbsp;⑴重新按排序属性进行范围划分，然后分别对每一个划分进行排序，最后将结果直接合并&nbsp;&nbsp;⑵采用并行外排序归并算法 2、并行连接 &nbsp;&nbsp;⑴划分连接 &nbsp;&nbsp;⑵分片-复制连接 3、其他的关系操作 &nbsp;&nbsp;⑴选择&nbsp;&nbsp;⑵消除重复&nbsp;&nbsp;⑶投影&nbsp;&nbsp;⑷聚集 云计算：&nbsp;&nbsp;①无需再为计算力准备计划或预算 &nbsp;&nbsp;②可以根据需要逐步追加硬件资源 &nbsp;&nbsp;③为用户提供短期使用资源的灵活性 云数据库的缺点：&nbsp;&nbsp;①不能确保数据的完整性&nbsp;&nbsp;②云对硬件进行虚拟化，不能直接对硬件进行管理&nbsp;&nbsp;③对因特网的依赖 XML可扩展标识语言：允许用户对自己的标记语言进行定义的源语言 XML数据库：支持对XML格式文档进行存储和查询等操作的数据库管理系统 XML数据库类型：⑴XML Enabled Database(XEDB)⑵Native XML Database(NXD)⑶Hybrid XML Database(HXD) XML数据库优势：⑴XML数据库能够对半结构化数据进行有效的存取和管理 ⑵提供对标签和路径的操作⑶便于对层次化的数据进行操作，能够存储和查询异种的文档结构 操作型数据：由企业的基本业务系统所产生的数据 决策支持系统DSS：用于协助管理人员在解决半结构化和非结构化问题的过程中做出决策，是为了增加决策的有效性 基于数据仓库的决策支持系统：以数据仓库为核心，它企业决策支持所需的数据集成在一起，构成一个集成的、一致而稳定的数据源。其中，数据仓库是核心，操作型系统是基本数据源，决策支持系统是数据的需求者 数据仓库：一个面向主题的、集成的、非易失的，且随时间变化的数据集合，用来支持管理人员的决策 数据仓库中的数据是以面向主题的方式进行组织的 面向业务应用的数据组织方法：对企业的某项应用的需求进行详细的调查、收集、建立数据库的基础数据，按照业务的要求，进行数据的组织和数据处理过程的组织。必须反映一个企业内的数据的动态特征，要便于表达企业各部门内的数据流动情况，即反映部门的数据处理流程，以实现联机事务处理。缺点：将数据和应用逻辑紧密地捆绑在一起，使得描述同一对象的数据可能以不同的表示方式存在于多个不同的业务应用系统中，缺乏一致性 数据仓库的特征：&nbsp;&nbsp;⑴面向主题性&nbsp;&nbsp;⑵集成性&nbsp;&nbsp;⑶不可更新性&nbsp;&nbsp;⑷时间特性（随时间变化） 数据仓库的数据体系结构：1、操作型数据 2、操作型数据存储 3、数据仓库 4、数据集市 5、个体层数据 数据仓库的数据组织：1、数据组织结构： &nbsp;&nbsp;①早期细节级&nbsp;&nbsp;②当前细节级&nbsp;&nbsp;③轻度综合级&nbsp;&nbsp;④高度综合级 2、粒度：粒度越大，表示综合程度越高 3、数据分区：恰当的数据分区能有效提高数据仓库各种数据处理功能的效率，按照时间标准来划分。 &nbsp;&nbsp;⑴系统层分区是数据库系统提供的机制，各个分区在逻辑上是一个表，在物理上属于不同分区&nbsp;&nbsp;⑵应用层分区由应用代码实现 多粒度级设计：针对某一主题，在可用的存储空间中保存粗细程度不同的主题数据，以尽可能满足各种应用的多角度、多层次数据查询要求，同时在总体上提高查询的计算效率。 元数据：关于数据的数据、描述数据的数据 技术元数据：描述关于数据仓库技术细节的数据，应用于开发、管理和维护数据仓库 业务元数据：从业务角度描述了数据仓库中的数据 企业级OLTP：在实际数据处理中，一个事务同时涉及多个部门的数据 数据仓库设计：1、数据体系的设计 2、应用体系的设计 应用体系的需求最终将反映为对数据的需求，构成数据体系的建设需求 数据仓库的数据模型：1、一般不包含纯操作型数据 2、一般需要扩充关键字结构，在其中加入时间属性 3、常常需要增加导出数据 概念模型：用于描述客观世界中的对象及其属性的一种概念性工具。现实世界的对象通过概念模型的抽象，进入到信息世界中，信息世界中的对象再通过转化进入到机器世界。 ER图：用于描述实体以及实体之间的联系 逻辑模型：关系型模型、多维数据模型 物理模型：逻辑模型在具体的数据存储平台上的物理定义1、物理存取方式 2、数据存储结构 3、数据存放位置 4、存储分配 优化物理模型的设计技术：1、引入冗余措施 2、分区 3、生成导出数据 4、表合并 5、细分数据和索引 用户最基本需求：将企业的各个主题数据集成起来，构成一个有效的信息处理和决策支持数据源，并在这基础上开发各种应用，包括基本信息处理应用、OLAP、企业常用的、例行性的中高级信息处理工作以及一些分析型、挖掘性的应用 数据集成：将源自不同数据源的数据经过抽取、转换、清理、装载等操作载入数据仓库的过程，是实施数据仓库的重要步骤 ETL（Extract Transform Load）：填充更新数据仓库的数据抽取、转换、装载的数据采集过程 数据清理Data Cleaning：减少错误和不一致性的过程，过滤掉那些不符合要求的数据（不完整的、错误的、重复的） 数据仓库的设计过程：1、概念模型设计 2、技术评估与环境准备工作 3、逻辑模型设计 4、物理模型设计 5、数据生成与应用实现 6、数据仓库运行与维护 数据仓库日常管理工作：1、操作型数据环境中新生成的数据的集成、 2、载入、刷新数据仓库中的细节数据和导出数据（物化视图） 3、将过时的数据转移到磁带等存储设备上 4、清除不再使用的数据 5、对元数据进行管理 数据仓库主题数据的刷新：1、对细节数据的刷新 2、对导出数据的刷新 数据仓库维护的基本思路：&nbsp;&nbsp;&nbsp;&nbsp;根据某种维护策略，在一定条件下触发维护操作；维护操作捕捉到数据源中的数据变化；通过一定策略对数据仓库中的数据进行相应的更新操作，以保持两者的一致性 维护策略：1、实时维护：在数据源发生变化时，立即更新数据仓库中数据 2、延时维护：在数据仓库中的视图被查询时完成更新 3、快照维护：定期对数据仓库进行维护 捕捉数据源的变化：1、触发器：当数据源发生更新操作时，触发器被触发，对更改的数据进行处理 2、修改数据源应用程序：向数据仓库端发送源数据变化的通告以及变化的内容 3、通过日志文件：对数据库的所有更新操作都会记录到日志文件中去 4、快照比较法：比较数据源当前时刻和前一时刻的快照 对数据仓库中导出数据的维护方法：1、根据维护对象的数据源对其进行重新计算 2、根据数据源的变化量在维护对象原有数据的基础上进行数据添加和修改 （增量式维护） “聚集”操作：预先生成一部分更新用的聚集数据，存放在附加表中，不涉及对数据修改“更新”操作：具体执行维护对象的更新 数据仓库的性能调节：&nbsp;&nbsp;&nbsp;&nbsp;通过将网络流通，磁盘存取和CPU占用时间最短化，使每个查询的响应时间最短化，提高数据库吞吐量，从而最大限度地优化查询 物化视图查询：&nbsp;&nbsp;&nbsp;&nbsp;将给定查询转变为基于物化视图的查询，然后使用若干个物化视图确定所有可能的查询计划，在估算每个执行计划的开销后，选择最小代价的计划执行查询，从而优化查询性能。 配合数据库的事件探查器，定期对索引进行分析和修改，完成对索引的再优化，达到整体数据仓库不随数据的更新维护而长期保持性能上的优化 数据仓库的存储容量有限 元数据管理机制：合理的管理数据仓库中的数据 元数据库：存储和管理元数据 对元数据进行科学有效的管理和元数据库标准化 元数据作用：1、记录企业详细信息 2、保存数据存储位置 3、生成维护数据之间的关系 4、数据的转换过程 数据的多维分析：针对数据仓库中以多维形式组织起来的数据，从多个角度、不同层次，采用各种数据分析技术，对数据进行剖析，以使用户能从不同角度和不同层次观察和分析数据。 多维视图：描述多维分析系统中用户所看到的数据 多维分析的基本操作：1、钻取与卷起：对应于某一维逐步向更细节层方向观察数据（钻取），卷起反之 2、切片和切块：实现局部数据的显示 3、旋转：改变一个报告或页面显示的维方向 OLAP的实现方式：1、基于多维数据库的OLAP 2、基于关系数据库的OLAP 3、混合型的OLAP 数据挖掘应用领域：1、客户细分 2、客户流失预测 3、客户价值分析 4、异常发现 5、个性化服务 6、预警 7、科学探索 数据挖掘步骤：1、数据准备： &nbsp;&nbsp;①数据选取 &nbsp;&nbsp;②数据预处理 &nbsp;&nbsp;③数据变换 2、数据挖掘： &nbsp;&nbsp;①确定挖掘的任务或目的&nbsp;&nbsp;②决定使用的挖掘算法&nbsp;&nbsp;&nbsp;&nbsp;I. 数据特点&nbsp;&nbsp;&nbsp;&nbsp;II. 用户或实际运行系统的要求 3、结果的解释评估 分类预测任务：从已经分类的数据中学习模型，并使用学习出来的模型去解决新的未分类的数据 描述型任务：根据数据内部具有的固有联系，生成对数据集中的数据关系或整个数据集的概要描述。 关联规则：&nbsp;&nbsp;①支持度s&nbsp;&nbsp;②置信度c 最小支持度：表示一组物品集在统计意义上需要满足的最低程度 最小可信度：反映了关联规则的最低可靠程度 强关联规则：满足最小可信度阙值和最小支持度阙值的关联规则 分类挖掘的过程：1、通过已知数据集（训练集），建立分类函数，构造分类器 2、利用所获得的分类函数对未知类别标记的数据项进行分类操作 聚类：将一个数据集中的数据进行分组，使得每一组内的数据尽可能相似而不同组间的数据尽可能的不同。 时间序列：用时间排序的一组随机变量 时间序列分析（数据演变分析）：描述行为随时间变化的对象的规律或趋势，并对其进行建模。 时间序列：1、⑴一元时间序列 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵多元时间序列 2、⑴平稳时间序列 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵非平稳时间序列]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库原理（考试版）]]></title>
    <url>%2F2017%2F06%2F23%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1234567单选20 判断20（10） 证明（问题建模，借助公式） 计算15（关系代数，几张表，运算结果） 编程15（SQL语句） 设计（画出ER图，写出关系模式，联系，一对一多对多，判断满足第几范式，不满足就分解） 理解！！！ 第一章 P4：数据（概念） 数据库存储的基本对象 ，描述事物的符号记录 P5：数据库管理系统DBMS 计算机的基础软件 数据定义功能 数据组织、存储和功能：提高存储空间利用率和方便存取 数据操纵功能：实现对数据库的基本操作，查询插入删除修改 数据库的事务管理和运行管理 数据库的建立和维护功能 与网络中其他软件系统的通信功能 P6：数据库管理技术三个阶段（每个阶段的特点） 人工管理阶段：数据不保存、应用程序管理数据、数据不共享、数据不具有独立性 文件系统阶段：数据可以长期保存、由文件系统管理数据、数据共享性差，冗余度打、数据独立性差 数据库系统阶段：数据结构化、数据的共享性高，冗余度低且易扩充、数据独立性高、数据由数据库管理系统统一管理和控制 P13：数据库的独立性（逻辑物理独立性） 物理独立性：指用户的应用程序与数据库中数据的物理存储是相互独立的 逻辑独立性：指用户的应用程序与数据库的逻辑结构是相互独立的 P18：数据库的构成要素：完整性约束条件、数据模型 完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定复合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容 数据模型：层次模型、网状模型、关系模型 P29：模式、外模式、内模式（必须内模式理解） 模式（逻辑模式）：数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图，定义数据的逻辑结构，定义数据之间的联系，定义与数据有关的安全性、完整性要求 外模式（子模式、用户模式）：数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有短的数据的逻辑表示 内模式（存储模式）：数据物理结构和存储方式的描述，是数据在数据库内部的组织方式 外模式/模式映像：当模式改变时，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。（对于每一个外模式，数据库系统都有一个外模式/模式映像） 模式/内模式映像：当数据库的存储结构改变时，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性，简称数据的物理独立性（模式/内模式映像是唯一的） 首先确定数据库的逻辑模式&nbsp;&nbsp;&nbsp;&nbsp;数据库的内模式依赖于它的全局逻辑结构，但独立于数据库的用户视图，也独立于具体的存储设备&nbsp;&nbsp;&nbsp;&nbsp;数据库的外模式面向具体的应用程序，它定义在逻辑模式之上，但独立于存储模式和存储设备 第二章 P38：域、笛卡尔积、元组、基数 域：一组具有相同数据类型的值的集合 笛卡儿积：在A去一个元素，在B去一个元素，组成n个取值的一个集合 每一个元素叫做一个元组一个域允许的不同取值个数称为这个域的基数 P40：目、候选码、主码、主属性、非主属性 n目关系必有n个属性 若关系中的某一属性组的值能唯一的表示一个元组，而其子集不能，则称该属性组为候选码 若一个关系中有多个候选码，则选定其中一个为主码 候选码的诸属性称为主属性 不包含在任何候选码中的属性成为非主属性或非码属性 关系模式的所有属性是这个关系模式的候选码，称为全码 选择、投影、并、差、笛卡儿积 P45：关系的完整性：实体完整性（主属性不能为空）、参照完整性（外码不能取空）、用户定义完整性（用户对） 实体完整性规则：若属性A是基本关系R的主属性，则A不能取空值 外码：自身不是主码，取值参照另一张表中主码的取值 参照完整性规则：若属性F是基本关系R的外码，与基本关系S的主码Ks相对应，则对于R中每个元组在F上的值必须：空值或等于S中某个元组的主码值 P49：关系代数 传统的集合运算：并、差、交、笛卡儿积 专门的关系运算：选择、投影、连接（自然连接去掉重复的属性列）、除（象集） P56：例题，完成关系运算 第三章（写语句） P90：select、distinct、between、in、like 12345select sno,sname from studentselect distinct sno from scselect sname drom student where sage between 20 and 23select sname from student where sdept in (‘CS’,’MA’,’IS’);select sname from student where sname like ‘刘_’（%代表任意长度，_代表任意单个字符） P97：聚集函数只能select子句和group by的having子句 count(*),count(),sum(),avg(),max(),min() P98：group by（分组查询） 1select sno from sc group by sno having count(*)&gt;3 P99：having、where、连接查询 1where sc.sno=student.sno P103：嵌套 123select snamefrom studentwhere sno in (select sno from sc where cno=’2’) P115：数据更新 update、delete 12345insert into student values (‘201215126’,’张成民’,’男’,’18’,’CS’)update student set sage=22 where sno=’201215121’delete from student where sno=’201215128’ P121：视图（理解） 定义视图：123create view is_student asselect sno,sname,sage from student where sdept=’IS’ with check option 删除视图:1drop view is_s1 cascade P126：更新视图，什么情况更新，什么情况不更新 对视图的更新最终要转换为对基本表的更新 行列子集视图是可更新的 不允许更新： 视图是由两个以上基本表导出的 视图字段来自字段表达式或常数，不允许insert和update，但是允许delete 视图字段来自聚集函数 视图定义含有group by子句 视图定义含有distinct短语 视图定义有嵌套查询，并且内层查询的from子句中涉及的表也是导出该视图的基本表 一个不允许更新的视图上定义的视图也不允许更新 第四章 P140：自主存取控制，强制存取控制（grant、revoke） 自主存取控制方法：用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户 强制存取控制方法：每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取 P145：角色 123grant insert on table sc to U5 with grant option （获得某种权限的用户还可以把这种权限再授予其他的用户）revoke insert on table sc from U5 cascade 基于角色的授权机制：123create role r1;grant select on table student to r1;grant r1 to A;revoke r1 from B; P148：强制存取控制规则、不下读不上写 强制存取控制适用于那些对数据有严格而固定密级分类的部门 主体：系统中的活动实体 客体：系统中的被动实体 敏感度标记：绝密TS&gt;=机密S&gt;=可信C&gt;=公开P（主体：许可证级别，客体：密级） 规则： 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体 仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体 P149：审计、视图、数据加密等等（了解） 通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保护 审计功能把用户对数据库的所有操作自动记录下来放入审计日志中。审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等 存储加密传输加密&nbsp;&nbsp;&nbsp;加密的基本思想：根据一定的算法将原始数据—明文变换为不可识别的格式—密文，从而使得不知道解密算法的人无法获知数据的内容 第六章第一范式：不存在可分割数据项第二范式：不存在部分函数依赖（非主属性对码）第三范式：不存在传递函数依赖（非主属性对码不存在传递函数依赖）BCNF：决定因素都是码 （给予关系模式、函数依赖关系，判断满足哪个范式） 规范化的基本思想是逐步消除数据依赖中不合适的部分，“一事一地”的模式设计原则模式的分解：分解具有无损连接性，分解要保持函数依赖 6.3节数据依赖 数据依赖是一个关系内部属性与属性之间的一种约束关系，通过属性间值的相等与否体现出来的数据间相关联系 函数依赖存在的问题： 数据冗余 更新异常 插入异常 删除异常 不属于2NF：插入异常、删除异常、修改复杂 P203习题第七大题判断题 第七章 P221：画ER图，一对一联系、多对多联系（标注）、联系属性、实体属性 数据库建设的基本规律：“三分技术，七分管理，十二分基础数据” 数据库设计的基本步骤：需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行与维护 数据字典是进行详细的数据收集和数据分析所获得的主要成果。是关于数据库中数据的描述，即元数据而不是数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改充实完善的，包括数据项、数据结构、数据流、数据存储和处理过程 P232：逻辑结构设计，一对一、一对多怎么转换为关系模式，横线，表组合表属性，再进行规范化判别、优化 一个一对一联系可以转换为一个独立的关系模式，也可以与任一一端对应的关系模式合并 一个一对多联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并 一个多对多联系可以转换为一个关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为n端实体的码 并不是规范化程度越高的关系就越优 物理结构设计-&gt;存取方法： B+树索引存取方法 hash索引存取方法 聚簇存取方法 把属性上具有相同值的元祖集中存放在连续的物理块中称为聚簇，该属性称为聚簇码 第九章查询处理步骤：查询分析、查询检查、查询优化（代数优化、物理优化）、查询执行 P277：选择操作：全表扫描、索引扫描P278：连接操作：嵌套循环、排序合并、索引连接、哈希连接（外表内表几遍）P281：查询优化实例（总代价=I/O代价+CPU代价+内存代价+通信代价）P284：查询树的启发式优化：选择、投影（要知道）【代数优化】 启发式规则：选择运算应尽可能先做、把投影运算和选择运算同时进行、把投影同其前或后的双目运算结合起来、把某些选择同在它前面要执行的笛卡儿积结合起来成为一个连接运算、找出公共子表达式 物理优化 P286：选择操作的启发式规则（索引扫描、全表扫描）P287：连接操作的启发式规则 （排序、索引、哈希、嵌套），作外表 如果2个表都已经按照连接属性排序，则选用排序—合并算法 如果一个表在连接属性上有索引，则可以选用索引连接算法 如果上面2个规则都不适用，其中一个表较小，则可以选用hash join算法 最后可以选用嵌套循环算法，并选择其中较小的表，即占用的块数B较少的表，作为外表 P288：代价估算cost=B，什么情况cost=B/2、代价计算cost=L+S，怎么来的为什么 设连接表R与S分别占用的块数为Br与Bs，连接操作使用的内存缓冲区块数为K，分配K-1块给外表。如果R为外表，则嵌套循环法存取的块数为Br+BrBs/（K-1） 第十章事务的基本概念、四个特性（原子性、一致性、隔离性、持续性） 事务：用户定义的一个数据库操作序列，一个不可分割的工作单位 原子性：事务是数据库的逻辑工作单位 一致性：事务执行的结果必须是使数据库从一个一致性状态从另一个一致性状态 隔离性：一个事物的内部操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰 持续性（永久性）：一个事务一旦提交，对数据库中的数据的改变是永久性的，接下来的其他操作或故障不应该对其执行结果有任何影响 事务内部故障、系统故障、介质故障、计算机病毒 事务撤销：在不影响其他事物运行的情况下，强行回滚该事务，即撤销该事务已经作出的任何对数据库的修改，使得该事务好像根本没有启动一样 系统故障：系统重启后，所有非正常终止的事务回滚，强行撤销所有未完成事务，还需要重做所有已提交的事务，以将数据库真正恢复到一致状态 介质故障：硬故障 计算机病毒：人为的故障或破坏 redo、undo，了解什么时候做什么，将课上的图完全弄明白，写还是没写、提交还是没提交 P297：数据转储：海量转储、增量转储、动态转储、静态转储、特性，恢复过程中要用到哪些文件 恢复的基本原理：冗余 建立冗余数据：数据转储和登记日志文件 转储：数据库管理员定期的将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程。称为后备副本 重装后备副本只能将数据库恢复到转储时的状态，还需重新运行自转储以后的所有更新事务 静态转储：在系统中无运行事务时进行的转储操作动态转储：指转储期间允许对数据库进行存取或修改，即转储和用户事务可以并发执行 海量转储：每次转储全部数据库 增量转储：每次只转储上一次转储后更新过的数据 日志文件：用来记录事务对数据库的更新操作的文件日志文件的作用：进行事务故障恢复和系统故障恢复，并协助后备副本进行介质故障恢复 登记日志文件遵循两条原则：登记的次序严格按并发事务执行的时间次序、必须先写日志文件，后写数据库 事务故障的恢复：undo 系统故障的恢复：undo，redo 介质故障的恢复：重装数据库，然后重做已完成的事务 恢复策略（很多判断）、检查点恢复技术（了解）、数据库镜像基础（了解） 动态维护日志文件的方法 周期性地执行建立检查点 保存数据库状态的操作 数据库镜像：根据数据库管理员的要求，自动把整个数据库或其中的关键数据复制到另一个磁盘上，每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去，由数据库管理系统自动保证镜像数据与主数据库的一致性]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统]]></title>
    <url>%2F2017%2F06%2F14%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[操作系统是配置在计算机硬件的第一层软件，是对硬件系统的首次扩充。其主要作用是管理设备，提高设备的利用率和系统的吞吐量 操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合 操作系统的目标：1、方便性：编译将高级语言翻译成机器代码2、有效性：提高系统资源的利用率和提高系统的吞吐量3、可扩充性：适应计算机硬件、体系结构以及计算机应用发展的要求4、开放性：彼此兼容，实现互连 操作系统的作用：1、OS作为用户与计算机硬件系统之间的接口方式：⑴命令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵系统调用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶图标-窗口2、OS作为计算机系统资源的管理者资源类型：⑴处理机&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵存储器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶I/O设备&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑷文件（数据、程序）3、OS实现了对计算机资源的抽象 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;含义：利用数据结构及操作命令来进行数据输入或输出，无需关心具体实现 推动操作系统发展的主要动力：1、不断提高计算机资源利用率（昂贵，但利用率不高）2、方便用户（上机调试程序不方便）3、器件的不断更新换代4、计算机体系结构的不断发展5、不断提出新的应用需求 操作系统的发展过程1、 未配置操作系统的计算机系统&nbsp;&nbsp;&nbsp;1) 人工操作方式缺点：①用户独占全机&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②CPU等待人工操作&nbsp;&nbsp;&nbsp;2) 脱机输入/输出方式Off-Line I/O含义：在脱离主机的情况下进行的反义：联机输入输出（在主机的直接控制下进行输入/输出的方式）优点：①减少了CPU的空闲时间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②提高了I/O速度2、 单道批处理系统含义：把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序，在它的控制下，使这批作业能一个接一个地连续处理局限性：虽然系统对作业的处理是成批进行的，但在内存中始终只保持一道作业缺点: 系统中的资源得不到充分的利用3、 多道批处理系统含义：作业存放在外存，并排成一个队列（后备队列），共享CPU和系统资源 优缺点：⑴资源利用率高&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ⑵系统吞吐量大：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① CPU和其他资源保持“忙碌”状态&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②系统开销小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ⑶平均周转时间长 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ⑷无交互能力 需解决的问题：⑴处理机争用问题 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵内存分配和保护问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶I/O设备分配问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ⑷文件的组织和管理问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑸作业管理问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑹用户与系统的接口问题4、分时系统 用户的需求：⑴人-机交互（方便进行修改）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵共享主机（昂贵，共享资源） 问题解决方法：⑴及时接收：多路卡（实现分时多路复用） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵及时处理：①作业直接进入主存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②采用轮转运行方式（每个作业每次只能运行一个时间片） 特征：⑴多路性（运行多个用户共享一台计算机） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵独立性（彼此之间互不干扰） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶及时性（用户请求在短时间得到响应） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑷交互性（人机对话）5、实时系统：实时系统的定义：系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行实时系统的类型：⑴工业（武器）控制系统 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵信息查询系统 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶多媒体系统 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑷嵌入式系统实时任务的类型：⑴周期性实时任务（按周期循环执行） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵非周期性实时任务最后期限：①开始截止时间（某任务在某时间以前必须开始执行）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②完成截止时间（某任务在某时间以前必须完成）⑶硬实时任务（系统必须满足任务对截止时间的要求）⑷软实时任务 实时系统特征：⑴多路性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵独立性（彼此之间互不干扰） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑶及时性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑷交互性（立即响应） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑸可靠性（要求系统高度可靠）6、微机操作系统的发展：⑴单用户单任务操作系统含义：只允许一个用户上机，且只允许用户程序作为一个任务运行代表性操作系统：①CP/M（8位）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②MS-DOS（16位）⑵单用户多任务操作系统：含义：只允许一个用户上机，但允许用户把程序分为若干个任务，使它们并发执行代表性操作系统：Windows⑶多用户多任务操作系统：UNIX OS 操作系统的基本特性：1、 并发&nbsp;&nbsp;⑴ 并行性：两个或多个事件在同一时刻发生&nbsp;&nbsp;⑵ 并发性：两个或多个事件在同一时间间隔内发生&nbsp;&nbsp;⑶ 进程：在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体2、 共享（复用，指系统中的资源可供内存中多个并发执行的进程共同使用）&nbsp;&nbsp;⑴ 互斥共享方式：在一段时间内，只允许一个进程访问该资源&nbsp;&nbsp;⑵ 同时访问方式：允许在一段时间内由多个进程“同时”对资源进行访问3、 虚拟（将一条物理信道变为若干条逻辑信道）&nbsp;&nbsp;⑴ 时分复用技术（利用处理机的空闲时间）&nbsp;&nbsp;&nbsp;&nbsp;① 虚拟处理机技术&nbsp;&nbsp;&nbsp;&nbsp;② 虚拟设备技术&nbsp;&nbsp;⑵ 空分复用技术（利用存储器的空闲空间）&nbsp;&nbsp;&nbsp;&nbsp;① 空分复用存储器：提高内存的利用率&nbsp;&nbsp;&nbsp;&nbsp;② 虚拟存储技术：实现内存的分时复用4、 异步（停停走走，进程是以人们不可预知的速度向前推进的） ==临界资源（独占资源）：在一段时间内只允许一个进程访问的资源== 操作系统的主要功能：1、 处理机管理功能&nbsp;&nbsp;⑴ 进程控制：创建和撤销进程，以及进程的状态转换&nbsp;&nbsp;⑵ 进程同步：对诸进程的运行进行协调&nbsp;&nbsp;&nbsp;&nbsp;①进程互斥方式（临界资源）&nbsp;&nbsp;&nbsp;&nbsp;②进程同步方式（共同任务）&nbsp;&nbsp;⑶ 进程通信：实现进程之间的信息交换&nbsp;&nbsp;⑷ 调度：按照一定的算法把处理机分配给进程&nbsp;&nbsp;&nbsp;&nbsp;①作业调度&nbsp;&nbsp;&nbsp;&nbsp;②进程调度2、 存储器管理功能&nbsp;&nbsp;⑴ 内存分配&nbsp;&nbsp;&nbsp;&nbsp;1) 任务：①为每道程序分配内存空间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②提高存储器的利用率&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③允许正在运行的程序申请附加的内存空间&nbsp;&nbsp;&nbsp;&nbsp;2) 方式：①静态分配方式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②动态分配方式&nbsp;&nbsp;⑵ 内存保护（设置内存保护机制）&nbsp;&nbsp;任务：①确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行&nbsp;&nbsp;⑶ 地址映射&nbsp;&nbsp;⑷ 内存扩充&nbsp;&nbsp;&nbsp;&nbsp;实现功能：①请求调入功能 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②置换功能3、设备管理功能&nbsp;&nbsp;⑴缓冲管理（缓和CPU和I/O设备速度不匹配的矛盾） &nbsp;&nbsp;缓冲区机制：①单缓冲机制&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②能实现双向同时传送数据的双缓冲机制&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③能供多个设备同时使用的公用缓冲池机制&nbsp;&nbsp;⑵设备分配&nbsp;&nbsp;⑶设备处理4、文件管理功能&nbsp;&nbsp;⑴文件存储空间的管理：为每个文件分配必要的外存空间&nbsp;&nbsp;⑵目录管理：为每个文件建立一个目录项&nbsp;&nbsp;⑶文件的读/写管理和保护&nbsp;&nbsp;&nbsp;&nbsp;a) 文件的读/写管理：合用一个读/写指针&nbsp;&nbsp;&nbsp;&nbsp;b) 文件保护：①防止未经核准的用户存取文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②防止冒名顶替存取文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③防止以不正确的方式使用文件 操作系统与用户之间的接口：&nbsp;&nbsp;⑴用户接口&nbsp;&nbsp;&nbsp;&nbsp;①联机用户接口&nbsp;&nbsp;&nbsp;&nbsp;②脱机用户接口&nbsp;&nbsp;&nbsp;&nbsp;③图形用户接口&nbsp;&nbsp;⑵程序接口（系统调用子程序） 现代操作系统的新功能：&nbsp;&nbsp;⑴系统安全&nbsp;&nbsp;&nbsp;&nbsp;① 认证技术：确定对象的真实性&nbsp;&nbsp;&nbsp;&nbsp;② 密码技术：对系统所需存储和传输的数据进行加密&nbsp;&nbsp;&nbsp;&nbsp;③ 访问控制技术：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i. 对用户存取权限的设置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii. 对文件属性的设置&nbsp;&nbsp;&nbsp;&nbsp;④ 反病毒技术：反病毒软件⑵网络的功能和服务&nbsp;&nbsp;A. 网络通信：实现无差别错的数据传输&nbsp;&nbsp;B. 资源管理：保证数据的安全性和一致性&nbsp;&nbsp;C. 应用互操作：实现信息的互通性和信息的互用性⑶支持多媒体&nbsp;&nbsp;a) 接纳控制功能&nbsp;&nbsp;b) 实时调度&nbsp;&nbsp;c) 多媒体文件的存储 OS结构：1、传统操作系统结构&nbsp;&nbsp;⑴无结构操作系统：每个过程可以任意地相互调用其他过程&nbsp;&nbsp;⑵模块化结构OS：“分解”、“模块化”、模块-接口法&nbsp;&nbsp;⑶分层化结构OS：有序分层法2、微内核OS结构（现代OS）： ⑴描述：①足够小的内核：实现现代OS最基本核心功能&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②基于客户/服务器模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③应用“机制与策略分离”原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④采用面向对象技术 ⑵功能：①进程（线程）管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②低级存储器管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③中断和陷入处理 ⑶优点：①提高了系统的可扩展性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②增强了系统的可靠性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③可移植性强&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④提供了对分布式系统的支持&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤融入了面向对象技术 前趋图：描述进程之间执行的先后顺序，有向无循环图DAG，结点表示进程或程序段，有向边表示存在的偏序或前趋关系 如果进程Pi和Pj存在着前趋关系，表示Pj开始执行之前Pi必须完成 初始结点：没有前趋的结点终止结点：没有后继的结点每个结点具有一个重量，用于表示该结点所含有的程序量或程序的执行时间 前趋图不允许有循环 程序顺序执行时的特征&nbsp;&nbsp;⑴顺序性：每一操作必须在下一个操作开始之前结束&nbsp;&nbsp;⑵封闭性：程序运行时独占全机资源&nbsp;&nbsp;⑶可再现性：程序重复执行，获得相同结果 程序并发执行时的特征：⑴间断性：并发执行的程序之间形成了相互制约，相互制约将导致并发程序具有“执行—暂停—执行”这种间断性的活动规律⑵失去封闭性：资源共享。当任一程序运行，其环境必然受到其他程序的影响⑶不可再现性：失去可再现性，得到的结果却各不相同 ==进程：为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制==进程控制块PCB：为使参与并发执行的每个程序（含数据）都能独立地运行，操作系统配置的专门的数据结构。描述进程的基本情况和活动过程，进而控制和管理进程进程（进程实体、进程映像）：程序段、相关的数据段和PCB创建（撤销）进程：创建（撤销）进程实体中的PCB 进程⑴定义：&nbsp;&nbsp;①进程是程序的一次执行&nbsp;&nbsp;②进程是一个程序及其数据在处理机上顺序执行时所发生的活动&nbsp;&nbsp;③进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位&nbsp;&nbsp;④进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位（传统OS定义）⑵特征：&nbsp;&nbsp;①动态性：由创建而产生，由调度而执行，由撤销而消亡 &nbsp;&nbsp;②并发性：多个进程实体同存于内存中，且能在一段时间内同时运行 &nbsp;&nbsp;③独立性：独立运行、独立获得资源、独立接受调度 &nbsp;&nbsp;④异步性：按各自独立的、不可预知的速度向前推进⑶基本状态：&nbsp;&nbsp;①就绪：进程已分配到除CPU以外的所有必要资源&nbsp;&nbsp;②执行：进程已获得CPU，其程序正在执行&nbsp;&nbsp;③阻塞：进程的执行受到阻塞⑷切换：&nbsp;&nbsp;①就绪-&gt;执行：调度程序分配了处理机&nbsp;&nbsp;②执行-&gt;就绪：时间片已完&nbsp;&nbsp;③执行-&gt;阻塞：I/O请求（发生某事件） 创建状态：进程所需的资源得不到满足，系统无足够的内存终止状态：进程到达自然结束点，出现无法克服的错误，被操作系统终结。进入终止态的进程以后不能再执行 创建进程的过程：首先向进程申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所需要的资源；最后，把该进程转入就绪状态并插入就绪状态并插入就绪队列之中终止进程的步骤：等待操作系统进行善后处理，最后将其PCB清零，并将PCB空间返还系统 ==挂起：此时该进程处于静止状态== 引入挂起操作的原因：&nbsp;&nbsp;&nbsp;&nbsp;①终端用户的需要：以便用户研究其执行情况或对程序进行修改&nbsp;&nbsp;&nbsp;&nbsp;②父进程请求：考查和修改该子进程，或协调各子进程之间的活动&nbsp;&nbsp;&nbsp;&nbsp;③负荷调节的需要：以保证系统能正常进行&nbsp;&nbsp;&nbsp;&nbsp;④操作系统的需要：检查运行中的资源使用情况或进行记账 活动就绪：此时进程可以接受调度静止就绪：进程不再被调度执行活动阻塞：进程处于未被挂起的阻塞状态静止阻塞-&gt;静止就绪：出现其所期待的事情后 挂起原语：Suspend激活原语：Active 记录和查询各种资源的使用及各类进程运行情况的信息 进程信息表（资源信息表）：包含了资源或进程的标识、描述、状态等信息以及一批指针数据结构：①内存表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②设备表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③文件表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④用于进程管理的进程表 PCB（记录型数据结构）的作用：&nbsp;&nbsp;①作为独立运行基本单位的标志：系统通过PCB感知进程的存在&nbsp;&nbsp;②能实现间断性运行方式：PCB可保存恢复CPU现场信息&nbsp;&nbsp;③提供进程管理所需要的信息：操作系统根据PCB实施对进程的控制和管理&nbsp;&nbsp;④提供进程调度所需要的信息：PCB提供了进程处于何种状态的信息&nbsp;&nbsp;⑤实现与其他进程的同步与通信：PCB具有用于实现进程通信的区域或通信队列指针 进程控制块中的信息：进程标识符（唯一地标识一个进程）：&nbsp;&nbsp;①外部标识符：父进程标识、子进程标识、用户标识&nbsp;&nbsp;②内部标识符：赋予每一个进程一个唯一的数字标识符处理机状态：&nbsp;&nbsp;①通用寄存器（用户可视寄存器）：暂存信息&nbsp;&nbsp;②指令计数器：存放要访问的下一条指令的地址&nbsp;&nbsp;③程序状态字PSW：状态信息（条件码、执行方式、中断屏蔽标志）&nbsp;&nbsp;④用户栈指针：存放过程和系统调用参数及调用地址进程调度信息：&nbsp;&nbsp;①进程状态：进程的当前状态&nbsp;&nbsp;②进程优先级：进程使用处理机的优先级别&nbsp;&nbsp;③进程调度所需的其他信息：与所采用的进程调度算法有关&nbsp;&nbsp;④事件：阻塞原因进程控制信息：&nbsp;&nbsp;①程序和数据的地址&nbsp;&nbsp;②进程同步和通信机制&nbsp;&nbsp;③资源清单：在运行期间所需的资源和已分配到该进程的资源的清单&nbsp;&nbsp;④链接指针：本进程PCB所在队列的下一个进程PCB的首地址 PCB的组成方式：&nbsp;&nbsp;①线性方式：系统的所有PCB组织的一张线性表&nbsp;&nbsp;②链接方式：把具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列&nbsp;&nbsp;③索引方式：系统根据所有进程状态的不同建立的索引表，每张索引表表目记录具有相应状态的某个PCB在PCB表中的地址 进程控制一般是由OS的内核中的原语来实现的 OS内核安排在紧靠硬件的软件层次的目的：&nbsp;&nbsp;⑴便于对其进行保护&nbsp;&nbsp;⑵提高OS的运行效率 处理机的执行状态：&nbsp;&nbsp;①系统态、管态、内核态：能执行一切指令，访问所有寄存器和存储区&nbsp;&nbsp;②用户态（目态）：仅能执行规定的指令，访问指定的寄存器和存储区 OS内核功能：&nbsp;&nbsp;⑴支撑功能：①中断处理（最基本）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②时钟管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③原语操作：原语在执行过程中不允许被中断&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑵资源管理功能：①进程管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②存储器管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③设备管理 应用程序只能在用户态运行，防止应用程序对OS的破坏原子操作在系统态下执行，常驻内存 父进程：创建进程的进程子进程：被创建的进程 进程图：用于描述进程间关系的一棵有向树，树的根结点是进程家族的祖先 导致一个进程创建另一个进程的事件：①用户登录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②作业调度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③提供服务&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④应用请求 创建新进程：①申请空白PCB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②为新进程分配其运行所需的资源&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③初始化进程控制块PCB：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i. 初始化标识信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii. 处理机状态信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii. 处理机控制信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④当能接纳，将新进程插入就绪队列 引起进程终止的事件：&nbsp;&nbsp;⑴正常结束：有一个用于表示进程已经运行完成的指示&nbsp;&nbsp;⑵异常结束：进程在运行时发生了某种异常事件，使程序无法继续运行&nbsp;&nbsp;&nbsp;&nbsp;①越界错：越出该进程的区域&nbsp;&nbsp;&nbsp;&nbsp;②保护错：进程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问&nbsp;&nbsp;&nbsp;&nbsp;③非法指令：程序试图去执行一条不存在的指令&nbsp;&nbsp;&nbsp;&nbsp;④特权指令错：指用户进程试图去执行一条只允许OS执行的指令&nbsp;&nbsp;&nbsp;&nbsp;⑤运行超时：指进程的执行时间超过了指定的最大值&nbsp;&nbsp;&nbsp;&nbsp;⑥等待超时：指进程等待某事件的时间超过了规定的最大值&nbsp;&nbsp;&nbsp;&nbsp;⑦算术运算错：进程试图去执行一个被禁止的运算&nbsp;&nbsp;&nbsp;&nbsp;⑧I/O故障：在I/O过程中发生错误⑶外界干预：进程应外界的请求而终止运行&nbsp;&nbsp;&nbsp;&nbsp;①操作员或操作系统干预&nbsp;&nbsp;&nbsp;&nbsp;②父进程请求结束子进程&nbsp;&nbsp;&nbsp;&nbsp;③在终止父进程时，终止所有子孙进程 进程的终止过程&nbsp;&nbsp;①根据标识符，从PCB集合中检索出被终止进程的PCB，从中读出该进程的状态&nbsp;&nbsp;②若处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度&nbsp;&nbsp;③终止所有子孙进程&nbsp;&nbsp;④将所终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统&nbsp;&nbsp;⑤将被终止进程PCB从所在队列（或链表）中移出，等待其他程序来搜集信息 引起进程阻塞和唤醒的事件&nbsp;&nbsp;①向系统请求共享资源失败&nbsp;&nbsp;②等待某种操作的完成&nbsp;&nbsp;③新数据尚未到达&nbsp;&nbsp;④等待新任务的到达 阻塞是进程自身的一种主动行为(图略) 进程同步机制的主要任务：是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好地相互合作，从而使程序的执行具有可再现性 多个进程并发时可能存在的制约关系：&nbsp;&nbsp;⑴间接相互制约关系：①多个进程对临界资源只能互斥地访问&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②资源由系统实施统一分配&nbsp;&nbsp;⑵直接相互制约关系：为完成同一项任务而相互合作 异步性会发生“与时间有关的错误”，为杜绝，需对进程的执行次序进行协调，保证诸进程能按序执行 临界区：每个进程中访问临界资源的那段代码 同步机制应遵循的规则：①空闲让进&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②忙则等待：以保证对临界资源的互斥访问&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③有限等待：应保证在有限时间内能进入自己的临界区&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④让权等待：若不能进入临界区，释放处理机 硬件同步机制&nbsp;&nbsp;⑴关中断：&nbsp;&nbsp;&nbsp;&nbsp;i. 方法：在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断&nbsp;&nbsp;&nbsp;&nbsp;ii. 缺点：①滥用关中断权利可能导致严重后果&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②关中断时间过长，会影响系统效率&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③不适用多CPU系统&nbsp;&nbsp;⑵利用Test-and-Set指令实现互斥：“测试并建立”&nbsp;&nbsp;⑶利用Swap指令实现进程互斥：为每个临界资源设置一个全局的布尔变量lock 信号量机制⑴整型信号量：wait(S)和signal(S)[原子操作]&nbsp;&nbsp;1) wait(S){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(S&lt;=0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S–;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;2) signal(S){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}⑵记录型信号量A. S-&gt;value的初值表示系统中某类资源的数目（资源信号量）B. S-&gt;value&lt;0，表示该类资源已分配完毕⑶AND信号量：将进程在整个运行过程中需要的所有资源，一次性全部的分配给进程，待进程使用完后再一起释放⑷信号量集：当进程申请某类临界资源时，在每次分配之前，都必须测试资源的数量，判断是否大于可分配的下限值，决定是否予以分配 信号量的应用⑴利用信号量实现进程互斥 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;互斥信号量mutex &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait：资源此刻未被访问，操作成功 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal：释放该临界资源⑵利用信号量实现前趋关系 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;公用信号量S &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal放在S1后面，wait插在S2前面 ==信号量机制的每个要访问临界资源的进程都必须自备同步操作== 管程⑴定义：&nbsp;&nbsp;①用少量信息和对该资源所执行的操作来表征该资源，而忽略它们内部结构和实现细节&nbsp;&nbsp;②代表共享资源的数据结构以及对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块&nbsp;&nbsp;③一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据⑵组成：&nbsp;&nbsp;①管程的名称&nbsp;&nbsp;②局部于管程的共享数据结构说明&nbsp;&nbsp;③对该数据结构进行操作的一组过程&nbsp;&nbsp;④对局部于管程的共享数据设置初始值的语句⑶特性：&nbsp;&nbsp;①模块化：管程是一个基本程序单位，可以单独编译&nbsp;&nbsp;②抽象数据类型：数据，和对数据的操作&nbsp;&nbsp;③信息隐蔽：管程中的数据结构只能被管程中的过程访问，具体实现外部不可见 所有进程要访问临界资源时，都只能通过管程间接访问，而管程每次只准许一个进程进入管程，执行管程内的过程，从而实现了进程互斥 ==进程通信：进程之间的信息交换== 高级通信工具的特点：&nbsp;&nbsp;①使用方便&nbsp;&nbsp;②高效地传送大量数据 进程通信的类型：⑴共享存储器系统&nbsp;&nbsp;①基于共享数据结构的通信方式&nbsp;&nbsp;②基于共享存储区的通信方式⑵管道通信系统 &nbsp;&nbsp;①管道：用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件&nbsp;&nbsp;②协调能力：&nbsp;&nbsp;&nbsp;&nbsp;i. 互斥&nbsp;&nbsp;&nbsp;&nbsp;ii. 同步&nbsp;&nbsp;&nbsp;&nbsp;iii. 确定对方是否存在⑶消息传递系统（使通信过程对用户透明化）&nbsp;&nbsp;①直接通信方式：OS的发送原语&nbsp;&nbsp;②间接通信方式：共享中间实体⑷客户机、服务器系统&nbsp;&nbsp;①套接字&nbsp;&nbsp;&nbsp;&nbsp;i. 基于文件型&nbsp;&nbsp;&nbsp;&nbsp;ii. 基于网络型&nbsp;&nbsp;②远程过程调用和远程方法调用&nbsp;&nbsp;&nbsp;&nbsp;i. 本地客户进程&nbsp;&nbsp;&nbsp;&nbsp;ii. 远程服务器进程 消息传递通信的实现方式⑴直接消息传递系统：&nbsp;&nbsp;①直接通信原语&nbsp;&nbsp;&nbsp;&nbsp;i. 对称寻址方式：不利于实现进程定义的模块化&nbsp;&nbsp;&nbsp;&nbsp;ii. 非对称寻址方式：无法事先指定发送进程&nbsp;&nbsp;②消息的格式：比较短的定长消息格式&nbsp;&nbsp;③进程的同步方式&nbsp;&nbsp;④通信链路&nbsp;&nbsp;&nbsp;&nbsp;i. 单向通信链路&nbsp;&nbsp;&nbsp;&nbsp;ii. 双向通信链路⑵信箱通信：进程之间的通信&nbsp;&nbsp;①信箱的结构：&nbsp;&nbsp;&nbsp;&nbsp;i. 信箱头：存放有关信箱的描述信息&nbsp;&nbsp;&nbsp;&nbsp;ii. 信箱体：若干个可以存放消息（头）的信箱格组成&nbsp;&nbsp;②信箱通信原语：&nbsp;&nbsp;&nbsp;&nbsp;i. 邮箱的创建和撤销&nbsp;&nbsp;&nbsp;&nbsp;ii. 消息的发送和接收&nbsp;&nbsp;③信箱的类型：&nbsp;&nbsp;&nbsp;&nbsp;i. 私用信箱：用户&nbsp;&nbsp;&nbsp;&nbsp;ii. 公用信箱：操作系统&nbsp;&nbsp;&nbsp;&nbsp;iii. 共享信箱：进程 发送进程和接收进程之间的关系：①一对一关系 ②多对一关系 ③一对多关系 ④多对多关系 ==引入线程的原因：为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性== 程序并发执行所需付出的时空开销：&nbsp;&nbsp;①创建进程&nbsp;&nbsp;②撤销进程&nbsp;&nbsp;③进程切换 线程：作为调度和分派的基本单位，轻型进程&nbsp;&nbsp;⑴调度的基本单位：在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然就会引起进程的切换&nbsp;&nbsp;⑵并发性：允许在一个进程中的所有线程都能并发执行&nbsp;&nbsp;⑶拥有资源：线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源&nbsp;&nbsp;⑷独立性：在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多&nbsp;&nbsp;⑸系统开销：线程的切换、同步和通信都无需操作系统内核的干预&nbsp;&nbsp;⑹支持多处理机系统：对于多线程进程，可以将一个进程的多个线程分配到多个处理机上 线程的基本状态：执行、就绪、阻塞 线程控制块TCB：线程标识符、一组寄存器、线程运行状态、优先级、线程专有存储区、信号屏蔽、堆栈指针 多线程OS中的进程属性：&nbsp;&nbsp;⑴进程是一个可拥有资源的基本单位&nbsp;&nbsp;⑵多个进程可并发执行&nbsp;&nbsp;⑶进程已不是可执行的实体 线程的实现方式：&nbsp;&nbsp;⑴内核支持线程KST：为每一个内核线程设置了一个线程控制块&nbsp;&nbsp;⑵用户级线程ULT：每个线程轮流执行一个时间片 ==调度的实质是一种资源分配，处理机调度室对处理机资源进行分配== 处理机调度的层次：&nbsp;&nbsp;①高级调度（长程调度、作业调度）：调度对象是作业，主要用于多道批处理系统&nbsp;&nbsp;②低级调度（进程调度、短程调度）：所调度的对象是进程（或内核级线程）&nbsp;&nbsp;③中级调度（内存调度，目的是提供内存利用率和系统吞吐量）：存储器管理的对换功能 进程调度的运行频率最高，作业调度算法花费较多时间 处理机调度算法的共同目标：&nbsp;&nbsp;①资源利用率：使处理机和其他资源尽可能保持忙碌状态&nbsp;&nbsp;②公平性：应使诸进程都获得合理的CPU时间，不会发生进程饥饿现象&nbsp;&nbsp;③平衡性：保持系统资源使用的平衡性&nbsp;&nbsp;④策略强制执行：只要需要，就必须予以准确地执行 批处理系统的目标：&nbsp;&nbsp;①平均周转时间短：&nbsp;&nbsp;&nbsp;&nbsp;i. 作业在外存后备队列上等待（作业调度）的时间&nbsp;&nbsp;&nbsp;&nbsp;ii. 进程在就绪队列上等待进程调度的时间&nbsp;&nbsp;&nbsp;&nbsp;iii. 进程在CPU上执行的时间&nbsp;&nbsp;&nbsp;&nbsp;iv. 进程等待I/O操作完成的时间&nbsp;&nbsp;②系统吞吐量高&nbsp;&nbsp;③处理机利用率高：单纯为使处理机利用率高，尽量多选择计算量大的作业运行 周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔带权周转时间：作业的周转时间T与系统为它提供服务的时间Ts之比（W=T/Ts）吞吐量：在单位时间内系统所完成的作业数 分时系统的目标：①响应时间快&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②均衡性实时系统的目标：①截止时间的保证&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②可预测性 响应时间：从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为止的一段时间间隔均衡性：系统响应时间的快慢应与用户所请求服务的复杂性相适应截止时间：某任务必须开始执行的最迟时间，或必须完成的最迟时间 作业：程序、数据，作业说明书作业步：每一个加工步骤称为一个作业步，各作业步之间存在着相互联系 作业控制块JCB：作业在系统中存在的标志&nbsp;&nbsp;1) 作业标识&nbsp;&nbsp;2) 用户名称&nbsp;&nbsp;3) 用户账号&nbsp;&nbsp;4) 作业类型&nbsp;&nbsp;5) 作业状态&nbsp;&nbsp;6) 调度信息&nbsp;&nbsp;7) 资源需求&nbsp;&nbsp;8) 资源使用情况 作业运行的三个阶段三个状态：&nbsp;&nbsp;⑴收容阶段（后备状态）：为作业建立JCB，放入后备队列&nbsp;&nbsp;⑵运行阶段（运行状态）：分配必要的资源和建立进程&nbsp;&nbsp;⑶完成阶段（完成状态）：运行完成或者异常结束 作业调度的主要任务：&nbsp;&nbsp;&nbsp;&nbsp;根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度 被称为接纳调度需作出的决定：&nbsp;&nbsp;①接纳多少个作业：允许多少个作业同时在内存中运行&nbsp;&nbsp;②接纳哪些作业：取决于所采用的调度算法 作业调度算法：&nbsp;&nbsp;⑴先来先服务FCFS：①按照作业到达的先后次序来进行调度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②优先考虑在系统中等待时间最长的作业&nbsp;&nbsp;⑵短作业优先SJF：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) 定义：作业越短，其优先级越高&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) 缺点：①必须预知作业的运行时间。一般会偏长估计 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②对长作业非常不利。可能使作业等待时间过长，出现饥饿现象 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③人–机无法实现交互 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④不能保证紧迫性作业能得到及时处理⑶优先级调度算法PSA：基于作业的紧迫程度，由外部赋予作业相应的优先级⑷高响应比优先调度算法HRRN：既考虑了作业的等待时间，又考虑作业运行时间的调度算法 响应比Rp=等待+要求服务时间/要求服务时间=响应时间/要求服务时间 进程调度的任务：&nbsp;&nbsp;⑴保存处理机的现场信息&nbsp;&nbsp;⑵按某种算法选取进程&nbsp;&nbsp;⑶把处理器分配给进程 进程调度机制：&nbsp;&nbsp;⑴排队器：为提高进程调度的效率，事先将系统中的所有就绪进程按照一定的策略排成一个或多个队列&nbsp;&nbsp;⑵分派器：将处理机分配给新选出的进程&nbsp;&nbsp;⑶上下文切换器：两对上下文切换 减少上下文切换：采用两组寄存器，一组寄存器供处理机在系统态使用，另一组供应用程序使用 进程调度方式⑴非抢占方式&nbsp;&nbsp;&nbsp;&nbsp;①定义：一旦把处理机分配给某进程后，就一直让它运行下去&nbsp;&nbsp;&nbsp;&nbsp;②优点：实现简单，系统开销小⑵抢占方式：&nbsp;&nbsp;&nbsp;&nbsp;①定义：允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程&nbsp;&nbsp;&nbsp;&nbsp;②抢占原则&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i. 优先权原则&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii. 短进程优先原则&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii. 时间片原则 进程调度算法：⑴轮转调度算法RR：让就绪队列上的每个进程每次仅运行一个时间片，每个一定时间间隔产生一次中断，一个时间片大小是略大于一次典型的交互所需要的时间⑵优先级调度算法：把处理机分配给就绪队列中优先级最高的进程 &nbsp;&nbsp;①调度算法类型：&nbsp;&nbsp;&nbsp;&nbsp;i. 非抢占式优先级调度算法：一直执行下去直至完成&nbsp;&nbsp;&nbsp;&nbsp;ii. 抢占式优先级调度算法：将处理机分配给新到的优先级最高的进程，常用于对实时性要求较高的系统中 &nbsp;&nbsp;②优先级类型：&nbsp;&nbsp;&nbsp;&nbsp;i. 静态优先级：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) 含义：在创建进程时确定，在进程的整个运行期间保持不变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) 影响大小的因素：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i. 进程类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii. 进程对资源的需求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii. 用户要求&nbsp;&nbsp;&nbsp;&nbsp;ii. 动态优先级：在创建进程之初，先赋予其一个优先级，其值随进程的推进或等待时间的增长，使其优先级相应提高。可防止一个长作业长期地垄断处理机&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) 含义：在创建进程时确定，在进程的整个运行期间保持不变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) 影响大小的因素：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i. 进程类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii. 进程对资源的需求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii. 用户要求⑶多队列调度算法：将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法⑷多级反馈队列调度算法：&nbsp;&nbsp;①调度机制：&nbsp;&nbsp;&nbsp;&nbsp;i. 设置多个就绪队列&nbsp;&nbsp;&nbsp;&nbsp;ii. 每个队列都采用FCFS&nbsp;&nbsp;&nbsp;&nbsp;iii. 按队列优先级调度&nbsp;&nbsp;②算法性能：&nbsp;&nbsp;&nbsp;&nbsp;i. 终端型用户&nbsp;&nbsp;&nbsp;&nbsp;ii. 短批处理作业用户&nbsp;&nbsp;&nbsp;&nbsp;iii. 长批处理作业用户：不必担心其作业长期得不到处理⑸基于公平原则的调度算法： &nbsp;&nbsp;①保证调度算法：保证每个进程都获得相同的处理机时间 &nbsp;&nbsp;②公平分享调度算法：使所有用户能获得相同的处理机时间，或所要求的时间比例，考虑到每一个用户所拥有的进程数目 实现实时调度的基本条件⑴提供必要的信息：&nbsp;&nbsp;①就绪时间：某任务称为就绪状态的起始时间&nbsp;&nbsp;②开始截止时间和完成截止时间&nbsp;&nbsp;③处理时间：一个任务从开始执行，直至完成时所需的时间&nbsp;&nbsp;④资源要求&nbsp;&nbsp;⑤优先级⑵系统处理能力强 &nbsp;&nbsp;提高系统处理能力：①单处理机：减少对每一个任务的处理时间 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②多处理机：Ci/Pi&lt;=N⑶采用抢占式调度机制⑷具有快速切换机制 &nbsp;&nbsp;应具有的能力：①对中断的快速响应能力：使禁止中断的时间间隔尽量短&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②快速的任务分派能力 实时调度算法类型：⑴非抢占式调度算法：①非抢占式调度算法：轮转队列 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②非抢占式优先调度算法：赋予较高的优先级⑵抢占式调度算法：①基于时钟中断的抢占式优先级调度算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②立即抢占的优先级调度算法 实时调度算法：⑴最早截止时间优先EDF算法&nbsp;&nbsp;①定义：根据任务的截止时间确定任务的优先级，任务的截止时间愈早，其优先级愈高&nbsp;&nbsp;②类型：&nbsp;&nbsp;&nbsp;&nbsp;i. 非抢占式调度方式用于非周期实时任务&nbsp;&nbsp;&nbsp;&nbsp;ii. 抢占式调度方式用于周期实时任务⑵最低松弛度优先LLF&nbsp;&nbsp;①定义：任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。&nbsp;&nbsp;②要求：系统中有一个按松弛度排序的实时任务就绪队列&nbsp;&nbsp;③目的：保证不遗漏任何一次截止时间&nbsp;&nbsp;④公式：松弛度=必须完成时间–其本身的运行时间–当前时间 优先级倒置：①定义：高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞②解决方法：&nbsp;&nbsp;i. 简单：假如进程p3在进入临界区后p3所占用的处理机就不允许抢占&nbsp;&nbsp;ii. 实用：建立在动态优先级继承基础上。当高优先级进程p1要进入临界区，去使用临界资源R，如果已有一个低优先级进程p3正在使用该资源，此时一方面p1被阻塞，另一方面由p3继承p1的优先级，并一直保持到p3退出临界区 ==引起死锁的主要是临界资源== 可重用性资源：①定义：一种可供用户重复使用多次的资源②性质：&nbsp;&nbsp;a) 每一个资源单元只能分配给一个进程使用&nbsp;&nbsp;b) 按顺序：请求资源-&gt;使用资源-&gt;释放资源&nbsp;&nbsp;c) 单元数目相对固定，进程在运行期间既不能创建也不能删除 可消耗性资源（临时性资源）：①定义：在进程运行期间，由进程动态地创建和消耗的 ②性质：&nbsp;&nbsp;a) 单元数目可不断变化&nbsp;&nbsp;b) 进程在运行过程中，可以不断地创造可消耗性资源的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目&nbsp;&nbsp;c) 进程在运行过程中，可以请求若干个可消耗性资源单位，用于进程自身的消耗 可消耗性资源通常是由生产者进程创建，由消费者进程消耗，如用于进程间通信的消息 可抢占性资源：某进程在获得这类资源后，该资源可以再被其他进程或系统抢占不可抢占性资源：一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放 死锁的起因：①竞争不可抢占性资源引起死锁：资源数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局②竞争可消耗资源引起死锁：如消息通信机制③进程推进顺序不当引起死锁：对资源进行申请和释放的顺序是否合法 ==死锁的定义：如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的== 产生死锁的必要条件：（必须同时具备）①互斥条件：进程对所分配到的资源进行排它性使用。在一段时间内，某资源只能被一个进程使用②请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求③不可抢占条件：进程已获得的资源在未使用完之前不能被抢占，只能在进程使用完时由自己释放④循环等待条件：在发生死锁时，必然存在一个进程–资源的循环链 处理死锁的方法：（对死锁的防范程度逐渐减弱，资源利用率提高，并发程度提高）①预防死锁：设置某些限制条件，去破坏产生死锁四个必要条件的一个或几个来预防产生死锁②避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态③检测死锁：通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来④解除死锁：撤销一些进程，回收它们的资源，分配给已处于阻塞状态的进程，使其能继续运行 预防死锁：⑴互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证⑵破坏“请求和保持条件”：（当一个进程在请求资源时，不能持有不可抢占资源） &nbsp;&nbsp;①第一种协议：&nbsp;&nbsp;&nbsp;&nbsp;1) 定义：所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源&nbsp;&nbsp;&nbsp;&nbsp;2) 优点：简单易行安全&nbsp;&nbsp;&nbsp;&nbsp;3) 缺点：资源被严重浪费，严重地恶化了资源的利用率，还会使进程经常会发生饥饿现象&nbsp;&nbsp;②第二种协议：&nbsp;&nbsp;1) 定义：允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中，再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源&nbsp;&nbsp;2) 优点：使进程更快地完成任务，提高设备的利用率，还可以减少进程发生饥饿的几率⑶破坏“不可抢占”条件&nbsp;&nbsp;①定义：当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请&nbsp;&nbsp;②缺点：使进程的执行被无限地推迟，延长了进程的周转时间，增加了系统开销，降低了系统的吞吐量⑷破坏“循环等待”条件 &nbsp;&nbsp;①定义：对系统所有资源类型进行线性排序，并赋予不同的序号，并规定每个进程必须按序号递增的顺序请求资源。例如，进程已请求到一些序号高的资源，又想申请序号低的资源时，必须先释放所有具有相同和更高序号的资源后，才能申请序号低的资源 &nbsp;&nbsp;②问题：&nbsp;&nbsp;&nbsp;&nbsp;a) 序号必须相对稳定，则限制了新类型设备的增加&nbsp;&nbsp;&nbsp;&nbsp;b) 作业使用各类资源的顺序与系统规定的顺序不同，造成对资源的浪费&nbsp;&nbsp;&nbsp;&nbsp;c) 限制用户简单、自主地编程 ==避免死锁：在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁== 当系统处于安全状态，可避免发生死锁（便不会进入死锁状态）当系统处于不安全状态，则可能进入到死锁状态 避免死锁的实质在于，系统在进行资源分配时，应使系统不进入不安全状态避免死锁的基本思想，确保系统始终保持安全状态 安全状态：系统能按某种进程推进顺序（P1，P2，…，Pn）为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成，此时称（P1，P2，…，Pn）为安全序列 最有代表性的避免死锁的算法是Dijkstra的银行家算法。为实现银行家算法，每一个新进程在进入进程时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。系统必须首先确定是否有足够的资源分配给该进程 银行家算法中的数据结构：①可利用资源向量Available：系统可利用的资源，初始值是系统中所配置的该类全部可用资源的数目②最大需求矩阵Max：所有进程对资源的最大需求③分配矩阵Allocation：已分配给每一进程的资源数④需求矩阵Need：每一个进程尚需的各类资源⑤矩阵关系：Need[i-j]=Max[I,j]-Allocation[i,j] 银行家算法：（Request是进程P的请求向量）①Request[j]&lt;=Need[i,j]：判断是否超过最大值②Request[j]&lt;=Available[j]：判断是否能够满足③系统试探着把资源分配给进程，并修改数值：&nbsp;&nbsp;Available[j]= Available[j]- Request[j]&nbsp;&nbsp;Allocation[i,j]= Allocation[i,j]+ Request[j]&nbsp;&nbsp;Need[i,j]= Need[i,j]-Request[j]④系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。 安全性算法：①设置向量：&nbsp;&nbsp;a) 工作向量Work：系统可提供给进程继续执行所需的各类资源数目，最初Work=Available&nbsp;&nbsp;b) Finish：系统是否有足够的资源分配给进程，使之运行完成，最初Finish[i]=false②找到满足下列条件的进程：&nbsp;&nbsp;a) Finsh[i]=false&nbsp;&nbsp;b) Need[i,j]&lt;=Work[j];③进程P获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，执行：&nbsp;&nbsp;a) Work[j]=Work[j]+Allocation[i,j];&nbsp;&nbsp;b) Finish[i]=true&nbsp;&nbsp;c) go to step 2；④假如所有进程的Finish[i]=true都满足，则表示系统处于安全状态 死锁检测对系统的要求：①保存有关资源的请求和分配信息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②提供一种算法，它利用这些信息来检测系统是否已进入死锁状态 资源分配图：①圆圈：一个进程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②方框：一类资源 若能消去图中所有的边，是所有的进程节点都成为孤立结点，则称该图是可完全简化的所有的简化顺序都将得到相同的不可简化图 ==死锁定理：S为死锁状态的充分条件，当且仅当S状态的资源分配图是不可完全简化的== 死锁解除：①简单：立即通知操作员，请操作员来以人工方法处理死锁②利用死锁解除算法：&nbsp;&nbsp;a) 抢占资源：从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态&nbsp;&nbsp;b) 终止（或撤销）进程：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I. 终止所有死锁进程：付出代价大&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;II. 逐个终止进程：按照某种顺序，逐个地终止进程，直至有足够的资源，以打破循环等待，把系统从死锁状态中解脱出来为止&nbsp;&nbsp;c) 付出代价最小的死锁解除算法 存储器的主要对象是内存 存储层次：&nbsp;&nbsp;①CPU寄存器：寄存器&nbsp;&nbsp;②主存：高速缓存、主存储器、磁盘缓存&nbsp;&nbsp;③辅存：固定磁盘、可移动存储介质 存储器的要求：&nbsp;&nbsp;①速度快&nbsp;&nbsp;②容量大&nbsp;&nbsp;③价格便宜 操作系统的存储管理范畴：寄存器，高速缓存，主存储器，磁盘缓存（掉电后存储信息不再存在） 可执行存储器：寄存器和主存储器 对辅存的访问需要通过I/O设备实现 操作系统的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数据移动的管理机制 主存储器（主存、内存）：用于保存进程运行时的程序和数据，访问速度远低于CPU执行指令的速度 寄存器：具有与处理机相同的速度，主要存放处理机运行时的数据，以加速存储器的访问速度 高速缓存：备份主存中较常用的数据，以减少处理机对主存储器的访问次数，缓和内存与处理机速度之间的矛盾 当CPU访问一组特定信息时，须检查它是否在高速缓存，若存在，可避免访问主存 紧靠内存的一级高级缓存的速度最高，而容量最小 磁盘缓存：缓和磁盘的I/O速度和对主存的访问速度。不实际存在的存储器，而是利用主存中的部分存储空间暂时存放从磁盘中读出（或写入）的信息辅存中的数据必须复制到主存方可使用，数据也必须先存在主存，才能输出到辅存 应用程序步骤：①编译：编译程序对源程序进行编译，形成若干个目标模块②链接：链接程序将目标模块和所需的库函数链接，形成一个完整的装入模块③装入：装入程序将装入模块装入内存 装入方式：⑴绝对装入方式：将目标模块装入到内存中事先指定的位置⑵可重定位装入方式：可根据内存的具体情况将装入模块装入到内存的适当位置，不允许程序运行时在内存中移动位置⑶动态运行时的装入方式：装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是将这种地址转换推迟到程序真正要执行时才进行 链接方式：⑴静态链接方式：&nbsp;&nbsp;①定义：在程序执行之前，将各目标模块及它们所需的库函数连接成一个完整的装配模块，以后不再拆开 &nbsp;&nbsp;②问题：&nbsp;&nbsp;&nbsp;&nbsp;i. 对相对地址进行修改&nbsp;&nbsp;&nbsp;&nbsp;ii. 变换外部调用符号⑵装入时动态链接：&nbsp;&nbsp;①定义：在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块 &nbsp;&nbsp;②优点：&nbsp;&nbsp;&nbsp;&nbsp;i. 便于修改和更新&nbsp;&nbsp;&nbsp;&nbsp;ii. 便于实现对目标模块的共享⑶运行时动态链接：&nbsp;&nbsp;①定义：将对某些模块的链接推迟到程序执行时才去进行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块，并将之装入内存，将其链接到调用者模块上&nbsp;&nbsp;②优点：&nbsp;&nbsp;&nbsp;&nbsp;I. 加快程序的装入过程&nbsp;&nbsp;&nbsp;&nbsp;II. 节省大量的内存空间 连续分配方式：（程序中代码或数据的逻辑地址相邻，内存空间分配时物理地址的相邻）⑴单一连续分配：系统区、用户区⑵固定分区分配：&nbsp;&nbsp;①定义：每个分区只装入一道作业，不相互干扰 &nbsp;&nbsp;②方法：&nbsp;&nbsp;&nbsp;&nbsp;I. 分区大小相等：方便实用，小则浪费内存空间，大则不足以装入程序&nbsp;&nbsp;&nbsp;&nbsp;II. 分区大小不等：可根据程序的大小，为之分配适当的分区 &nbsp;&nbsp;③分区使用表：&nbsp;&nbsp;&nbsp;&nbsp;i. 起始地址&nbsp;&nbsp;&nbsp;&nbsp;ii. 大小&nbsp;&nbsp;&nbsp;&nbsp;iii. 状态⑶动态分区分配（可变分区分配）：根据进程的实际需要，动态地为之分配内存空间 &nbsp;&nbsp;①数据结构：&nbsp;&nbsp;&nbsp;&nbsp;I. 空闲分区表：分区号、分区大小、分区始址&nbsp;&nbsp;&nbsp;&nbsp;II. 空闲分区链：用于控制分区分配的信息、前向指针、后向指针&nbsp;&nbsp;②分配操作：分配内存-&gt;回收内存 基于顺序搜索的动态分区分配算法：依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区⑴首次适应算法（FF）： &nbsp;&nbsp;①要求：空闲分区链以地址递增的次序链接 &nbsp;&nbsp;②优点：优先利用内存中低址部分的空闲分区，为以后到达的大作业分配大的内存空间创造了条件 &nbsp;&nbsp;③缺点：低址部分不断被划分，留下很多碎片，且增加查找可用空闲分区时的开销⑵循环首次适应算法（NF）：在为进程分配内存空间时，从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区⑶最佳适应算法（BF）：每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免“大材小用”⑷最坏适应（WF）：&nbsp;&nbsp;①定义：在扫描整个空闲分区表或链表时，总是挑选一个最大的空闲区，从中分割一部分存储空间给作业使用&nbsp;&nbsp;②要求：所有的空闲分区按其容量以从大到小的顺序形成一空闲分区链 基于索引搜索的动态分区分配算法：⑴快速适应算法（分类搜索法）：将空闲分区根据其容量大小进行分类，管理索引表和指针⑵伙伴系统：无论已分配分区或空闲分区，其大小均为2的k次幂⑶哈希算法：以空闲分区大小为关键字的哈希表和表头指针 连续分配方式的特点：一个系统或用户程序必须被装入一片连续的内存空间中 碎片（零头）：不能被利用的小分区 紧凑（拼接）：通过移动内存中作业的位置，把原来多个分散的小分区拼接成一个大分区的方法。 每次“紧凑”后必须对移动了的程序或数据进行重定位 重定位寄存器：存放程序（数据）在内存中的起始地址 ==地址变换过程是在程序执行期间，随着对每条指令或数据的访问自动进行的，故称为动态重定位== 使用可变分区分配方式，分配给每一个进程的内存空间根据进程程序而定。 离散分配：（一个进程直接分散地装入到许多不相邻接的分区）⑴分页存储管理方式：（将用户程序的地址空间分为若干个固定大小的区域）&nbsp;&nbsp;①页面和物理块：&nbsp;&nbsp;&nbsp;&nbsp;I. 页面：内存分配以块为单位&nbsp;&nbsp;&nbsp;&nbsp;II. 页面大小：2的幂，选择适中 &nbsp;&nbsp;②地址结构：页号P、位移量W &nbsp;&nbsp;③页表（页面映像表）：通过查找该表，能找到每页在内存中的物理块号，作用是实现 从页号到物理块号的地址映射 &nbsp;&nbsp;④存取控制字段：用于对该存储块中的内容加以保护⑵分段存储管理方式：（为每个分段分配一个连续的分区）&nbsp;&nbsp;①分段：每一段定义了一组逻辑信息 &nbsp;&nbsp;②分段地址：段号+段内地址 &nbsp;&nbsp;③段表：记录该段在内存中的起始地址（基址）和段的长度，实现从逻辑段到物理内存区的映射⑶段页式存储管理方式（同时具备两者的优点。）&nbsp;&nbsp;①定义：将用户程序分成若干段，再把每个段分成若干页，并为每一个段赋予一个段名&nbsp;&nbsp;②作业地址空间：主程序段、子程序段和数据段 &nbsp;&nbsp;③地址结构：段号、段内页号、页内地址&nbsp;&nbsp;④三次访问内存：&nbsp;&nbsp;&nbsp;&nbsp;I. 访问段表，取得页表始址&nbsp;&nbsp;&nbsp;&nbsp;II. 访问页表，取得物理地址&nbsp;&nbsp;&nbsp;&nbsp;III. 取出指令或地址 地址变换机构⑴基本任务：将逻辑地址的页号转换为内存中的物理块号，实现从逻辑地址到物理地址的转换⑵类型：&nbsp;&nbsp;①基本的地址变换机构：设置一个页表寄存器PTR存放页表在内存的始址和页表的长度（CPU每存取一个数据时，两次访问内存）&nbsp;&nbsp;②具有快表的地址变换机构：&nbsp;&nbsp;&nbsp;&nbsp;I. 硬件支持：具有并行查寻能力的联想寄存器（快表）&nbsp;&nbsp;&nbsp;&nbsp;II. 变换过程：由地址变换机构自动的将页号P送入高速缓冲寄存器。未找到则再访问内存 内存的有效访问时间EAT：①定义：从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所需要花费的总时间）②公式：EAT=a λ +(t+λ)(1-a)+t=2t+λ-ta（λ表示查找快表所需要的时间，a表示命中率，t表示访问一次内存所需要的时间） 命中率：使用快表并在其中成功查找到所需页面的表项的比率 在外层页表的每个页表项中所存放的是某页表分页的首址外层页表寄存器：存放外层页表的始址多级页表：将外层页表再进行分页离散分配空间的办法并未减少页表所占用的内存空间 反置页表：①定义：为每一个物理块设置一个页表项，并将它们按物理块的编号排序②优点：可有效地减少页表占用的内存 引入分段存储管理方式的原因：（为了满足用户程序员在编程和使用上多方面的要求）①方便编程：使程序直观，更具可读性②信息共享：段是信息的逻辑单位，简化了共享的实现③信息保护：每个程序段有不同的保护属性，更有效方便地实现对信息的保护功能④动态增长：数据量、数据段、存储空间动态增加⑤动态链接：以目标程序（即段）作为链接的基本单位 分段和分页的区别：①页是信息的物理单位，段是信息的逻辑单位②页的大小固定且由系统决定，段的长度不固定③分页的用户程序地址属于单一的线性地址空间，而分段的地址空间是二维的，既给出段名，又给出段内地址 分段系统的优点：易于实现段的共享，即允许若干个进程共享一个或多个分段 可重入代码（纯代码）：一种允许多个进程同时访问的代码，不允许任何进程对它进行修改 虚拟存储器：具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。逻辑容量由内存容量和外存容量之和所决定，运行速度接近内存，成本接近外存。既满足用户需要，又改善了系统的性能。 常规存储器管理方式的特征：①一次性：作业必须一次性地全部装入内存后方能开始运行。直接限制了对处理机的利用率和系统的吞吐量的提高②驻留性：作业被装入内存后，整个作业都一直驻留在内存中，直至作业运行结束才换出 局部性原理：在一较短的时间内，程序的执行仅局限于某一部分，相应的，它所访问的存储空间也局限于某个区域&nbsp;&nbsp;①程序执行时，除了少部分的转移和过程调用指令外，在大多数情况下是顺序执行的&nbsp;&nbsp;②过程调用的深度在大多数情况下都不超过5&nbsp;&nbsp;③程序中存在许多循环结构，被多次执行&nbsp;&nbsp;④对数据结构的处理局限于很小的范围内 局限性：⑴时间局限性 &nbsp;&nbsp;①原因：在程序中存在大量的循环操作 &nbsp;&nbsp;②现象：如果程序中的某条指令被执行，则不久以后该指令可能再次执行 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果某数据被访问过，则不久以后该数据可能再次被访问⑵空间局限性 &nbsp;&nbsp;①原因：程序的顺序执行 &nbsp;&nbsp;②现象：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问 虚拟存储器的基本工作情况： &nbsp;&nbsp;&nbsp;&nbsp;程序在运行时，如果它所要访问的页（段）已调入内存，便可继续执行下去；但如果程序所要访问的页（段）尚未调入内存（称为缺页或缺段），便发出缺页（段）中断请求，此时OS将利用请求调页（段）功能将它们调入内存，以使进程能继续执行下去。如果此时内存已满，无法再装入新的页（段），OS还需再利用页（段）的置换功能，将内存暂时不用的页（段）调至盘上，腾出足够的内存空间后，再将要访问的页（段）调入内存，使程序继续执行下去 虚拟存储器的特征：（虚拟性是以多次性和对换性为基础的）⑴多次性（最重要特征）：一个作业中的程序和数据允许被分成多次调入内存运行，即只需将当前要运行的那部分程序和数据装入内存即可开始运行⑵对换性：&nbsp;&nbsp;①在进程运行期间，允许将那些暂不使用的代码和数据从内存调至外存的对换区（换出），待以后需要时再将它们从外存调至内存（换进）&nbsp;&nbsp;②允许在作业的运行过程中进行换进换出&nbsp;&nbsp;③换进和换出能有效的提高内存利用率⑶虚拟性：&nbsp;&nbsp;①从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量&nbsp;&nbsp;②优点：改善内存的利用率，提高程序执行的并发程度，增加系统的吞吐量 虚拟存储器的实现，建立在离散分配存储管理方式的基础上 分页请求系统：在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统，允许用户程序只装入少数页面的程序数据即可启动运行⑴硬件支持：&nbsp;&nbsp;①请求分页的页表机制&nbsp;&nbsp;②缺页中断机构&nbsp;&nbsp;③地址变换机构⑵软件支持：&nbsp;&nbsp;①实现请求调页的软件&nbsp;&nbsp;②实现页面置换的软件 请求分段系统：在分段系统的基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统，允许用户出现只要装入少数段的程序和数据即可启动运行⑴硬件支持：&nbsp;&nbsp;①请求分段的段表机制&nbsp;&nbsp;②缺段中断机构&nbsp;&nbsp;③地址变换机构⑵软件支持：&nbsp;&nbsp;①实现请求调段的软件&nbsp;&nbsp;②实现段置换的软件 请求分页系统在实现上要比请求分段系统简单 请求页表机制：（请求页表）&nbsp;&nbsp;①页号&nbsp;&nbsp;②物理块号&nbsp;&nbsp;③状态位（存在位）P：用于指示该页是否被调入内存，供程序访问时参考&nbsp;&nbsp;④访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问&nbsp;&nbsp;⑤修改位M：标识该页在调入内存后是否被修改过&nbsp;&nbsp;⑥外存地址：该页在外存的地址 缺页中断机构：&nbsp;&nbsp;①在指令执行期间产生和处理中断信号（立即）&nbsp;&nbsp;②一条指令在执行期间可能产生多次缺页中断 地址变换机构：&nbsp;&nbsp;①检索快表：修改访问位和修改位&nbsp;&nbsp;②到内存去查找页表：判断状态位，写入快表 请求分页中的内存分配：⑴最小物理块数的确定：能保证进程正常运行所需的最小物理块数⑵内存分配策略：&nbsp;&nbsp;①固定分配局部置换&nbsp;&nbsp;②可变分配全局置换&nbsp;&nbsp;③可变分配局部置换：当某进程发现缺页时，只允许从该进程在内存的页面中选择一页换出&nbsp;&nbsp;&nbsp;&nbsp;i. 固定分配：为每个进程分配一组固定数目的物理块，在进程运行期间不再改变&nbsp;&nbsp;&nbsp;&nbsp;ii. 可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少&nbsp;&nbsp;&nbsp;&nbsp;iii. 局部置换：如果进程在运行中发现缺页，则只能从分配给该进程的n个页面中选出一页换出。然后再调入一页，以保证分配给该进程的内存空间不变&nbsp;&nbsp;&nbsp;&nbsp;iv. 全局置换：如果进程在运行中发现缺页，则将OS所保留的空闲物理块取出一块分配给该进程，或者以所有进程的全部物理块为标的，选择一块换出，然后将所缺之页调入 物理块分配算法①平均分配算法：将系统中所有可供分配的物理块平均分配的物理块平均分配给各个进程②按比例分配算法：根据进程的大小按比例分配物理块③考虑优先权的分配算法：为高优先进程适当地增加其相应份额 页面调入策略：⑴确定系统将进程运行时所缺的页面调入内存的时机：&nbsp;&nbsp;①预调页策略：将预计在不久之后便会被访问的页面预先调入内存&nbsp;&nbsp;②请求调页策略：进程访问程序数据，若发现其所在页面不在内存，便立即提出请求⑵从何处将缺页调入内存（三种情况） &nbsp;&nbsp;①系统拥有足够的对换区空间：全部从对换区调入所需页面 &nbsp;&nbsp;②系统缺少足够的对换区空间：直接从文件区调入，换出时调到对换区 &nbsp;&nbsp;③UNIX方式：该系统允许页面共享，页面可能已被其他进程调入内存 页面调入过程： &nbsp;&nbsp;&nbsp;&nbsp;每当程序所要访问的页面未在内存时（存在位为“0”），便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后转入缺页中断处理程序。该程序通过查找页表得到该页在外存的物理块后，如果此时内存能容纳新页，则启动磁盘I/O，将所缺之页调入内存，然后修改页表。如果内存已满，则须先按照某种置换算法，从内存中选出一页准备换出；如果该页未被修改过（修改位为“0”），可不必将该页写回磁盘；但如果此页已被修改过（修改位为“1”），则必须将它写回磁盘，然后再把所缺的页调入内存，并修改页表中的相应表项，置其存在位为“1”，并将此页表项写入快表中 缺页率：①公式=访问失败次数/页面访问次数 ②影响因素：&nbsp;&nbsp;a) 页面大小&nbsp;&nbsp;b) 进程所分配物理块的数目&nbsp;&nbsp;c) 页面置换算法&nbsp;&nbsp;d) 程序固有属性：程序编制的局部化程度越高，相应执行时的缺页程度越低③缺页中断处理时间：t=βtA+(1-β)tB （置换页面被修改概率β，其缺页中断时间tA，置换页面没有被修改的时间tB） 页面置换算法：（选择换出页面的算法）⑴最佳Optimal置换算法：所选择的被淘汰页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面⑵先进先出FIFO页面置换算法：淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰⑶最近最久未使用LRU置换算法&nbsp;&nbsp;①描述：选择最近最久未使用的页面予以淘汰&nbsp;&nbsp;②硬件支持&nbsp;&nbsp;&nbsp;&nbsp;a) 寄存器：页面配置移位寄存器&nbsp;&nbsp;&nbsp;&nbsp;b) 栈：保存当前使用的各个页面的页面号，栈顶始终是最新被访问页面的编号，栈底则是最近最久未使用页面的页面号⑷最少使用LFU置换算法：选择在最近时期使用最少的页面作为淘汰页&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（移位寄存器：记录该页面被访问的频率）⑸Clock置换算法（循环的检查各页面的使用情况）&nbsp;&nbsp;①简单的Closk置换算法（最近未用算法NRU）： 为每页设置一位访问位，再将内存中的所有页面都通过链接指针连接成一个循环队列。若0则选择该页换出，若1则将其置0 &nbsp;&nbsp;②改进型Clock置换算法：同时检查访问位与修改位（置换代价） 页面缓冲算法PBA：特点：①显著地降低了页面换进换出的频率&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②不需要特殊硬件的支持，实现简单 设置的两个链表：①空闲页面链表：免除从磁盘读入数据的操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②修改页面链表：减少已修改页面换出的次数 影响页面换进换出效率的因素：①页面置换算法：缺页率低可减少页面换进换出的开销 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②写回磁盘的频率 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③读入内存的频率 被访问页不在内存中，内存的有效访问时间EAT=λ+aλ +(1-a)[t+f(+λ+t)+(1-f)(λ+t)]λ表示查找快表所需要的时间，a表示命中率，t表示访问实际物理地址所需要的时间，缺页中断时间ε，缺页率f 抖动：⑴定义：造成每个进程的大部分时间用于页面的换进换出⑵产生原因：同时运行的进程太多，分配给每一个进程的物理块太少，频繁出现缺页⑶预防方法：&nbsp;①采取局部置换策略&nbsp;②把工作集算法融入到处理机调度中&nbsp;③利用“L=S”准则调节缺页率&nbsp;④选择暂停的进程 ==工作集：在某段时间间隔里，进程实际所要访问页面的集合== 请求段表：&nbsp;&nbsp;①段名&nbsp;&nbsp;②段长&nbsp;&nbsp;③段基址&nbsp;&nbsp;④存取方式：只执行、只读、允许读/写&nbsp;&nbsp;⑤访问字段A：用于记录该段被访问的频繁程度&nbsp;&nbsp;⑥修改位M：表示该页在进入内存后是否已被修改过&nbsp;&nbsp;⑦存在位：用于指示本段是否已调入内存&nbsp;&nbsp;⑧增补位：用于表示本段在运行过程中是否做过动态增长&nbsp;&nbsp;⑨外存始址：指示本段在外存中的起始地址 不可能出现一条指令被分割在两个分段中，和一组信息被分割在两个分段中的情况 共享段表：&nbsp;①共享进程计数count：记录有多少进程正在共享该分段&nbsp;②存取控制字段：为不同的进程赋予不同的存取权限&nbsp;③段号：每个进程可用自己进程的段号去访问该共享段 分段保护：&nbsp;①越界检查：利用地址变换机构完成&nbsp;②存取控制检查：用于规定对该段程序或数据进行读访问&nbsp;③环保护机构（规则）：&nbsp;I. 一个程序可以访问驻留在相同环或者较低特权环（外环）中的数据&nbsp;II. 一个程序可以调用驻留在相同环或者较高特权环（内环）中的服务 I/O系统管理：⑴主要对象：I/O设备和相应的设备控制器⑵主要任务：完成用户提出的I/O请求，提高I/O速率，以及提高设备的使用率，并能为更高层的进程方便地使用这些设备提供手段 I/O系统的基本功能⑴隐藏物理设备的细节：对设备加以适当的抽象，隐藏物理设备的实现细节⑵与设备的无关性：使用抽象的I/O命令，还可使用抽象的逻辑设备名来使用设备⑶提高处理机和I/O设备的利用率：尽可能地让处理机和I/O设备并行操作⑷对I/O设备进行控制 &nbsp;控制方式：①采用轮询的可编程的I/O方式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②采用中断的可编程I/O方式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③直接存储器访问方式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④I/O通道方式⑸确保对设备的正确共享 &nbsp;共享属性的设备类型： &nbsp;&nbsp;&nbsp;&nbsp;①独占设备（打印机、磁带机）：进程互斥访问&nbsp;&nbsp;&nbsp;&nbsp;②共享设备（磁盘）：在一段时间内允许多个进程同时访问⑹错误处理：&nbsp;&nbsp;①临时性错误：可通过重试操作纠正&nbsp;&nbsp;②持久性错误：向上层报告 I/O软件的层次结构：&nbsp;①用户层I/O软件：实现与用户交互的接口&nbsp;②设备独立性软件：实现用户程序与设备驱动器的统一接口、设备命名、设备保护及设备分配释放&nbsp;③设备驱动程序：具体实现系统对设备发出的操作指令&nbsp;④中断处理程序 I/O系统的分层：&nbsp;①中断处理程序&nbsp;②设备驱动程序&nbsp;③设备独立性软件 I/O系统的上下接口：⑴I/O系统接口：（方便高层对设备的使用） &nbsp;&nbsp;①块设备接口：（块设备管理程序与高层之间的接口）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I. 块设备：数据的存取和传输都是以数据块为单位的设备&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a) 传输速率较高&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b) 可寻址：能指定数据的输入源地址及输出的目标地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;II. 隐藏了磁盘的二维结构：线性序列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;III. 将抽象命令映射为低层操作 &nbsp;&nbsp;②流设备接口：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i. 字符设备：数据的存取和传输都是以字符为单位的设备&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii. get和put操作：顺序存取方式、建立一个字符缓冲区&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii. in-control指令 &nbsp;&nbsp;③网络通信接口⑵软件/硬件接口 I/O设备的类型：⑴按使用特性：&nbsp;①存储设备：用以存储信息&nbsp;②I/O设备：&nbsp;&nbsp;&nbsp;&nbsp;I. 输入设备&nbsp;&nbsp;&nbsp;&nbsp;II. 输出设备&nbsp;&nbsp;&nbsp;&nbsp;III. 交互式设备⑵按传输速率：&nbsp;①低速设备：键盘、鼠标器&nbsp;②中速设备：行式打印机、激光打印机&nbsp;③高速设备：磁带机、磁盘机、光盘机 信号线类型：（设备与设备通信器的接口）&nbsp;①数据信号线：在设备和设备控制器之间传送数据信号&nbsp;②控制信号线：由设备控制器向i/o设备发送控制信号时的通路&nbsp;③状态信号线：传送指示设备当前状态的信号 ==设备控制器的主要功能：控制一个或多个I/O设备和计算机之间的数据交换== 设备控制器的基本功能：&nbsp;①接收和识别命令&nbsp;②数据交换：设置数据寄存器&nbsp;③标识和报告设备的状态&nbsp;④地址识别：识别所控制的每个设备的地址&nbsp;⑤数据缓冲区：暂存主机和I/O设备的数据&nbsp;⑥差错控制 设备控制器的组成：&nbsp;①设备控制器与处理机的接口&nbsp;②设备控制器与设备的接口&nbsp;③I/O逻辑 对I/O设备的控制：&nbsp;①利用特定的I/O指令：访问内存和访问设备指令不同&nbsp;②内存映像I/O I/O通道不同于一般处理机的地方：&nbsp;①指令类型单一&nbsp;②通道没有自己的内存 通道类型：⑴字节多路通道：按字节交叉方式工作⑵数组选择通道：按数组方式进行数据传送⑶数组多路通道：两者优点相结合 “瓶颈”问题：⑴原因：通道不足⑵解决方法：增加设备到主机间的通路而不增加通道 中断（外中断）：CPU对I/O设备发出的中断信号的一种响应陷入（内中断）：由CPU内部事件所引起的中断（如上下溢） 中断向量表：为每种设备配以相应的中断处理程序，中断号+人口地址中断优先级：对服务要求的紧急程度 对多中断源的处理方式：⑴屏蔽（禁止）中断：当处理机正在处理一个中断时，将屏蔽掉所有的中断⑵嵌套中断 &nbsp;&nbsp;规则：①CPU优先响应最高优先级的中断请求 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②高优先级的中断请求可以抢占正在运行的低优先级中断的处理机 中断处理程序的处理过程：&nbsp;&nbsp;①测定是否有未响应的中断信号&nbsp;②保护被中断进程的CPU进程&nbsp;③转入相应的设备处理程序&nbsp;④中断处理&nbsp;⑤恢复CPU的现场并退出中断 设备驱动程序的功能：⑴接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列⑵检查用户I/O请求的合法性，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式⑶发出I/O命令⑷及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理 设备驱动程序特点：⑴实现在与设备无关的软件和设备控制器之间通信和转换的程序⑵与设备控制器以及I/O设备的硬件特性紧密相关⑶与I/O设备所采用的I/O控制方式紧密相关⑷用汇编语言书写⑸允许可重入 设备处理方式（三种）：&nbsp;①为每一个设备设置一个进程&nbsp;②在整个系统设置一个I/O进程&nbsp;③不设置专门的设备处理进程 设备驱动程序的主要任务：启动指定设备，完成上层指定的I/O工作 设备驱动程序的处理过程：&nbsp;①将抽象要求转换为具体要求&nbsp;②对服务请求进行校验&nbsp;③检查设备的状态&nbsp;④传送必要的参数&nbsp;⑤启动I/O设备 对I/O设备的控制方式：⑴采用轮询的可编程的I/O方式：在处理机向控制器发出一条I/O指令，启动输入设备输入数据时，要同时把状态寄存器中的忙/闲标志busy置为1，然后便不断的循环测试busy（称为轮询）⑵采用中断的可编程I/O方式：当某进程要启动某个I/O设备工作时，便由CPU向相应的设备控制器发出一条I/O命令，然后立即返回继续执行原来的任务⑶直接存储器访问方式&nbsp;&nbsp;①特点：&nbsp;&nbsp;&nbsp;&nbsp;I. 数据传输的基本单位是数据块&nbsp;&nbsp;&nbsp;&nbsp;II. 所传送的数据是从设备直接送入内存的&nbsp;&nbsp;&nbsp;&nbsp;III. 仅在传送一个或多个数据块的开始和结束时才需CPU干预，整块数据的传送是在控制器的控制下完成的&nbsp;&nbsp;②DMA控制器的组成：&nbsp;&nbsp;&nbsp;&nbsp;I. 主机与DMA控制器的接口&nbsp;&nbsp;&nbsp;&nbsp;II. DMA控制器与块设备的接口&nbsp;&nbsp;&nbsp;&nbsp;III. I/O控制逻辑&nbsp;&nbsp;③四类寄存器：&nbsp;&nbsp;&nbsp;&nbsp;I. 命令/状态寄存器CR：接收从CPU发来的I/O命令&nbsp;&nbsp;&nbsp;&nbsp;II. 内存地址寄存器MAR：&nbsp;&nbsp;&nbsp;&nbsp;III. 数据寄存器DR：暂存数据&nbsp;&nbsp;&nbsp;&nbsp;IV. 数据计数器DC：存放本次CPU要读或写的字（节）数&nbsp;&nbsp;④DMA工作过程：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当CPU要从磁盘读入一数据块时，便向磁盘控制器发送一条读命令。该命令被送入命令寄存器CR中。同时，需要将本次要读入数据在内存的起始目标地址送入内存地址寄存器MAR中。将要读数据的字（节）数送入数据计数器DC中、还需将磁盘中的源地址直接送至DMA控制器的I/O控制逻辑上。然后，启动DMA控制器进行数据传送。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当DMA控制器已从磁盘中读入一个字的数据，并送入数据寄存器DR后，再挪用一个存储器周期，将该字传送到MAR所指示的内存单元中。然后便对DMA内容加1，将DC内容减1，若减1后DC内容不为0，表示传送未完，便继续传送那个下一个字（节）；否则，由DMA控制器发出中断请求⑷I/O通道控制方式 逻辑设备：抽象的设备名 I/O重定向：用于I/O操作的设备可以更换（重定向），而不必改变应用程序 逻辑设备表：将逻辑设备名称转换为某物理设备名称的功能 ==设备无关性：应用程序中所用的设备，不局限于使用某个具体的物理设备== 与设备无关的软件：（I/O系统的最高层软件）&nbsp;①设备驱动程序的统一接口：将抽象的设备名转换为具体的物理设备名&nbsp;②缓冲管理：缓和CPU和I/O设备之间的矛盾&nbsp;③差错控制：&nbsp;&nbsp;i. 暂时性错误：因发生暂时性事件引起的&nbsp;&nbsp;ii. 持久性错误：由持久性故障引起的&nbsp;④对独立设备的分配与回收：由系统来统一分配，不允许进程自行使用&nbsp;⑤独立于设备的逻辑数据块 设备控制表DCT：&nbsp;①设备队列队首指针&nbsp;②忙/闲标志&nbsp;③与设备连接的控制器表指针&nbsp;④重复执行次数 控制器控制表COCT：记录控制器情况通道控制表CHCT 系统设备表SDT：①设备类型 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②设备标识符 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③设备控制表 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④设备驱动程序的入口项 设备分配时应考虑的因素：⑴设备的固有属性（分配策略） &nbsp;&nbsp;①独占设备：由该进程独占 &nbsp;&nbsp;②共享设备：同时分配给多个进程使用 &nbsp;&nbsp;③虚拟设备：可共享⑵设备分配算法 &nbsp;&nbsp;①先来先服务：进程对某设备提出请求的先后次序 &nbsp;&nbsp;②优先级高者优先：优先级相同的，按先来先服务原则排队⑶设备分配中的安全性 &nbsp;&nbsp;①安全分配方式：CPU与I/O设备是顺序工作的 &nbsp;&nbsp;②不安全分配方式：一个进程可同时操作多个设备，使进程推进迅速 设备分配顺序：&nbsp;&nbsp;①分配设备&nbsp;&nbsp;②分配控制器&nbsp;&nbsp;③分配通道 逻辑设备表LUT：逻辑设备名、物理设备名、设备驱动程序的入口地址 逻辑设备表的设置方式：①整个系统只设置一张LUT &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②为每个用户设置一张LUT SPOOLing技术（假脱机技术）：在联机情况下实现的同时外围操作的技术 SPOOLing系统的组成：①输入井和输出井 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②输入缓冲区和输出缓冲区 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③输入进程和输出进程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④井管理程序 SPOOLing系统的特点：①提高了I/O的速度 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②将独占设备改造为共享设备 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③实现了虚拟设备功能 假脱机打印机系统：&nbsp;&nbsp;①磁盘缓冲区&nbsp;&nbsp;②打印缓冲区&nbsp;&nbsp;③假脱机管理进程和假脱机打印进程 引入缓冲区的原因：&nbsp;&nbsp;①缓和CPU与I/O设备间速度不匹配的矛盾&nbsp;&nbsp;②减少对CPU的中断频率，放宽对CPU中断响应时间的限制&nbsp;&nbsp;③解决数据粒度不匹配的问题&nbsp;&nbsp;④提高CPU和I/O设备之间的并行性 缓冲区管理：⑴单缓冲区：每当用户进程发出一I/O请求时，操作系统便在主存中为之分配一缓冲区⑵双缓冲区：在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区⑶环形缓冲区：多个缓冲区、多个指针 缓冲池：&nbsp;&nbsp;①空白缓存队列emq&nbsp;&nbsp;②输入队列inq&nbsp;&nbsp;③输出队列outq 缓冲区的工作方式：&nbsp;&nbsp;①收容输入&nbsp;&nbsp;②提取输入&nbsp;&nbsp;③收容输出&nbsp;&nbsp;④提取输出 改善磁盘系统的性能的途径：&nbsp;&nbsp;①选择好的磁盘调度算法，以减少磁盘的寻道时间&nbsp;&nbsp;②提高磁盘I/O速度，以提高对文件的访问速度&nbsp;&nbsp;③采取冗余技术，以提高系统的可靠性，建立高度可靠的文件系统 扇区字段：标识符字段、数据字段 磁盘类型：①固定头磁盘：每道磁道上有一读/写磁头，可访问所有各磁道，进行并行读写②移动头磁盘：每一个盘面仅配有一个磁头，磁头移动以进行寻道，串行读写 磁盘访问时间：⑴寻道时间Ts：启动磁臂的时间s与磁头移动n条磁道所花费的时间之和（Ts=m*n+s）⑵旋转延迟时间Tr：指定扇区移动到磁头下面所经历的时间⑶传输时间Tt：把数据从磁盘读出或向磁盘写入数据所经历的时间。 适当的集中数据传输将有利于提高传输效率 磁盘调度：（目标是使磁盘的平均寻道时间最少）⑴早期的磁盘调度算法：&nbsp;&nbsp;①先来先服务FCFS：根据进程请求访问磁盘的先后次序进行调度&nbsp;&nbsp;②最短寻道时间优先SSTF：其要求访问的磁道与当前磁头所在的磁道距离最近⑵基于扫描的磁盘调度算法：&nbsp;&nbsp;①扫描SCAN算法（电梯调度算法）：既考虑欲访问的磁道与当前磁道间的距离，优先考虑磁头当前的移动方向&nbsp;&nbsp;②循环扫描CSCAN算法：规定磁头单向移动，将最小磁道号紧接着最大磁道号构成循环，进行循环扫描&nbsp;&nbsp;③NStepSCAN算法：将磁盘请求队列分成若干个长度为N的子队列，按FCFS算法依次处理这些子队列，每处理一个队列时按SCAN算法&nbsp;&nbsp;④FSCAN算法：将磁盘请求队列分成两个子队列，一个由当前所有请求磁盘I/O的进程形成的队列，另一个是新出现的所有请求磁盘I/O的进程 磁臂粘着：进程反复请求对某一磁道的I/O操作，从而垄断了整个磁盘设备 数据组成：⑴数据项 &nbsp;&nbsp;①基本数据项（最小逻辑数据单位） &nbsp;&nbsp;②组合数据项（由若干个基本数据项组成）⑵记录（一组相关数据项的集合） &nbsp;&nbsp;关键字是唯一表示一个记录的数据项⑶文件（若干个记录组成） &nbsp;&nbsp;①文件类型 &nbsp;&nbsp;②文件长度 &nbsp;&nbsp;③文件的物理位置 &nbsp;&nbsp;④文件的建立时间 文件类型：⑴按性质用途： &nbsp;&nbsp;①系统文件 &nbsp;&nbsp;②用户文件 &nbsp;&nbsp;③库文件⑵按文件中数据的形式分类 &nbsp;&nbsp;①源文件 &nbsp;&nbsp;②目标文件 &nbsp;&nbsp;③可执行文件⑶按存取控制属性分类 &nbsp;&nbsp;①只执行文件 &nbsp;&nbsp;②只读文件 &nbsp;&nbsp;③读写文件⑷按组织形式和处理方式分类 &nbsp;&nbsp;①普通文件 &nbsp;&nbsp;②目录文件 &nbsp;&nbsp;③特殊文件 文件系统的层次结构⑴对象及其属性：&nbsp;&nbsp;①文件&nbsp;&nbsp;②目录&nbsp;&nbsp;③磁盘（磁带）存储空间⑵对对象操纵和管理的软件集合 &nbsp;&nbsp;①I/O控制层 &nbsp;&nbsp;②基本文件系统层 &nbsp;&nbsp;③基本I/O管理程序 &nbsp;&nbsp;④逻辑文件系统⑶文件系统的接口 &nbsp;&nbsp;①命令接口 &nbsp;&nbsp;②程序接口 文件操作：&nbsp;&nbsp;①最基本的文件操作：创建文件、删除文件、读文件、写文件、设置文件的读/写位置&nbsp;&nbsp;②文件的“打开”和“关闭”操作&nbsp;&nbsp;③其他文件操作 文件逻辑结构的类型：⑴按文件是否有结构分类 &nbsp;&nbsp;①有结构文件：定长记录、变长记录 &nbsp;&nbsp;②无结构文件⑵按文件的组织方式分类 &nbsp;&nbsp;①顺序文件&nbsp;&nbsp;&nbsp;&nbsp;I. 串结构&nbsp;&nbsp;&nbsp;&nbsp;II. 顺序结构 &nbsp;&nbsp;②索引文件 &nbsp;&nbsp;③索引顺序文件 记录寻址：&nbsp;&nbsp;①隐式寻址方式&nbsp;&nbsp;②显式寻址方式&nbsp;&nbsp;&nbsp;&nbsp;I. 通过文件中记录的位置&nbsp;&nbsp;&nbsp;&nbsp;II. 利用关键字 对目录管理的要求：&nbsp;&nbsp;①实现“按名存取”&nbsp;&nbsp;②提高对目录的检索速度&nbsp;&nbsp;③文件共享&nbsp;&nbsp;④允许文件重名 文件控制块FCB：⑴基本信息类：&nbsp;&nbsp;①文件名&nbsp;&nbsp;②文件物理位置&nbsp;&nbsp;③文件逻辑结构 &nbsp;&nbsp;④文件的物理结构⑵存取控制信息类：&nbsp;&nbsp;①文件主的存取权限&nbsp;&nbsp;②核准用户的存取权限&nbsp;&nbsp;③一般用户的存取权限⑶使用信息类&nbsp;&nbsp;①文件的建立日期和时间&nbsp;&nbsp;②文件上一次修改的日期和时间&nbsp;&nbsp;③当前使用信息 索引结点：⑴磁盘索引结点：&nbsp;&nbsp;①文件主标识符&nbsp;&nbsp;②文件类型&nbsp;&nbsp;③文件存取权限 &nbsp;&nbsp;④文件物理地址 &nbsp;&nbsp;⑤文件长度 &nbsp;&nbsp;⑥文件连接计数 &nbsp;&nbsp;⑦文件存取时间⑵内存索引：&nbsp;&nbsp;①索引结点编号&nbsp;&nbsp;②状态&nbsp;&nbsp;③访问计数&nbsp;&nbsp;&nbsp;&nbsp;I. 文件所属文件系统的逻辑设备号&nbsp;&nbsp;&nbsp;&nbsp;II. 链接指针]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管理信息系统]]></title>
    <url>%2F2017%2F03%2F05%2F%E7%AE%A1%E7%90%86%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[信息系统是怎么改变企业的？—企业寻求快速感知和响应客户需求变化，实现更高的运营效率技术领域三大变化：移动数字平台的出现、“大数据”商业应用的出现，“云计算”的发展业务流程：组织按照时间顺序开发的逻辑上相关的一系列任务和行动，以产生特定的业务结果以及组织与协调业务活动的特定方式。 信息系统是怎么构建企业业务战略目标的实现 ？—-实现六项战略业务目标：卓越经营，新产品、新服务和新商业模式，与客户和供应商的密切关系，改善决策，竞争优势，生存（满足挑战要求） 劳顿教授的创新，从三个维度分析信息系统？—-信息系统有管理（分析理解组织所面临的各种情境、做出决策并制定行动方案解决）和组织（人员、组织结构、业务流程、规章制度和企业文化）、信息技术（计算机软件硬件、数据管理技术、网络和通信技术）维度互补性资产：确保基本投资获得价值的资产。 善于用现代方法看待信息系统？—–技术方法、行为方法小节熟 在业务流程基础上，了解信息系统都有什么类型？信息系统能完成自动化、改变信息流、消除延误事务处理系统TPS（transaction processing system），计算化的系统，用以执行和记录企业日常性的业务管理信息系统MIS（management information system）为中层管理人员提供关于组织当前运行情况的报告决策支持系统DSS（decision-support system），关注独特且快速变化的问题经理支持系统ESS（executive support system），帮助高层管理者作出决策，需要判断、评估和洞察力的非程序化的决策 电子企务：针对企业内部的信息化建设电子商业：企业应用数字技术和互联网来执行主要的业务流程电子商务：电子商业中涉及通过互联网买卖商品及服务的部分电子政务：应用互联网和计算机网络技术，使各政府部门和公共服务机构与市民、企业及其他政府分支机构之间的关系数字化。信息系统部门：程序员（编写计算机软件指令）、系统分析员（将业务问题和需求转换为信息和系统需求）、信息系统经理（团队领导者管理者）、信息主管CIO（全面负责企业信息技术应用的高级管理者）、安全主管CSO（确保企业信息系统安全和信息安全）、隐私主管CPO（确保企业行为符合现有数据隐私法律）、知识主管CKO（负责企业知识管理项目）、终端用户（信息系统部门外的企业各部门人员） 组织：一个稳定的、正式的社会结构，从环境中获取资源并进行处理，然后输出产品。正规法律实体，内部规则程序遵守法律法规。一段时间内经由冲突与解决冲突而形成的一系列权利、特权、义务和责任的平衡体。专业化的层级状官僚机构，有明确的劳动分工组织特性：工作规范和业务流程、组织政治、组织文化、组织环境、组织结构、组织的其他特征（目标、服务对象、领导形式、执行任务、使用技术） 组织跟信息系统有什么关系？——互相影响。信息系统是为让企业获利，但要从新技术获利，组织必须知道并接受信息系统带来的影响（经济、组织和行为）迈克尔·波特的竞争力模型：传统的竞争者、市场新进入者、替代性的产品和服务、客户、供应商 信息系统怎样帮助企业提升竞争力？—-低产品领先，产品差异化，聚焦细分市场，加强与客户和供应商的亲密关系企业的价值链模型：主要活动（为客户创造价值的、与企业产品和服务的生产和分销最直接相关的活动）支持活动（为支持、辅助主要活动而开展的活动）。企业活动能增加企业产品和服务的边际价值小节熟 第四章了解 IT（信息技术）基础设施：1、为企业特定的信息系统应用提供平台的共享技术资源。2、运营整个企业所必需的物理设备和应用软件的集合，也是由管理层预算所决定的人和技术能力的服务集合。 信息技术基础发展经历哪几个阶段？1、 通用主机及小型计算机阶段（1959年至今）2、 个人计算机阶段（1981年至今）3、 客户机/服务器阶段（1983年至今）4、 企业计算阶段（1992年至今）5、 云计算及移动计算阶段（2000年至今） 掌握摩尔定律？—摩尔定律：在芯片的最小单元元件（晶体管）的生产成本不变的情况下，一块芯片上集成的元件数量每年翻一番，后来把芯片处理速率的增长修订为每两年翻一番–别人的解读：微处理器的处理能力每18个月翻一番。计算机的计算能力每18个月翻一番。计算成本每18个月下降一半大规模数字存储定律：数字信息的总量差不多每年翻一番梅卡尔夫定律：网络的价值或能力会随着网络中成员数量的增加而呈指数级增长IT（信息技术）基础设施组成部分：计算机硬件平台、操作系统平台、企业软件平台、网络和通信平台、数据库管理软件、互联网平台及咨询服务和系统集成云计算：资源可以按需提供的方式从任何连接的设备和位置来访问自主计算：一种能够自我配置、优化和调整的系统，当系统损坏时能够自我恢复，并能够保护自身不受外界入侵或者自损网格计算：把分散在不同地理位置的计算机连接在一个单独的网络中，将网格中所有的计算机的计算能力组合在一起，组织成一台虚拟的超级计算机虚拟化：提供一套不受物理配置和地理位置限制且能够访问的计算资源开放源代码软件（开源软件）：免费并可以被用户修改的软件。小节熟 数据管理最有效方法：数据库掌握数据库的分析和设计—-提供数据管理水平：建立一个基于新的硬件和软件系统的公司级数据库，以支持一系列更有效率的业务应用需求数据仓库：一个数据库，存储着决策者认为有潜在价值的、当前的和历史的公司数据数据集市：数据仓库的一个子集，里面有企业数据的汇总或高度聚集了部分的企业数据，是为特定用户建立的单独的数据库。数据挖掘：以发现导致问题的原因为驱动力，通过大型数据库发现隐藏的模式和关系，并从中推断规则，用以预测未来行为。小节熟 计算机网络按内外分有哪几种类型？？—局域网、（校园网）、城域网、广域网 计算机网络连接有哪些介质？—-双绞线、同轴电缆、光纤电缆、无线传输介质 系统有哪些漏洞？—系统容易受到破坏，恶意软件（病毒、蠕虫、特洛伊木马、间谍软件），黑客与计算机犯罪、员工的内部威胁、软件漏洞 系统为什么被滥用？—-无解计算机病毒：一种通常在用户不知情和认可的情况下，附着在其他软件程序或者数据文件上执行的欺诈软件程序蠕虫：一种独立的计算机程序，可以在网络上将自己从一台计算机拷贝到另一台计算机。黑客：妄图非授权访问计算机系统的个人骇客：形容具有犯罪意图的黑客计算机犯罪：DoS攻击、植入病毒、盗用服务和扰乱计算机系统。电子欺骗（欺骗网站）、拒绝服务攻击（网络崩溃）、身份盗用（网络钓鱼、嫁接）、点击欺诈、网络恐怖主义和网络战 信息系统安全与控制有什么商业价值？—不仅保护公司的信息资产，还要保护客户、员工和合作伙伴的信息—拥有良好的安全与控制系统以保护企业信息资产，因而能够产生较高的投资回报。—强有力的安全与控制措施还能提高员工的工作效率，降低运营成本小节熟 企业应用系统？企业系统：由一套集成的软件模块和一个中央数据库组成，也称为企业资源计划ERP企业软件（定义及来源）：选择希望实现的系统功能，修改系统操作，实现信息与流程的集成 掌握供应链管理系统？—供应链：由组织和业务流程组成的网络，从原材料开始，半成品（配件、零件），成品—供应链规划系统：模拟公司目前的供应链，生成产品的需求预测，制定最佳的采购和生产计划—供应链执行系统：负责管理分销中心和仓库的物流，保证以最高效的方式将产品送到正确的地点–基于推动和基于拉动的供应链模型 掌握客户关系管理系统？–从公司各处收集和集成客户的数据，整合、分析数据，将结果传递到企业各个系统以及与客户有接触的地方。软件交换信息、共享潜在客户数据的能力–特征：销售团队自动化（集中于最赚钱的客户）、客户服务（提供客户信息和服务工具）、市场营销（营销活动建议）、交叉销售（推销辅助产品） 小节熟 电子商务：1、 利用互联网和网站进行商务交易2、 组织和个人之间以数字化形式进行的商务交易 电子商务有几种类型？（按参与者、实用者分类）电子商务有什么特征？和传统商务有什么不同？—-B2C:企业向个体购物者出售产品及服务B2B:企业之间的产品及服务销售C2C:消费者个体之间直接的买卖—-移动商务：使用便捷式设备随处购买商品及服务的方式—-提供更为灵活和更低成本的方式—-商业模式和新兴信息技术的巧妙结合—-特性：无所不在，全球化、统一标准、丰富性、交互性、信息密度、个性化/定制化、社交技术：用户内容好创建和社交网络 电子商务有哪些商业模式？有哪些营利模式？—门户网站（向广告商收取费用）、网络零售商（在线零售商店）、内容提供商（具有知识产权的表现方式）、交易代理商（为消费者处理交易）、标识创建者（展示商品、购买商品的平台）、服务提供商（在线提供服务）、社区提供商（提供数字化环境）—广告、销售、订阅、免费/免费增值、交易费、合作数字市场：互联网创建的，人们可以直接地、实时地、免费地交换大量信息数字化产品：可以通过数字化网络交付的商品小节熟 系统地掌握什么叫数据、信息、知识、智慧？–数据：被组织系统获取的一系列事件或交易，有用性较小–信息：企业投入资源把数据按理解的类别分类，如销售额报告等–知识：企业再投入额外的资源，发现知识工作的模式、规则、脉络-（隐性显性知识）–智慧：集体和个人应用知识去解决实际问题的经验 掌握知识管理的价值链：知识获取—知识储存—知识传播—知识应用—创造组织和管理资本：合作、实践社区和虚拟办公环境知识管理系统：企业知识管理系统、知识工作系统、智能技术（了解就行）企业级知识管理系统：收集、储存、传播和使用数字化的内容和知识。可查询结构化和非结构化的信息，帮助企业识别内部员工和专家。（企业内容管理系统和知识网络系统）。企业外部的知识资源易于访问外部公开的网站，用关键字标注（社会化书签）。管理、提交、跟踪和评估员工学习和培训效果（学习管理系统）知识工作系统：高度定制化的专用知识工作系统，提高工作者工作效率。实例：计算机辅助设计、虚拟现实系统、增强现实智能技术：使组织获取个人知识和集体知识，扩展组织的知识库小节熟（除智能技术） 非结构化决策：新颖的、重要的、非常规性的。决策者必须对问题进行判断、评价和洞察，从而解决问题的一类决策结构化决策：重复的、例行的。遵循一个明确的程序处理。半结构化决策：同时具备。只有其中一部分能由商定的程序给定明确的答案 决策经历哪些过程？–情报（发现、识别和理解组织问题）–设计（识别和探讨问题的各种解决方案）–选择（在各种解决方案中进行选择，确定较好的方案）–实现（选择方案，并继续监测此方案的效果）商务智能：存储、集成、报告和分析来自商业环境中数据的基础架构。手机、储存、清洗和提供相关信息给管理人员 商务智能主题（组成）？–以便管理人员作出更好的决策、规划–较低层的运行管理、中层管理人员，高级管理人员群体决策支持系统GDSS：以计算机为基础的交互式系统，为一组工作在同一地点或不同地点的决策者提供决策支持，促进其解决非结构化问题 信息系统建设，涉及各个阶段？（图略） 信息系统的开发有哪些类型？用的什么方法？运用什么工具？什么模型？（略） 系统分析、系统设计，信息实施？编程？测试？切换？（图略） 小节熟（至少50分） 项目：为了完成特定企业目标而规划的一系列相关活动项目管理：在一定的预算和时间限制下，运用知识、技能、工具和技术实现特定的目标风险：影响成功的潜在因素（增加时间、成本，降低项目输出质量，阻碍项目完成） 有什么有效措施防范风险？—管理技术复杂性（预见问题，理顺工作关系，召开团体会议）：内部集成工具—正式的计划和控制工具（甘特图、计划评审图）—增加用户参与，克服用户抵触：外部集成工具 wyn]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构笔记]]></title>
    <url>%2F2017%2F03%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据、数据元素、数据项、数据对象、逻辑结构、存储结构（顺序、链表） 抽象数据类型：数据对象、数据关系、基本操作 Status是函数返回值类型，其值是函数结果状态代码 Typedef是描述存储结构，elemtype定义数据元素类型 New delete动态分配释放内存空间 交换赋值：变量名12 异常结束语句 exit（异常代码） C++输入输出：12cin&gt;&gt; &gt;&gt; ; cout&lt;&lt; &lt;&lt; ; 算法特性：有穷性、确定性、可行性、输入、输出算法优劣评价：正确性、可读性、健壮性、高效性问题规模：算法求解问题输入量的多少，n越大算法执行时间越长（语句频度之和） 语句频度：一条语句重复执行次数 分析算法复杂度：找出所有语句中语句频度最大的那条语句作为基本语句，计算基本语句的频度得到问题规模n的某个函数fn，取数量级O（最深层循环决定）语句频度为某个常数：算法执行时间不随问题规模n的增加而增长 随数量级递增：常数阶，对数阶，线性阶，线性对数阶（nlog2n），平方阶，立方阶，k次方阶，指数阶随n增大，Tn增长慢的为最优算法 原地工作（算法）：算法执行时所需要的辅助空间相对于输入数据量而言是个常数 算法的时间复杂度取决于问题规模和待处理数据的初态。 线性结构的基本特点：除第一个元素无直接前驱，最后一个元素无直接后继，其他每个数据元素都有一个前驱和后继 一个数据元素可以包含若干个数据项 线性表：由n个数据特性相同的元素构成的有限序列线性表的相邻元素之间是一对一的序偶关系 初始化：initlist 销毁：destroy 置空表：clearlist 判空表：Listempty 求表长：listlength 取第i个元素：Getelem 查找元素：locateelem 前驱（后继）Priorelem/nextelem 插入元素：Listinsert 删除元素：Listdelete 遍历表：Traverselist 顺序表：用顺序映像（用一组地址连续的存储单元依次存储线性表的数据元素）的线性表 存储位置：LOC（ai）=LOC（1）+（i-1）l（每个元素占据l单元，a（1）为线性表的起始地置或基地址） 随机存取的存储结构只要确定了存储线性表的起始位置，线性表的任一数据元素都可随机存取 注意区分元素位置区号和下标位置的对应关系 通过length的值判断是否为空 动态分配线性表的存储区域可以更有效地利用系统的资源123ASL=（n+1）/2Eins=n/2Edel=（n-1）/2 数组的静态特性：长度相对固定 链表的存储映像（结点）： 数据域（存储数据元素信息） 指针域（存储直接后继存储位置，指针或链） 线性链表（单链表）链表的每个结点中只包含一个指针域 整个链表的存取必须从头指针开始进行，头指针指2. 示链表中的第一个结点（首元结点）的存储位置。单链表最后一个结点的指针为空 单链表可由头指针唯一确定，c中的结构指针。单链表可用头指针名字命名 首元结点：链表中存储第一个数据元素a1的结点头结点：在首元结点前附设的一个结点，其指针域指向首元结点。数据域可以不存储任何信息，也可以存储 头指针：指向链表中第一个结点的指针（有头指头，无头指首元） 链表增加头结点作用：便于首元结点的使用，便于空表与非空表的统一处理 顺序存取的存取结构：要取得第i个数据元素必须从头指针出发顺链进行寻找 123456单链表ASL=（n-1）/2 插入：s-&gt;next=p-&gt;next;p-&gt;next=s; 要在i个结点前插入新结点，需找到i-1，所以on 删除：p-&gt;next=p-&gt;next-&gt;next； 合法插入位置n+1个，合法删除位置n个 链表是动态结构，空间不需预先分配划定，由系统按需即时生成 前插法：将新结点逐个插入链表的头部（头结点后）来创建链表 后插法：将新结点逐个插入链表的尾部来创建链表。为了使新结点能够插入表尾，需要增加一个尾指针r指向链表的尾结点。 循环链表特点：表中最后一个结点的指针域指向头结点 指向表尾结点的终止条件： 单链表（p/p-&gt;next!=null） 循环链表（p/p-&gt;next!=l） 合并两个线性表：头尾相指，释放第二个表的头结点1234&#123; p=B-&gt;next（头）-&gt;next; B-&gt;next=A-&gt;next（头）; A-&gt;next=p; &#125; 在单链表中，查找直接后继结点执行时间为o1，而前驱为on 双向链表通常采用带头结点的循环链表形式 只要是删除，需要判断是否为空 只要是静态存储，需要判断是否满 存储密度：数据元素本身所占用的存储量和整个结点结构所占用的存储量之比 存储密度大，存储空间利用率高 顺序表适用：表长变化不大，且能事先确定变化范围。很少插入删除，经常按元素位置序号访问数据元素。 链表适用：长度变化极大，频繁进行插入删除 栈是限定仅在表尾进行插入或删除操作的线性表，后进先出 栈顶：表尾端 栈底：表头端 队列：先进先出的线性表 队尾：允许插入的一端 队头：允许删除的一端 栈和队列是限定性的数据结构 插入操作：入栈、入队 删除操作：出栈、出队 求栈长：stacklength 求栈顶元素：gettop 插入：push 删除：pop 遍历：stacktraverse 顺序栈：利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈的位置 空栈：top和base的值相等 当Base=NULL，则栈结构不存在 Top初值指向栈底，栈非空时，始终指向栈顶元素的上一位置 Stacksize指示栈课使用的最大容量 存储分配失败：12345&#123; xx=new yy； if(！xx) exit(overflow)；&#125; 入栈出栈需判栈空栈满 链栈：以链表的头部作为栈顶 入链栈不需要判栈空，出链栈要判栈满 递归：在定义的内部直接或间接出现定义本身“分治法”：分解-求解的策略 迭代法：迭代地展开递归方程的右端，使之成为一个非递归的和式，再估计 链表是一种递归的数据结构 求队头元素：gethead 插入：enqueue 删除：dequeue 顺序队列：利用一组地址连续的存储单元依次存放从队列头到队列尾的元素，附设两个整型变量front和rear（指示队列头尾元素的位置，即头尾指针） 空队列：front=rear=0； 插入新的队列尾元素：rear+1 删除队列头元素：front+1 头指针始终指向队列头元素，尾指针指向队列尾元素的下一位置 假溢出：因数组越界而导致程序的非法操作错误解决假溢出：循环队列（需要模运算），该队列出栈不用释放空间，凡是涉及队头队尾指针修改的都要将其对MAXSIZE求模 区别队满队空：少用一个元素空间、另设一个标志位 队空：Q.front=Q.rear; 队满：(Q.rear+1)%MAXSIZE==Q.front 队列长度：头尾指针差值（非循环队列），123(Q.rear-Q.front+MAXSIZE)%MAXSIZE（循环队列） e=Q.base[Q.front] //用e返回队头元素 链队被添加一个头结点，并令头指针始终指向头结点 初始化：构造一个只有一个头结点的空队 链队出队：队列最后一个元素被删，队列尾指针丢失，需对队尾指针重新赋值（指向头结点） 递归程序占用内存空间较多，运行效率较低 树以分支关系定义的层次结构，有且仅有一个称为根的结点，其余m个子树互不相交 结点：树的独立单元 结点的度：结点拥有的子树数 树的度：树内各结点度的最大值 叶子结点（终端结点）：度为零的结点 分支结点（非终端结点）：度不为零的结点 内部结点：除根节点外的分支结点 祖先：从根到该结点所经分支上的所有结点 子孙：以某结点为根的子树中的任一结点 堂兄弟：双亲在同一层的结点 树的深度（高度）：树中结点的最大层次 有序树：树中结点的各子树从左至右是有次序的（不能互换）。最左边的子树的根称为第一个孩子，最右边称为最后一个孩子 森林：m棵互不相交的树的集合 二叉树每个结点至多只有两棵子树（不存在度大于2的结点），子树有左右之分（次序不能任意颠倒），有5种基本形态 求根：root 求结点值：value 赋值结点：assign 求双亲：parent 求左右孩子：leftchild/rightchild 求左右兄弟：leftsibling/rightsibling 插入子树：insertchild 先序遍历：preordertraverse 中序遍历：inordertraverse 后序遍历：postordertraverse 层次遍历：levelordertraverse 二叉树性质： 在二叉树的第i层上至多有2^（i-1）个结点（i）=1） 深度为k的二叉树至多有2^k-1个结点（k）=1） 对任何一棵二叉树T，终端结点n0，度为2的结点n2，则n0=n2+1 具有n个结点的完全二叉树的深度为[log2n]+1（向下取整） 双亲[i=2],（向下取整），左孩子2i，右孩子2i+1 满二叉树：深度为k且含有2^k-1个结点的二叉树，每一层的结点数都是最大结点数 完全二叉树：每个结点与满二叉树编号（自上而下，自左而右）一一对应。叶子结点只在层次最大的两层出现，右子孙层次l，则左子孙层次l或l+1 顺序存储结构仅适用于完全二叉树（从根起按层序存储），0表示不存在该结点 二叉链表：数据域和左、右指针域 三叉链表：数据域和左、右指针域，以及指向其双亲结点的指针域 在含有n个结点的二叉链表中有n+1个空链域查找双亲时，在二叉链表中需从根指针出发巡查链式存储是二叉树常用的存储结构 线索二叉树在第一次遍历时将结点的前驱、后继信息存储下来，便于再次遍历二叉树 遍历二叉树：按某条搜索路径巡访树中各个结点，使得每个结点均被访问一次，而且仅被访问一次（二叉树最基本操作） 遍历实质：对二叉树进行线性化过程（结点排成线性序列） 先序遍历：根，左，右 中序遍历：左，根，右 后序遍历：左，右，根 遍历时间空间复杂度均为on 由先序和中序序列，或由后序和中序序列均能唯一地确定一棵二叉树 复制二叉树（类似先序遍历过程）：利用已有的一棵二叉树复制得到另外一棵与其完全相同的二叉树二叉树深度（计算过程类似后序遍历）：树中结点的最大层次，左右子树深度较大者加1 二叉树结点个数：空树则为0，否则为左子树加右子树加1 遍历二叉树：以一定规则将二叉树中的结点排列成一个线性序列 为避免混淆，则改变结点结构，增加两个标志域 LTag：指示结点的左孩子（0），指示结点的前驱（1） RTag：指示结点的右孩子（0），指示结点的后继（1） 线索：指向结点前驱和后继的指针 线索二叉树：加上线索的二叉树 线索化：对二叉树以某种次序遍历使其变为线索二叉树的过程 线索链表：实线为指针（指向左、右子树），虚线为线索（指向前驱、后继），且第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点线索二叉树构造的实质：将二叉链表中的空指针改为指向前驱或后继的线索 为记录遍历过程访问结点的先后关系，附设一个指针pre始终指向刚刚访问过的结点，而指针p指向当前访问的结点 中序线索二叉树： LTag=1，左链指向前驱，右链指向后继 LTag=0，前驱是左子树中最右下的结点，后继是遍历其右子树时访问的第一个结点 在先序线索化树找前驱或在后序线索化树上找后继比较复杂，直接建立4个指针的线索链表 树的存储结构 双亲表示法：以一组连续的存储单元存储树的结点，除数据域data，附设parent域用以指示其双亲结点的位置。但求结点的孩子需要遍历整个结构 孩子表示法：多重链表（每个结点有多个指针域），每个指针指向一棵子树的根结点 同构：空间浪费，在一棵有n个结点度为k的树中必有n(k-1)+1个空链域 不同构：操作不方便 孩子链表：把每个结点的孩子结点排列，以单链表做存储结构。头指针组成线性表，用顺序存储结构孩子兄弟法（二叉树表示法、二叉链表表示法）：链表中结点的两个链域分别指向该结点的第一个孩子结点（firstchild）和下一个兄弟结点（nextsibling）优点：和二叉树的二叉链表完全一样，便于将一般的树结构转换为二叉树 任何一棵树都能通过孩子兄弟表示法转换为二叉树进行存储 任何一棵和树对应的二叉树，其根结点的右子树必空(利用二叉链表存储树时，右指针指向兄弟结点) 树转换成二叉树：将结点的长子变成其左孩子，右兄弟变成其右孩子 森林转换成二叉树：每一棵树变成二叉树，后将各根结点视为兄弟连在一起 二叉树转换成森林：左孩子变为长子，右孩子变为右兄弟 树的遍历：先根遍历（根结点，子树），后根遍历（子树，根结点） 引入二叉线索树的目的是加快查找结点前驱或后继的速度 交换其所有分支结点左、右子树的位置，利用后序遍历方法最合适。 一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树只有一个叶子结点 在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关 图G由V（顶点集）和E（边集）。E（G）可以为空，则图G只有顶点没有边 有向图（有向边的集合）中，顶点对&lt;x,y&gt;是有序的边或弧，x是有向边的始点或弧尾，y是有向边的终点或弧头 无向图（无向边的集合）中，（x,y）是无序的一条边 子图：边集合和点集合的子集构成的图 无向完全图：具有n（n-1）/2条边 有向完全图：具有n（n-1）条弧 稀疏图：有很少条弧或边的图 稠密图：有很多条弧或边的图 权：每条边标上具有某种含义的数值，表示距离或耗费 网：带权的图 邻接点：v1和v2在一条线上，互为邻接点 度TD（v）：和v相关联的边的数目，度等于入度加出度数 入度ID(v)：以顶点v为头的弧的数目 出度OD(v)：以顶点v为尾的弧的数目 路径长度：一条路径上经过的边或弧的数目 回路（环）：第一个顶点和最后一个顶点相同的路径 简单路径：序列中顶点不重复出现的路径 简单回路（环）：除第一个和最后一个顶点外 其余顶点不重复出现的回路 连通：v到v1有路径，连通 连通图：任意两个顶点都连通，无向图G为连通图 连通分量：无向图中的极大连通子图（连通子图个数） 强连通图：任意两个顶点都存在路径，有向图G为连通图 强连通分量：有向图中的极大强连通子图（连通子图个数） 连通树的生成树：一个极小的连通子图，含有图中全部顶点，但只有足以构成一棵树的n-1条边 如果一个图有n个顶点和小于n-1条边，则是非连通图。如果多于，则一定是环 有n-1条边的图不一定是生成树 有向树：有一个顶点的入度为0，其余顶点的入度均为1的有向图 构造图：creategraph 返回顶点位置：locatevex 返回顶点值：getvex 对顶点赋值：putvex 返回第一个邻接顶点：firstadjvex 返回下一个邻接顶点：nextadjvex 增加新顶点：insertvex 增加弧：insertarc 深度优先遍历：DFSTraverse 广度优先遍历：BFSTraverse 生成森林：由若干个有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧 邻接矩阵：表示顶点之间相邻关系的矩阵 图：若属于集合，则Aij=1，否则Aij=0 网：若属于集合，则Aij=w（权值），否则Aij=∞（计算机允许的、大于所有边上权值的数） 邻接矩阵表示图：一个用于存储邻接矩阵的二维数组，还有一个一维数组存储顶点信息 优点：便于判断两个顶点之间是否有边，便于计算各个顶点的度（无向图是第i行元素之和，有向图第i行元素之和为出度，第i列元素之和为入度） 缺点：不便于增加和删除结点，不便于统计边的数目（需扫描全部元素），空间复杂度高（稀疏图浪费空间） 压缩存储：仅存储下三角（上三角）的元素 邻接表：对图中每个顶点建立一个单链表，把邻接的顶点放入链表。单链表的第一个结点存放有关顶点的信息，其余结点存放边的信息。（表头节点表、边表） 表头结点表：顺序存储，数据域（用于存储顶点的名称或其他有关信息），链域（指向链表中第一个结点，即与顶点邻接的第一个邻接点） 边表：由2n个边链表组成，邻接点域（指示与顶点邻接的点在图中的位置），数据域（存储和边相关的信息，如权值），链域（指示与顶点邻接的下一条边的结点） 在无向表的邻接表，顶点的度恰为第i个链表中的结点数。而在有向图仅为顶点的出度 逆邻接表：邻接表记录顶点的入边，称入边表 优点：便于增加和删除顶点，便于统计边的数目，空间效率高（空间复杂度o（n+e）），适合稀疏图 缺点：不便于判断顶点之间是否有边，不便于计算有向图各个顶点的度 十字链表：结合有向图的邻接表和逆邻接表 在十字链表中，每一条弧有一个结点，对应于每个顶点也有一个结点 弧结点：尾域tailvex和头域headvex分别指示弧尾和弧头在图中的位置，链域hlink指向弧头相同的下一条弧，链域tlink指向弧尾相同的下一条弧，info域指向该弧的相关信息 弧头或弧尾相同的在同一链表上 头结点（顶点结点）：data域存储和顶点相关的信息，链域firstin和firstout分别指向以该顶点为弧头或弧尾的第一个弧结点 邻接多重表：每一条边用一个结点表示，每一个顶点也用一个结点表示 边结点：mark标志域可用以标记该条边是否被搜索过，ivex和jvex为该边依附的两个顶点在图中的位置，ilink指向下一条依附于顶点ivex的边，jlink指向下一条依附于jvex的边，info为指向和边相关的各种信息的指针域 头结点（顶点结点）：data域存储和该顶点相关的信息，firstedge域指示第一条依附于该顶点的边。 在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，则每个边结点同时链接在两个链表中 深度优先搜索：类似树的先序遍历，栈。从某个顶点出发，顺着第一个未被访问的邻接点，返回前一个访问过但有未被访问的邻接点，直至都被访问，结束。时间复杂度on^2（邻接矩阵），oe（邻接表） 广度优先搜索：类似树的层次遍历，队列。从顶点出发，依次访问各个未曾访问过的邻接点，再从邻接点出发访问邻接点，先被访问过的先于后被访问过的 最小代价生成树（最小生成树）：在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树 普里姆算法：找出一条权值最小的边并入集合。适合构造稠密网的最小生成树，时间复杂度on^2 加点法：逐步增加集合中的顶点 克鲁斯卡尔算法：选择权值最小的边，若该边依附的顶点落在集合中不同的连通分量上，则将此边加入集合，否则舍去，选择另一条。直至集合所有顶点都在同一连通分量上。适合构造稀疏网的最小生成树，时间复杂度oelog2e 加边法：逐步增加生成树的边 带权有向网，路径第一个顶点为源点，最后一个顶点为终点 求从某个源点到其余各顶点的最短路径：迪杰斯特拉算法（按路径长度递增的次序产生最短路径），时间复杂度on^2 求每一对顶点之间的最短路径：弗洛伊德算法（求每一对顶点之间的最短路径） 查找表：由同一类型的数据元素（或记录）构成的集合（一种非常灵便的数据结构） 关键字：数据元素（或记录）中某个数据项的值，可以标识。若唯一，则为主关键字。若识别若干，则为次关键字。当数据元素只有一个数据项，其关键字为该数据元素的值 查找：根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素 动态查找表：在查找的同时进行修改。查找成功返回，否则插入关键字等于给定值记录 可以用平均查找长度来衡量查找算法的性能 顺序查找：从表的一端开始，依次将记录的关键字和给定值进行比较，若相等则查找成功；反之若扫描整个表仍未找到，则查找失败（时间复杂度on） 优点：算法简单，对表结构无要求（顺序、链式） 缺点：平均查找长度较大，查找效率较低 通过设置监视哨，免去查找过程中每一步都要检测整个表是否查找完毕 折半查找（二分查找）：从表的中间记录开始，如果给定值和中间记录的关键字相等，则查找成功；如果大于或小于，则在表中大于或小于中间记录的那一半中查找，重复操作直至成功，或者在某一步中查找区间为空，则查找失败。要求顺序存储结构有序表，表中关键字按关键字有序排列（时间复杂度olog2n） 折半查找的判定树：树中每一结点对应表中一个记录，结点值是记录在表中的位置序号。把当前查找区间的中间位置作为根，左右子表分别作为左右子树。 成功的折半查找恰好是走了一条判定树的根到被查结点的路径，经历比较的关键字个数恰为该结点在树中的层次 查找成功时进行比较的关键字个数最多不超过树的深度，至多（log2n）+1[向下取整] 优点：比较次数少，查找效率高 折半查找不适用与数据元素经常变动的线性表分块查找（索引顺序查找）：建立索引表，对每个子表（块）建立一个索引项（关键字项、指针项）。先确定待查记录所在的块（子表），然后在块中顺序查找。 索引表按关键字有序（有序或分块有序） 分块有序：第i个子表所有记录的关键字均大于第i-1个子表中的最大关键字 确定块可用顺序或折半查找，在块中只能顺序 优点：又快速查找又经常动态变化 缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算 线性表的查找更适用于静态查找表 二叉排序树：若左右子树不空，左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值，其左右子树也分别为二叉排序树。时间复杂度olog2n 中序遍历一棵二叉排序树可以得到一个结点值递增的有序序列 适用情况：需要经常进行插入删除和查找运算的表 插入：新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点（不必移动其他结点，仅需改动某个结点的指针，由空变为非空） 构造树的过程：对无序序列进行排序的过程 删除：缺右子树用左孩子填补，缺左子树用右孩子填补，在左子树上找中序最后一个结点填补（被删结点左右子树存在） 平衡二叉树（AVL）：左右子树深度之差的绝对值不超过1，其左右子树也是平衡二叉树 平衡因子：该结点左右子树的深度之差，只可能是-1,0，1 调整方法：找到离插入结点最近且平衡因子绝对值超过1的祖先结点 最小不平衡子树：以该祖先结点为根的子树基准点：最靠近叶结点的不平衡点 LL型：右旋顺时针 RR型：左旋逆时针 LR型：先逆后顺 RL型：先顺后逆 当平衡的二叉排序树因插入结点而失去平衡时，仅需对最小不平衡子树进行平衡处理。确保二叉树在任何情况下的深度都是olog2n 内查找法：查找存储在计算机内存中较小的文件 B-树：用于外查找的平衡多叉树。有平衡、有序、多路的特点 树中每个结点至多有m棵子树 若根结点不是叶子结点，则至少有2棵子树 除根之外的所有非终端结点至少有[m/2]（向上取整）棵子树 所有的叶子结点都出现在同一层次上，并且不带信息，称为失败结点 所有的非终端结点最多有m-1个关键字，且左子树小于关键字，右子树大于关键字 如：4阶的B-树最多有三个关键字，四棵子树为记录其双亲结点，通常增加一个parent指针，指向双亲结点在B-树中插入关键字，可能产生结点的分裂，删除可能产生合并 B+树 有n棵子树的结点中含有n个关键字 所有的叶子结点中包含了全部关键字的信息，以及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接 所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中最大（最小）关键字散列查找法（杂凑法、散列法）：在元素的存储位置和其关键字建立某种直接关系，直接由关键字找到相应的记录。通过对元素的关键字值进行某种运算，直接求出元素的地址 散列函数：p（散列地址）=H（key）[散列函数]散列表：一个有限连续的地址空间，用以存储按散列函数计算得到相应散列地址的数据记录 散列表属于线性结构，通过一种散列函数把记录的关键字和它在表中的位置建立起对应关系，并在存储记录发生冲突时采用专门的处理冲突的方法。 冲突：对不同的关键字可能得到同一散列地址同义词：具有相同函数值的关键字 冲突经常存在原因：散列表中关键字的取值集合远远大于表空间的地址集 构造“好”的散列函数遵循原则： 函数计算简单，每一关键字只能有一个散列地址与之对应 函数的值域需在表长的范围内，计算出的散列地址的分布应均匀，尽可能减少冲突 构造方法： 数字分析法（从关键字中提取数字分布比较均匀的若干位作为散列地址），事先必须明确知道所有的关键字每一位上各种数字的分布情况 平方取中法（取关键字平方后的中间几位或其组合作为散列地址，具体所取位数由表长决定），适用于..不能事先了解关键字的所有情况，或难以直接从关键字中找到取值较分散的几位 折叠法（移位叠加、边界叠加）：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），取这几部分的叠加和（舍去进位）作为散列地址。适用..散列地址位数少，关键字位数多，难以直接从关键字找到取值较分散的几位 移位叠加：将分割后每一部分的最低位对齐，然后相加 边界叠加：将两个相邻的部分沿边界来回折叠，然后对齐相加 除留余数法：H（key）=key%p（p为小于表长的最大质数） 处理冲突的方法与散列表本身的组织形式有关 开放地址法：在寻找“下一个”空位的散列地址（探测）时，原来的数组空间对所有元素开放。公式Hi=（H（key）+di）%m 线性探测再散列法：发生冲突时，从冲突地址的下一单元顺序寻找空单元。找不到从头开始，失败作溢出处理 二次探测再散列法：di=1，–1^1，2^2，-2^2，……，+k^2，-k^2 伪随机探测再散列法：di=伪随机数序列 二次聚集：在处理冲突过程中发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象线性只要未满总会找到地址，但会产生二次聚集现象。二次和伪随机可避免二次聚集，但不能保证找得到 同义词链表：把具有相同散列地址的记录放在同一个单链表中。凡是散列地址为i的记录都以结点方式插入到以HT[i]为头结点的单链表中。存储效率低，因附加指针域 装填因子（散列表的装满程度）：表中填入的记录数/散列表的长度，越小，发生冲突的可能性越小 影响平均查找长度：处理冲突的方法和装填因子（散列函数均匀） 成功/失败平均查找长度：ASL=1/n∑Ci（n为记录个数，Ci为比较次数） 排序：按关键字的非递减或非递增顺序对一组记录重新进行排列的操作 排序算法是否稳定由排序方法决定 内部排序：待排序记录全部存放在计算机内存中进行排序的过程。 一趟排序：使有序区中记录的数目增加一个或几个的操作称为一趟排序 地址排序：设一个指示各个记录存储位置的地址向量，在排序过程中不移动记录本身，而移动地址向量中这些记录的“地址”，在排序结束之后再按照地址向量中的值调整记录的存储位置 直接插入排序：将一条记录插入的已排好序的有序表中，从而得到一个新的、记录数增1的有序表，时间复杂度on^2，空间复杂度o1。稳定排序，算法简便，可顺可链，适合初始记录基本有序（正序）情况 折半插入排序：类似折半查找。在插入第i个记录时需要经过[log2i]+1次比较，才能确定它应插入的位置。时间复杂度on^2，空间复杂度o1,。稳定排序，只能顺序，适合初始记录无序、n较大的情况 希尔排序（缩小增量排序）：将整个分割成几组，分别进行直接插入排序，经过几组分组排序，对全部记录进行一次直接插入排序。时间复杂度on^1.3，空间复杂度o1。不稳定，只能顺序，适用于初始记录无序、n较大的情况。增量序列可多种取法，但增量序列的值应取没有除1外的公因子，且最后一个增量值必须等于1 冒泡排序：两两比较相邻记录的关键字，逆序则交换，使关键字小的左移，关键字大的右移。时间复杂度on^2，空间复杂度o1。稳定，可顺可链，移动次数多，不适用初始记录无序、n较大的情况 快速排序：任取一个记录（一般取第一个记录）作为枢轴（支点），交换到前面后面。时间复杂度onlog2n，空间复杂度olog2n（最好），on（最坏）。不稳定，适合顺序结构，速度最快，适用初始记录无序、n较大的情况 简单选择排序：选择关键字最小的排在最后，依次排序。时间复杂度on^2，空间复杂度o1。稳定，可顺可链，移动记录次数较少 树形选择排序（锦标赛排序）：对n个记录的关键字进行两两比较，然后在其中[n/2]（向上取整）个较小者之间再进行两两比较，直至选出最小关键字 堆排序：大根堆（堆顶记录的关键字最大），小根堆（堆顶记录的关键字最小）。从上到下。形状是个完全二叉树。时间复杂度onlog2n，空间复杂度o1。不稳定，只能顺序，比较次数较多，适合记录多的情况 筛选法：把较小的关键字逐层筛下去，而将较大的关键字逐层选上来 2-路归并：将两个有序表合并成一个有序表的过程，核心操作是前后相邻的两个有序表。时间复杂度onlog2n，空间复杂度on。稳定，可顺可链，且不需要附加存储空间（链） 基数排序：根据关键字中各位的值，通过对待排序记录进行若干趟分配收集来实现排序的，借助多关键字思想对单关键字排序。 多关键字排序：最高位优先法，最低位优先法 链式基数排序：分配最低位，十位数、百位数，重新链成一个链表。时间复杂度o（d（n+rd）），空间复杂度o（n+rd），d个关键字，每个关键字取rd个值 时间性能好的都是不稳定的。基数排序是稳定的内排方法 若记录本身信息量大，为避免移动记录耗费大量时间，可采用链式存储结构 N较大： 关键字分布随机，稳定性不作要求：快速排序（平均时间性能佳） 关键字基本有序，稳定性不作要求：堆排序 关键字基本有序，内存允许，要求排序稳定：归并排序]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管理学]]></title>
    <url>%2F2016%2F03%2F07%2F%E7%AE%A1%E7%90%86%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[第一章：管理概述 P6 管理的职能 管理的职能是：计划、组织、人事、指挥、协调、报告、预算。（1）资源是管理的前提条件（2）目标是管理的价值体现（3）效率是管理的灵魂所在（4）效果是管理的生命源泉 管理的基本职能：（1）计划：管理者谋划组织未来行动目标以及提出实现目标途径的过程（2）组织：通过任务结构和权力关系的设计来协调组织成员的努力。（3）指挥：对下属行为予以指导（4）控制：管理者为了保证实际工作与计划的要求相一致，按照既定的标准，对组织的各项工作进行检查、监督和调节的管理活动 P13 不同层次的管理者 （1）高层管理者：负责确定组织目标，制定实现既定目标的战略。（2）中层管理者：负责承上启下，将高层管理者制定的战略分解为可操作的具体任务并组织一线部门予以实施。（3）一线管理者：提高生产效率，提供技术援助，监督下属对规划和程序的实施情况 P14 管理技能 （1）技术技能：从事自身管理范围内的工作所需的基本技术和具体方法（2）人际技能：把握与处理人际关系的有关技能。（3）概念技能：综观全局、把握关键、认真思考、扎实谋事的能力（洞察组织与环境及其之间相互影响以及复杂性的能力） P20 组织的概念与基本特征 概念：组织是人们在共同劳动中形成的协作性团体，是一切管理活动的载体（政治、经济、文化组织） 作业关系视觉的组织： 由相互联系的多个子系统组成的人造系统：目标和价值子系统、技术子系统、社会心理子系统、结构子系统、管理子系统 开放的社会技术系统 治理结构视角的组织： 内部治理机制：股东会、董事会、经营会、监事会 外部治理机制：经理市场、产品市场、资本市场、金融市场。 P24 管理外部环境 （发展趋势是什么（大题）） 一般环境（那些可能对企业日常经营没有直接影响但存在间接影响的外部因素） 文化 技术 教育 政治 法制 自然资源 人口 社会 经济 任务环境 消费者 供应者 竞争者 社会政治 技术 P26当今管理的外部环境特征 （1）经济体制市场化（2）技术基础信息化（3）知识资源主体化（4）信用经济普遍化（5）公司运作透明化（6）管理制度人性化 第二章：西方管理思想的历史演进 P32 科学管理理论 科学管理理论（泰罗）：以科学的方法分析工作过程以及对劳动行为进行监督（一方面提高劳动生产率，另一方面加强管理、提高管理效率、降低管理成本） 作业管理：（1）制定科学的作业方法（2）科学挑选与合理培训工人（3）实行刺激性的差别计件 组织管理：（1）把计划职能与执行职能分开，变经验工作法为科学工作法（2）实行职能工长制（3）实行例外原则 P36 古典组织理论 法约尔的行政管理理论：（1）分工（减少浪费，提高生产率）（2）权力与责任（保持对等）（3）纪律（协定，态度以及遵守情况）（4）统一指挥（只能接受一个上级的指令）（5）统一领导（一个直接上级）（6）个人利益服从整体利益（7）人员的报酬（维持职工的最低生活消费和企业的基本经营情况）（8）集权化（提高或降低部下作用用分散或集中）（9）等级制度（跳板原则，或法约尔桥）（10）秩序（11）公平（“公道”原则加上善意的对待员工）（12）人员稳定（人员稳定是相对的，人员流动是绝对的）（13）首创精神（发明、执行的可能性，建议、执行的自主性）（14）集体精神（协调团结） 韦伯的理想官僚组织观点（组织理论之父）：合法型统治：高度理性化，最合理、最有效率、“理想的官僚组织”，尊重理性分析和规则约束（1）明确的劳动分工（2）严密的职权等级（3）正式的甄选（4）正式的规则和法规（5）非人格化（6）职业生涯导向 传统型统治（任人唯亲原则，注重先例的约束）：（1）缺乏按照章程确立的、固定的权限（2）缺乏固定的、合理的等级制度（3）缺乏按章程要求的官员晋升制度（4）缺乏专业培训 魅力型统治（“感情共同体”，排斥理性和规则，推崇神谕、灵感和个人意志）：（1）成员按对统治者魅力的适应性选择的（2）既没有任命或罢免，也不存在资历和升迁（3）不存在“等级制度”（4）没有固定的“机构”（5）没有规章，没有抽象的法律原则 P43 人际关系学说之霍桑实验 经济人：在思想上、行动上力争获得个人利益，追求最大限度的经济收入。（1）照明度实验：照明度对生产没有影响（2）试验室实验：管理人员监督技巧的改进以及随之而来的人际关系改善和团队士气提高（3）访谈研究：监工要能够倾听和理解工人的“诉苦”，不要道德说教（4）观察研究：认真处理“效率逻辑”和“感情逻辑”之间的冲突 结论： 工人是社会人（社会人：属于某一集体并受其影响的，追求显示自己社会重要性的社会受认可度） 工人的士气是决定生产效率的关键 企业中存在着“非正式组织”（超然于组织外的个人感情，具有不可忽视的导向力） 新型领导方式应当以社会和人际技能为基础 P48 管理理论“丛林式”发展（注意：行为、权变） 管理过程学派：职能分类、明确任务、具体研究 行为科学学派：主要是有关对工作环境中个人和群体的行为进行分析和解释的心理学和社会学学说，试图创造出一种最优工作环境 决策理论学派：组织就是决策者的个人所组成的系统，组织成员都是为实现一定目的而合理地选择手段的决策者 系统管理学派：以目标、责任、人为中心，以整个系统为出发点 社会-技术系统学派：技术因素对行为的影响 经验主义学派：提供成功经验和科学方法 权变理论学派：强调在企业管理中要根据企业所处的内外环境随机应变，没有什么一成不变、普遍适用的、“最好的”管理理论和方法 管理科学学派：采用科学的方法，探求最有效的工作方式或最佳途径 第三章：管理学中的人性假设和管理发展趋势 P62 人性假设（前三个） 经济人（泰罗）：在思想上、行动上力争获得个人利益，追求最大限度的经济收入。只注重对人的物质刺激，忽视对人的社会需求的满足 社会人（梅奥）：有各种需求，满足安全、友情、受尊重及自我实现上的需要 复杂人（沙因）：人类的需要是分成许多类的，并且会随着人口发展阶段和整个生活处境而变化，由于需要与动机彼此作用，并组合成复杂的动机模式、价值观与目标，所以人们必须决定自己要在什么样的层次上去理解人的激励。 第四章：决策 P82 决策含义、类型和程序 决策含义：为了达到一定的目标，在掌握必要的信息和有关情况并进行全面分析的基础上，用科学的方法拟定和评估相关行动方案，最终选定合理方案的过程。决策要素：（1）决策者：对客观世界的认识能力和对未来实践的驾驭能力（2）决策对象（3）信息：决策的依据（4）决策理论与决策方法：进行科学的分析、综合、推理，而后得到正确的判断（5）决策结果 决策类型： 按重要程度 战略决策：有关组织全局利益和长远利益的决策 战术决策：有关实现战略目标的方式、途径、措施等的决策 按重复程度： 程序化决策：例行问题（有现存的政策和规则可依） 非程序化决策：例外问题（需要开拓创新） 按条件确定性： 确定性决策：未来的自然状态是确定的 不确定决策：对各自然状态在未来发生的可能性一无所知 风险型决策：知道（或可估计）每个自然状态发生的概率 按决策主体所处的管理层次： 高层决策：组织的高层领导者所作的决策（事关全局、长远） 中层决策：组织的中层领导者所作的决策（大多只涉及一个部门） 基层决策：组织的基层领导者所作的决策（解决局部的日常工作中的问题） 决策的程序：（1）识别决策问题（意识到问题、迫于压力采取行动、拥有行动所需的资源）（2）确认决策标准（3）为决策标准分配权重（4）开发备择方案（5）分析备择方案（6）选择备择方案（7）实施备择方案（8）评估决策结果 P88 决策的标准（理性与有限理性） 泰罗的“最优”标准：理性人，决策者是完全理性的，能做出最优选择，追求效用最大化 理性决策条件：（1）能得到所需要的全部详细的决策信息（2）能了解所有人的社会价值取向（3）能找到所有决策方案（4）能准确预测所有可能产生的后果（5）能正确选择最有效的决策方案（6）目的始终是使本组织获得最大的经济利益 理性决策模式内容：（1）面临的是一个既定的问题（2）做出决定的各种目的、价值或各种目标是明确的，可按重要性排序（3）将所有方案列举出来（4）对方案进行评估，预测后果（5）一一对比，按优劣排出先后顺序（6）正确选择最大限度地实现预定目的、价值或目标的那个方案 西蒙的“满意标准”（有限理性人，比较现实的决策模型）：（1）人的理性是完全理性和完全非理性之间的一种有限理性（2）容易把问题的部分信息当作认知对象，直觉多于逻辑分析方法（3）不可能做到全部了解，选择的理性相对的（4）厌恶风险，倾向于接受风险比较小的方案（5）往往只求满意的结果，而不愿费力寻求最优方案 P90 决策的思维方式 概率思考：（1）前提：思考者在头脑中应该有概率的概念，即要懂得用概率表达事件的可能性（2）具有概率思维的人：能够使用或习惯于使用数量化的主观概率值来表达事件可能性的人（3）具有概率思维道德人其决策的科学性和有效性会更高一些（4）概率思维能力和习惯主要受个性差异和文化差异的影响 解析思考： 认真分析，综合思考（找出问题的症结所在，“模型要简单，思考要综合”） 分解（将一个问题分成若干组成部分） 简化（找出真正重要的因素，略去无关紧要的因素）：列出所有可能的决策方案、找出每个方案的可能结果、预测概率、列出后果，评价决策者对每个方案的偏好度，从而得出一组最理想的结果 判断（对决策问题的各个不确定因素做出具体的说明） 再思考（再次思考一下在这步分析中用到的判断值和在简化时被略去的因素） 目标-手段分析（西蒙）：（1）理性的决策，应以有限手段获取最大价值（2）考虑一些始料不及的后果的重要性（3）抉择受特定目的、时间因素的影响 第五章：计划制定 P122 计划含义 （1）广义的工作计划：制定计划、执行计划和检查计划执行情况三个紧密衔接的工作过程（2）狭义的工作计划：制定计划 根据实际情况，通过科学的预测，权衡客观的需要和主观的可能，提出在未来一定时期内要达到的目标，以及实现目标的途径 计划工作的任务：（1）明确具体任务和要求（2）明确宗旨、目标和战略（3）了解环境条件和限制（4）明确规定目标、任务、地点和进度（5）制定实现计划的措施，以及相应的政策和规则（6）控制标准和考核指标的制定 P123 计划制定程序 估量机会（对未来可能出现变化和预示的机会进行初步分析、扬长避短） 确定目标 说明基本方针 目标 指定战略 政策 规则 程序 规划 预算 指出工作的重点 确定前提条件（计划工作的假设条件） 拟定可供选择的方案 评价各种备选方案 选择方案 拟定派生计划 编制预算（使之数字化） P126 物料需求计划 含义：一种计算物料需求量和需求时间的生产计划与控制系统 基本思想：围绕物料转化组织制造资源，实现按需要准时生产。 独立需求（需求的对象和数量不确定，只能根据市场预测进行粗略的估计） 相关需求（非独立需求，可以根据对最终产品的独立需求精确地计算出来） 基本任务： 从最终产品的生产计划（独立需求）导出相关物料（原材料、零部件等）的需求量和需求时间（相关需求） 根据物料的需求时间和生产（订货）提前期来确定其开始生产（订货）时间 基本内容：编制零件的生产作业计划和采购供应计划 主要输入： 主生产计划（确定每一具体的最终产品在每一具体时间段内生产数量的计划） 产品结构文件（用规范的数据格式来描述产品结构的文件） 库存信息（保存企业所有产品、零部件、在制品、原材料等存在状态的数据库） P129 网络计划技术 含义：用于工程项目的计划与控制的一项管理技术 关键路线法：通过网络分析研究工程费用与工期的相互关系，并找出在编制计划及计划执行过程中的关键路线 基本内容： 网络图 时间参数 关键路线 网络优化 基本原理：把一项工作或项目分成各种作业，然后根据作业顺序进行排列，通过网络图对整个工作或项目进行统筹规划和控制，并对工程的时间进度与资源利用实施优化 P134 目标管理（大题） 含义：“成果管理”，俗称“责任制”，是指在企业个体职工的积极参与下，自上而下地确定工作目标，并在工作中实行“自我控制”，自下而上地保证目标实现的一种管理方法。以目标为导向，以人为中心，以成果为标准，从而使组织和个人取得最佳业绩的现代管理方法。 过程：管理者应该通过目标对下级进行管理，当组织最高层管理者确定了组织目标后，必须对其进行有效分解，转变成各个部门以及各个人的分目标，管理者根据分目标的完成情况对下级进行考核、评价和奖惩。 意义：由上而下的目标分解和自下而上的目标期望相结合，使经营计划的贯彻执行建立在职工的主动性、积极性的基础上，把企业职工吸引到企业经营活动中去 特点： 重视人的因素（平等、尊重、依赖、支持，自觉自主自治） 建立目标锁链与目标体系 重视成果 目标的程序： 目标的设置：高层管理预定目标、重新审议组织结构和职责分工、确立下级的目标、上级和下级就实现各项目标所需的条件以及实现目标后的奖惩事宜达成协议 实现目标过程的管理（进行定期检查、通报进度、解决困难问题） 总结和评估（考核目标完成情况） 优点： 对组织内易于度量和分解的目标会带来良好的绩效 有助于改进组织结构的职责分工 启发了自觉，调动了职工的主动性、积极性、创造性 促进了意见交流和相互了解 缺点： 目标难以制定 哲学假设不一定都存在 目标商定可能增加管理成本 奖惩不一定都能和目标成果相配合，也很难保证公正性 第六章：战略管理 P151 战略管理含义 含义：对企业发展的统筹规划，决定企业在外部竞争环境中的发展定位 根本目标：获得持续的竞争优势 当今战略决策: 产业环境的选择（进入适合企业发展的业务领域 构建企业的资源与能力基础（获取竞争对手难以模仿与替代的战略位势） P152 战略含义 含义：泛指重大的、带有全局性或决定全局的谋划 特征： 简单、一致和长期性的目标 深刻理解竞争环境 客观评价各种资源 有效的战略实施 企业战略：对企业长远生产与发展所作出的全局性谋划 P153 战略管理产生与发展 产生：伊戈尔·安索夫提出，指的是企业高层管理者在对内外部环境分析的基础上，对企业未来发展制定全局的谋划与安排，并有效配置组织内的相关资源，以促进目标的达成。 发展： 以环境为基点的经典战略管理理论（选择有利的环境并规划企业的业务发展范围，缺乏对竞争环境的分析） 以产业（市场）结构分析为基础的竞争战略理论（强调产业环境的分析，但缺乏对企业内部资源能力基础的分析） 以资源、能力、知识为基础的核心能力理论（研究对象集中于处于优势地位的领导企业，缺乏对于弱势企业战略的评价） P154 战略管理层次与过程 公司层战略（为实现企业总体目标，对企业未来发展方向作出的长期性和总体性战略）：限定了公司竞争活动的范围，即各种行业和市场 业务层战略（经营战略或竞争战略，在总体战略指导下，一个业务单位进行竞争的战略）：有关公司如何在一个行业内或市场中进行竞争的决策。 职能层战略（企业中的各职能部门制定的指导职能活动的战略）：保证公司层战略与经营战略在企业各个职能层面具体落实 战略管理是一个动态和连续与不断调整的过程： 明确组织当前的使命、目标和战略 每一个组织的管理都要分析组织所处的环境（一般环境、竞争环境） 评估组织的机会和威胁 从对组织外部的考察转移到对组织内部进行考察 P160 公司层战略之成长战略 集中化成长战略（企业在产品、业务方面保持单一，将拥有的全部资源都集中用于自己最具优势或企业最看好的某种产品或业务上，力求将其做大做强；基本不涉足新的业务多新市场领域）： 市场渗透战略 市场开发战略 产品开发战略 一体化战略： 纵向一体化（企业在两个可能的方向上扩展现有经营义务，前后向） 横向一体化（企业收购或兼并同类产品生产产业以扩大经营规模） 多元化战略： 相关多元化（同心多元化） 无关多元化 P163 BCG、GSM矩阵 波士顿（BCG）分析矩阵（纵轴业务增长率，横轴相对竞争优势）： 问题业务：具有成功潜力的新产品，但需要大量现金投入开发（成长战略） 明星业务：一般是处于产业生命周期顶峰的市场领先者，能够产生足够多的现金维持高市场占有率（成长战略） 现金牛业务：产生的现金收入一般高于维持其市场占有率需要的花费（维持战略） 瘦狗业务：那些市场占有率很低而且不具有带来大量现金潜力的产品（收缩、放弃战略） 大战略（GSM）分析矩阵（横轴竞争地位，纵轴市场增长速度）： 第一象限：继续集中经营于当前的市场（市场渗透和市场开发）和产品（产品开发）是适当的战略，可一体化战略或集中多元化 第二象限：处于高速增长产业，加强型战略是首选。横向一体化（缺乏独特的生产能力或竞争优势）是理想战略。可剥离、结业清算战略次要地位业务。 第三象限：产业增长缓慢，相对竞争能力不足。必须实施收割战略，大幅减少成本或投入，将资源转向其他业务领域，最后剥离或结业清算撤离该产业。 第四象限：产业增长缓慢，但处于有利地位。具有较大的现金流量，对需求有限，有足够资源能力实施多元化或混合式多元化战略 P166-167 业务层管理的决定 成本领先战略（低成本生产）：提高经营效率、取得规模经济性、技术创新、获得低成本的劳动力或优惠的原材料供给 差别化战略（争取在某一宽泛性市场中能够具有独特性）：高品位、优质的服务、创新的设计、技术能力或积极向上的商标形象，要区别于竞争者 集中战略（只将业务集中在某一狭窄市场领域）：选择行业中的一个或一组细分市场，制定适当的战略为这些细分市场提供独到的服务 管理者应该避免在同一产业内与所有的竞争对手进行较量，应该把优势和精力放在竞争对手的弱势领域内，用正确的战略获得竞争优势。 P169 VRIO框架 价值问题（资源的价值性指一个企业的资源和能力能否使企业对环境威胁和机遇作出反应）：发展新的和有价值的资源和能力或者将原来具有价值的资源和能力以新的方式出现。 稀有性问题（只要拥有特殊的有价值的资源和能力的企业数量少于在产业中需要创造完全竞争动态企业的数量） 模仿性问题（不可模仿的特征是难以直接复制和替代）：独特的历史条件、因果关系的模糊性、社会的复杂性、专利的限制。 组织问题（补充性的资源和能力）：企业的组织结构、企业的管理控制体系、企业的补偿政策 P171 职能层战略包括那几块 营销战略：顾客需求、宣传与推广策略、分销渠道策略 财务战略：维持负债、权益、内部长期资金之间的合理比例 技术开发战略：确定产品和工艺创新及其改进（发展中国家：技术追随战略） 制造战略：决定在何地以何种方法制造产品、纵向一体化程度、有形资源配置以及与供应商的联系 人力资源战略：人员与组织间的最佳匹配 第七章：组织设计 P180 组织及组织设计的概念 （1）组织：建立任务和权力结构（形成组织结构）的活动（2）组织设计：通过任务结构和权力关系的设计来协调组织成员的努力 P181 岗位设计分类之第五方面 按对生产活动有无直接指挥关系分： 直线职能岗位：直接组织指挥日常生产活动的职责，从企业上层到基层，形成垂直的、逐级指挥的直线系统 参谋职能岗位：专业管理，协助领导指导和监督下级，但无权直接下达命令。 P182 部门设计 部门：对企业内各种职能加以分类后所组成的专业化的亚单位（1）职能部门化：具有专业化，把同类活动集中于一个部门（2）产品部门化：把生产一种产品或产品系列的所有必需活动组织一起，从而形成相应部门（3）地域部门化：把某一地区内本企业的全部活动集中起来并组成一个部门（4）顾客部门化：按服务对象划分，有利于在满足不同顾客需要的同时找到自己的活动空间（5）流程部门化：组织按生产过程，工艺流程或设备来划分部门 P183 管理幅度和管理层次设计 管理幅度：一个主管人员所能直接有效管辖的下级人数（部门的规模） 管理层次：从企业最高一级管理组织到最低一级管理组织的各个组织等级（组织纵向结构特征） 关系： 管理幅度对管理层次的多少具有直接影响，并最终影响到组织结构的形式 反比关系。管理幅度加大，管理层次减少。 管理幅度设计影响因素： 管理人员与下属的工作能力 工作内容和性质： 主管所处的管理层次 下属工作的相似性 计划的完善程度 非管理事务的多少 工作条件： 助手的配置情况 信息手段的配备情况 工作地点的相近性 工作环境 管理层次的设计： 依据企业的纵向职能分工，确定基本的管理层次 依据提高组织效率的要求，确定具体的管理层次：管理层次较多时，领导岗位多，晋升机会多，一定的激励效果，成员沟通方便。易于达成共识。但协调成本高，上下级意见沟通受阻，影响下级人员的主动性和创造性。管理层次较少时，信息流通快、管理费用低，被管理者拥有较大的自主权，降低管理严密性，导致部门规模过大带来的无序状态。 依据组织不同部门的特点，实行管理层次的差异化设计 P186 职权设计（大题） 职权：企业各个部门、各种职务在职责范围内决定和影响其他个人或集体行为的支配力 职权的纵向结构设计： 纵向结构：高层的经营决策权、中层的专业管理权、基层的作业管理权 集权：决策权在组织系统中较高层次的一定程度的集中 衡量集权与分权的标准：决策的数量、决策的范围、决策的重要性、对决策的控制程度 影响集权与分权的因素：决策的代价、政策的一致性、组织的规模、管理人员的数量与素质、控制的可能性、职能领域 职权的横向结构设计（为了解决企业管理专业化分工与协作之间的矛盾，达到在分工基础上加强协作，提高企业管理整体功能的目的）： 非结构性方式（改变和完善组织运行规则与形式）：建立管理工作规范、建立例会制度、由主要部门组织会审会签、跨部门直接协商、联合办公和现场调度 结构性方式（调整甚至变更原有组织结构以达到横向协调的目的）：设置联络员、建立任务小组或委员会、设立专职协调部门 人际关系方式（目的是改善人际关系） P189 注重行为分析 现代企业：最大的特点是组织目标与个人目标的融合、人际关系中相互依存度大为提高 交迭角色组理论（卡恩）： 组织是由许多交迭的、连锁的角色组所组成的集合体 可能产生的矛盾： 角色冲突（不同成员对中心人物的不同期望） 角色超负荷（中心人物没有能力满足许多期望） 角色含糊不清（中心人物不知道做什么） 连接销结构（利克特）：把组织中的个人作为组织中各个单位之间的“连接销”，以实现一体化 行为学观点（本尼斯）：预言集权等级制会越来越没活力，在组织会逐渐减少 P191 倾向权变观点（大题） 权变观点的倾向：组织是在各种内外因素的综合作用下运行的 权变因素：变化着的内外因素 机械式结构：强调应用界限清楚的、集中化的等级结构 有机式结构：分权式、参与式的权力等级结构，其职务和程序都比较灵活 环境、战略与技术是影响组织结构选择的三个重要因素 环境与组织结构： 按经济组织：人员市场、采购市场、投资市场、销售市场 按市场的变动性和复杂性： 高度确定的环境（市场相对稳定、稳定性大、可预测度高、机械式结构是成功的） 比较确定的环境（顾客需求复杂、多供应商、多竞争者、市场变动小、市场趋势较准确了解、机械化结构不合适、组织必适当发展） 很不确定的环境（市场复杂多变、情况模糊而难以了解、组织必强调分权和参与，即采用灵活的易变的有机式结构） 战略与组织结构： 数量发展阶段（单独的职能） 地区开拓阶段（职能部门） 纵向深入阶段（职能机构）1.多项经营阶段（横向发展的分权式组织结构） 技术与组织结构： 管理角度的技术：组织把原材料转化为最终产品或服务的机械力和智力的转换过程 按完成工作任务方式： 中介型技术（把彼此独立的，有标准的操作程序的各作业单位连结起来的技术） 长链型技术（按照完成一次任务的先后程序，把相互依存的职能单位联结起来的技术） 集束型技术（围绕一项任务，同时调动和集合若干职能单位的技术） P194-197 当今组织结构的趋势（大题） U型结构（按职能划分部门的纵向一体化的职能结构）：企业内部按职能划分为一系列部门，各部门独立性很小，企业实行集中控制和统一指挥，可使企业达到必要的规模和效率，适应于市场稳定、产品品种少、需求弹性大的环境 M型结构（多分部或事业部的组织形式）：按产品、客户、地区等来设立事业部（有相当自主权的利润中心），独立的进行日常决策（1）组织形态扁平化（2）组织规模小型化（3）组织反应敏捷化（4）组织姿态开放化（5）组织格局分权化（6）组织行为创新化 全球竞争： 全球竞争的普遍化（“国家”、“企业”、“个人”的全球化） 全球竞争的“横向”组织法则：要拥有横向的，能和任何人连接与合作的习惯 技术性安排：内部横向化、外部横向化 组织虚拟化：从头到尾通过网络完成，甚至无须见面 P198 组织结构基本形式（大题） 组织结构形式：组织结构设置的具体模式、管理组织的外在表现形式 直线制（只适用小规模企业）： 机构简单、沟通迅速 权力集中、指挥统一 垂直联系、责任明确 职能制（除了服从直线领导、还受多个职能部门领导） 优点：管理分工较细、有利于工作深入，便于充分发挥职能机构的专业管理功能。 缺点：多头领导，无法统一指挥 直线-职能制（直线-参谋制）：以直线指挥系统为主体，同时利用职能部门的参谋作用（对下级部门无权直线指挥，只起业务指导作用） 优点：保证了企业的统一指挥、有利于用专业化管理提高管理效率 不足： 下级缺乏必要的自主权 各职能部门之间联系不紧，易于脱节或难以协调 企业内部信息传递路线较长，反馈较慢，难以适应环境变化 事业部制（联邦分权制）：实际的利益责任单位，具有利益生产、利益核算、利益管理三种职能，有独立的市场 优点： 有利于发挥各事业部的积极性、主动性 有利于最高管理层摆脱日常事务，集中精力去考虑宏观战略 有利于锻炼和培养部门管理人员 要求：管理者精干得力、知识面广、经验丰富 矩阵制（规划–目标结构）：被用于完成某一项特别任务 优点： 加强了各职能部门的配合 有利于发挥专业人员的综合优势 有利于改善整体工作效率 不足：双重领导 网络制（信息革命的直接产物）： 内网络型：由若干独立、彼此有一定纵横联系的经营单位组成的网络。 其组织哲学：组织应当是丰富化的和由下而上的小独立创新单位的有序结合 外网络型：若干为了完成某一任务，利用电子信息技术在短时间内建立起合作关系的企业所构成的网络式联盟组织（临时性的、分合迅速、反应灵敏、效率极高） 企业网络特点：松散性、动态性 第八章：人力资源管理 P207 序篇 员工：企业最宝贵的财富、组织利润的创造者、组织活力的维护者和推动者 组织的人力资源会成为企业竞争优势的重要源泉 彼得·德鲁克：人力资源是一种特殊资源，必须通过有效的激励机制才能开发利用，并为企业带来可观的经济价值 人力资源是一定时期内组织中所拥有的能够被组织所用，且对价值创造有贡献的人的知识、技能、经验、体力、智力等的总和。 人力资源管理：一种职能型职责，组织中各类管理者的职责 P209 内外部招聘内容 内部招聘（在组织内部现有员工中发掘、获取所需人才，填补职位空缺）： 内部提升（将现有职员提升到比他原有级别更高级别职位）： 优点： 鼓舞士气、激发热情 保证招聘工作的正确性 利于被聘用者迅速展开工作 不利： 员工内部关系紧张 形成“近亲繁殖” 工作轮换（对员工工作岗位的暂时变动） 外部招聘（根据组织预先确定的招聘标准和招聘程序，从组织外部应聘者中选拔出符合空缺职位要求的人的过程）： 优点： 没有“历史包袱” 避免组织的“职场政治”，保持工作的独立性 1. 带来新鲜空气 在更广阔的范围选拔人才 局限性： 资讯了解可能不全面、不深入 环境、人际关系不熟悉 对内部员工的负面影响 内外部招聘方法：（1）刊登招聘广告（2）举办人才招聘会（3）通过网络发布招聘信息（4）员工举荐（5）熟人推荐 P217 职业生涯指导 职业生涯：个人职业生活的发展和变化历程（一个人所从事的各种客观工作总称，个人在从事各种工作过程中所形成的人生价值观、处世态度、工作动机的变化过程） 职业生涯理论： 职业选择理论（霍兰德）：人格是个体选择职业的重要影响因素。职业性向有实际型、研究型、社会型、常规型、企业型、艺术型。 职业锚理论（施恩）：探索发展过程中慢慢形成一个较为清晰的与职业有关的自我。职业锚（当一个人不得不做出选择时，他都不会放弃的那种至关重要的东西或者价值观）有技能或功能型职业锚、管理型职业锚、创造型职业锚、自主型或独立型职业锚、安全型职业锚。 职业发展理论：每一个阶段都有其独特的职业活动。 职业发展阶段 成长阶段（14） 探索阶段（24） 确立阶段（44） 维持阶段（60） 衰退阶段。 职业指导（组织为了达到组织和个人的目标而采取的一系列旨在开发人力资源潜能、实现职业目标的活动）： 提供自我评估平台 开展职业咨询 实施职业发展项目： 纵向发展 横向发展 专业方向发展 P220 两类绩效指标 绩效评估：根据事先确定的工作目标、工作时间和评估标准对员工和部门实际工作完成情况进行评估的过程（1）岗位绩效指标：对岗位的一般性、常规性职责的完成情况进行考评而设置的指标体系（2）关键绩效指标：衡量企业战略目标任务完成情况的度量尺度（强调组织整体战略） P224 薪酬概念 （1）狭义：经济性补偿，组织以货币形式支付给员工的薪酬和主要以非货币形式支付的福利（2）广义：除经济性补偿外，还包括工作成就感、工作声望、发展前景等 P228 劳动关系概念 劳动关系是劳动者与组织之间在劳动过程中形成的社会关系第九章：组织文化 P236 组织文化概念 组织文化：组织在长期的实践活动中形成的，并且为组织成员普遍认可和共同遵循的、具有本组织特色的价值观念、团体意识、行为规范和思维模式的总和（组织的灵魂和精神支柱） P236-241组织文化结构 深层的精神文化决定其他两层文化，其他两层文化反作用于深层文化 企业文化的精神层（在生产经营过程中，受一定的社会文化背景、意识形态影响而形成的一种精神成果和文化观念、企业意识形态的总和）： 企业精神（企业文化的高度浓缩） 企业经营哲学（在经营管理过程中提升的世界观和方法论） 企业价值观（企业在追求经营活动过程中所推崇的基本信念和奉行的目标、企业全体或多数员工一致赞同的关于企业意义的终极判断）：经济价值取向（对利益的看法）、社会价值取向（对社会关系的看法）、伦理价值取向（涉及各方关系）、人文价值取向（以人为本，具有人文关怀） 企业文化的制度层： 企业领导体制（企业领导方式、领导结构、领导制度） 企业组织机构（为了有效地实现企业目标而筹划建立的企业内部各组成部分及其关系） 企业管理制度（为求得最大效益，在生产管理实践活动中制定的各种带有强制性义务，并能保障一定权利的各项规定或条例） 企业文化的物质层（以物质形态为主要研究对象的表层文化）： 产品（用于销售的最终成果） 企业环境（与企业生产相关的各种物质设施、厂房建筑以及职工的生活娱乐设施）和企业容貌（企业文化表征，体现企业个性化的标志） 企业生产环境（直接影响企业员工的工作效率和情绪，可通过色彩、音乐调节优化环境） 技术、设备现代化与文明程度 联系： 精神文化是核心层，是形成其他两层文化的基础和原则，并决定它们。 制度文化是一定精神文化的产物，也是它的基础和载体，并反作用于它。同时，制度文化是物质文化建设的保证。 物质文化是企业文化的最表层部分，是形成制度层和精神层的条件，是企业文化的直接外在表现，是企业精神文化的外在折射。 P241 组织文化功能 指导功能（为组织经营活动确定正确的制导思想和决策方向、把组织整体及组织成员个人的价值取向及行为引导到组织所确定的目标上来） 约束功能（对每个组织成员的思想、感情、心理、行为和举止具有约束和规范的作用，也体现在对组织本身的约束上） 凝聚功能（树立以组织为中心的共同理想、信念、目标、追求和价值观念，产生一种强烈的向心力） 激励功能（激发组织成员从内心深处自觉产生为组织目标拼搏的精神，并通过软约束调整组织成员的不合理需要，形成积极向上的整体力，产生持久的驱动力） 辐射功能（不仅对内部成员产生影响，而且通过各种渠道向社会辐射和传播）：传播途径有软件辐射、产品辐射、人员辐射、宣传辐射。 第十二章：激励 P326 个体行为动机模型 含义：人的行为是由动机决定的，而动机是由需要引起的，行为产生客观现实的效果，行为的效果受到目标的检验，目标的检验又会使人调整或产生新的需要，并依次反复，激励过程包含了上述的因素和环节。 P327-331 内在需要和外在需要、动机概念，功能和分类 激励概念，分类，过程，与工作绩效关系 需要（人对某种事物的渴求或欲望） 特征： 社会性 目标性 无限性与不满足性 共同性与个体性 分类： 按性质：物质需要、精神需要 按满足强弱程度：强的直接需要、弱的间接需要 按满足方式： 外在性需要（靠组织所掌握和控制的资源（或奖酬）来满足的） 物质性需要 社会性需要、 内在性需要（靠被激励者本人对工作活动本身或工作任务完成时所带来的某种因素的体验和感受） 过程导向的内在性需要（在工作过程中得到满足，而不关心结果） 结果导向的内在性需要（通过完成工作并取得积极成果后所体验到的某种贡献感与自豪感实现的） 动机（人们行为产生的直接心理动力）： 功能： 引发功能 导向功能：促使个体行为朝着一定的目标或对象进行和发展 强化功能 分类： 按性质： 本能性动机（基于人的生理、本能需要而产生的原始动机） 社会性动机（由个体经过后天学习而获得的对社会物质和精神生活的需要而引起的动机） 按在行为活动中所起的作用的大小 主导动机（最为强烈、稳定的处于支配地位的动机） 辅助动机（其他动机） 按产生的来源 外部动机（由外部刺激对人激发出来的动机） 内部动机（对工作本身的兴趣、工作成果的满足而引发的动机） 激励： 含义：在一个人需要的基础上，通过促进、诱导其形成动机，并引导行为指向目标的活动过程。（激发人的动机，诱导人的行为，发挥其潜力，并用来为组织目标服务。本质是推动个体付出努力的一种心理诱导） 作用： 提高员工的工作绩效 协调利益分配中的矛盾，提高组织的凝聚力 利于组织留住人才和吸引人才 利于实现组织目标 按类型分类： 内在性激励（满足那些来自于所从事的工作本身、依靠工作本身或工作任务完成时所提供的某些因素的需要）有工作活动本身的激励性、工作任务完成时的激励性 外在性激励（满足外在性需要的资源所诱发的动机而产生的行为过程） 过程： 与工作绩效密切相关： 绩效=f（能力，资源，激励） 激励可以激发调动人的潜力，从而提高工作绩效 激励水平：激励的动力、激励行为的方向、激励行为的保持 P331-348 内容型、过程型、行为改造型激励 理论 内容型激励理论：需要层次理论（亚伯拉罕·H 马斯洛）：（1）人的五种需要：①生理需要（最原始、最基本）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②安全需要（现在的、未来的） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③社交需要（友爱或归属的需要） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④尊重需要（自尊、受他人尊重） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤自我实现需要（2）五种需要具有等级关系：①较低层次：生理、安全&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②较高层次：社交、尊重、自我实现（3）在一段时间内人的行为由主导需要（最迫切的需要）决定（4）未被满足的需要才具有激励作用（需要：促使人产生某种行为的内在基础）（5）启示：①正确认识员工需要的多层次性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②明确员工当前的主导需要 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③激励与需要对应 成就需要理论（麦克莱兰）【后天需要理论、三种需要理论】：（1）主要内容：①成就需要（对事业成功的追求）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②权力需要（影响或控制他人的欲望） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③合群需要（归属需要，建立亲密的人际关系、避免冲突的欲望）（2）结论：①权力需要强烈的人更有可能不断地获得晋升&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②有强烈合群需要的人往往是成功的人际关系“调节者” &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③合群需要与权力需要和管理的成功密切相关 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④最优秀的管理者往往是权力需要很高而合群需要很低的人（3）启示：①设置员工职位应尽可能围绕三种需要&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②三种后天需要可以通过训练来培养和激发 双因素理论（赫茨伯格）： 内容： 激励因素：与组织成员工作本身或工作内容有关的、促使人们产生工作满意感的一类因素（类似尊重和自我实现） 保健因素：凡是与工作环境或条件有关的、能防止人们产生不满意的因素（类似生理、安全、社交 ） “满意”的对立面是“没有满意”，而“不满意”的对立面是“没有不满意” 启示： 可以运用双因素理论转化为管理制度 注意保健因素与激励因素的相互转换 X理论和Y理论（道格拉斯·麦格雷戈）：以人的性质的假设为依据，用不同方式来组织、控制和激励人们 X理论（“理性-经济人”理论）：传统的管理观点 大多数人： 懒惰、尽可能逃避工作 宁可让别人领导 很容易受别人影响 选择经济获利最大的事 管理人员（“胡萝卜加大棒”的方法）： 如何提高劳动生产率、完成任务 应用职权，发号施令，使对方服从 强调严密的组织和制定具体的规范和工作制度 应以金钱报酬来收买员工的效力和服从 Y理论：建立在对人的特性和人的行为动机的更为恰当的认识基础上 一般人： 喜欢不喜欢工作，看环境而定 愿意实行自我管理和自我控制来完成应当完成的目标 如果提供适当的机会就能将个人目标和组织目标统一起来 学会接受职责、谋求职责 都能发挥较高的想象力、聪明才智和创造性智慧潜能部分地得到了发挥 管理措施： 创造一个使人得以发挥才能的工作环境，发挥出职工的潜力，并使职工在为实现组织的目标贡献时也能达到自己的目标 给予来自工作本身的内在激励 给予更多的自主权 Y理论并不是普遍适用的 过程型激励理论（研究从被激励者的需要到动机的产生直至行为结果的中间心理过程）：期望理论（弗罗姆）：（1）主要内容：如果一个人相信某个目标的价值，并认为经过自己的努力能够实现该目标，满足自己某方面的需要，他就会受到激励（2）M=VE：M（激励力：激励程度），V（效价：偏爱程度、吸引力），E（期望值：可能性、概率）（3）情况：①E高V高=M高&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②E高V低=M低 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③E中V中=M中 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④E低V高=M低 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤E低V低=M低（4）处理好这三方面的关系：①努力与绩效的关系&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②绩效与奖励的关系 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③奖励与满足个人需要的关系（5）启示：①激励的效果取决于目标效价和期望概率的共同作用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②激励员工时要考虑到个体期望目标的多样性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③提高员工的效价水平 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④设置适当的期望概率和实际概率 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤建立公平公正的绩效评价体系和奖励机制 公平理论（社会比较理论、亚当斯）： 基本观点：不仅关心自己所得报酬的绝对量，更关心相对量 主要内容： 公平公式：OA/IA（&lt;&gt;=）OB/IB 比较的参照对象：他人（横向比较）、自我（纵向） 制度公平（程序公平）：用来确定报酬分配的制度或程序是否让人觉得公平 互动公平（根据社会交换理论，个人希望通过付出换取自己想要的回报）：人际公平、信息公平 启示： 高度重视相对报酬问题：与积极性高低并无直接的必然关系 建立奖罚分明的制度 加强组织内沟通，做好心理疏导工作 目标设置理论（洛克）：强调了研究目标的重要性 目标是行为的最直接动机，设置适当的目标会对人产生强烈的激励作用，从而提高个体的工作绩效 内容： 设置具体、有挑战性、能被执行者接受 让员工参与目标的设置过程 实现目标的承诺（前提条件）、自我效能（个人对于自己是否完成任务的信念）、民族文化影响目标–绩效关系 启示： 管理者应与员工建立双向沟通的渠道，及时了解员工的目标设置状况 让员工参与制定合理的工作目标，才能有效地激发工作热情、提高工作绩效、获得满足感（成功时） 局限性： 某些目标难以定量化 只关注如何完成目标 行为改造型激励理论（研究如何改造和转化人们的行为，使其达到目标的一种理论）：强化理论（斯金纳）: 主要内容：若结果有利，趋向重复行动；若不利，趋向减弱或消失。（行为是结果的函数） 强化类型： 正强化（积极强化）：对符合组织目标要求的行为给予鼓励，从而加强这种行为的重复出现 负强化（消极强化、规避性学习）：对与组织不相容的行为予以何种不利结果的规定，强调的是一种事前规避 惩罚：对不符合组织目标的行为出现后采取的惩罚措施，以使这类行为减少，是一种事后处理④忽视：采取“不理睬”或“冷处理”的手段，以达到行为的自然消退 强化频率 连续强化（最容易塑造、最容易消退） 1. 固定时距强化（刺激强度最小） 固定比率强化（刺激性更大） 可变时距强化（按照不固定的时间间隔来采用强化物） 可变比率强化（随机安排） 启示： 因人而异采用不同的强化手段 设立一个目标体系，分阶段进行强化 正确选择强化措施 归因理论（海德）：如何解释、推论行为原因即归因的理论 归因：把他人或自己的行为的动机加以解释和推测 类型： 外部原因：来自个人本身以外的外界环境 内部原因（个人倾向归因）：来自个人本身的主观条件 成功与失败的归因： 努力 能力 任务难度 机遇 启示： 了解员工的归因倾向，掌握归因规律，可指导和训练人们的正确归因倾向，帮助正确地总结教训，从而调动积极性，提高工作效率 宣传教育，端正态度，做出合理的归因分析（通过改变员工对所发生事件的归因认知来激励和引导员工的行为，达到改造人的行为的目的） 挫折理论（多拉尔德、梅尔、米勒）：了解阻碍个人发挥积极性的各种因素，分析挫折产生的原因、遭受挫折后的表现以及寻求有效应对挫折的可行途径，以达到保护积极性、调动积极性的目的 挫折（人们在从事有目的的活动过程中，遭遇各种障碍和干扰，使其需要和动机不能获得满足时的情绪状态）： 环境起因挫折：由于外界客观事物或情况阻碍人们达到目标而产生的挫折 个人起因挫折：由于主观因素引起的挫折 受挫表现：理智性的、非理智性的 攻击：直接攻击（对构成挫折直接原因的人或物进行攻击）、转向攻击 退化（倒退、回归） 固执（坚持行为） 妥协 应对： 采取谅解、容忍的态度 消除形成挫折的根源，并创造有利于战胜挫折的组织环境 利用精神发泄方法 启示： 对形成根源的挫折进行系统分析，以有效的预防挫折的发生 提高员工的挫折容忍力 采取必要的应对挫折的方法 P353 实践层面的激励 实行员工参与： 直接参与式管理（下级很大程度上分享其直接监管者的决策权） 代表参与（员工不直接参与决策，有一部分人代表他们进行参与） 质量管理圈（QC小组：由一些基层管理人员以及一般员工自愿组成的，而且在业余时间内开展小组的讨论和研究工作，从而发现、分析并最终解决生产和质量问题） 员工持股计划（给予员工部分企业的股权，以此参与企业经营管理和剩余利润分配） 提高工作的价值感： 开展具有激励作用的工作设计：工作扩大化或岗位轮换、工作丰富化、工作特征模型 塑造绩效导向型的企业文化：如BSC（平衡记分卡）、KPI（关键业绩指标） 提高工作生活质量（QWL） 建立竞争性评价机制： 公平有效的绩效评估体系 薪酬激励制度（“对内机会平等公开，对外具有竞争力”） 用人激励制度：竞争上岗制（择优聘用）、末尾淘汰制（增强竞争意识和危机意识）、晋升激励制度 激发员工高层次需求： 沟通激励 荣誉激励 成就激励 情感激励（最直接） 培训激励 目标激励（至关重要、有效） 兴趣激励（为员工创造工作的意义和价值） 培养标杆员工： 准确选题，搭建平台 择优培养 提高效价水平 倡导学习标杆员工的管理者要身体力行发挥表率和示范作用 强化标杆行为（积极强化） 第十三章：领导 P362 领导概念 定义：在特定的环境下，指挥、带领、领导、鼓励和影响组织中每个成员（个体）和全体成员（群体）的行为活动过程，其目的在于使个体和群体能够自觉自愿而有信心地为实现群体或组织的既定目标而努力。 P364 权力定义 领导者权力类型与影响力来源、权力运用 权力：组织中个人（或者部门）影响其他人并实现其所希望的目标的能力（指挥下级的权和促使下级服从的力） 影响力:一个人的行动对他人态度、价值观、信仰或行动的影响 领导者权力类型与影响力来源：（1）职位权力（领导者在组织中所处的位置通过组织政策和程序上级和组织赋予的，随职务的变动而变动）：&nbsp;&nbsp;&nbsp;&nbsp;①合法权力：根据个人在组织中所处职位而被正式授予的权力&nbsp;&nbsp;&nbsp;&nbsp;②奖赏权力：对依照其命令行事的作用对象拥有分配有价值资源的能力&nbsp;&nbsp;&nbsp;&nbsp;③强制权力：建立在惧怕基础上的，对不服从要求的人进行惩罚的能力（2）个人权力（基于领导者的特殊知识或人格特征，由其自身的某些特殊条件才具有的源于个人特征的能力）：&nbsp;&nbsp;&nbsp;&nbsp;①专家权力：由于具有他人承认的知识、技能而产生的权力&nbsp;&nbsp;&nbsp;&nbsp;②参照权力（模范权）：由于具有他人喜欢，仰慕的人格特征而产生的力量 P367-374 第三节、第四节（大题） 领导行为理论： 领导作风理论（卢因）： 专制型：靠权力和强制命令让人服从（产量最高） 民主型：以理服人、以身作则（对待下级用个人权力和威信）[工作效率最高] 放任型：放任自流、毫无规章制度（绩效最差） 领导方式的连续统一体理论（坦南鲍姆、施米特）：七种典型领导方式（领导者、下属、环境三个因素） 领导行为四分图： 创立组织：把重点放在完成组织绩效上的领导行为 关怀体谅：信任尊重下级，关怀下级个人福利与需要，上下级沟通对话并鼓励下级参与决策的制定 关怀和组织都可能是成功的原因，根据具体情况而定 管理方格理论（得克萨斯大学教授布莱克、莫顿）：衡量管理者所处领导形态的模式（把任务成就以及人的满足感和一个正式的管理发展计划联系起来了） 研讨训练 团队发展 群际发展 确定组织目标 实现目标 稳定 领导权变理论：认为各种领导风格在对应的不同的环境中最有效 费德勒模型：任何领导形态均可能有效，其有效性完全取决于所处的环境是否适应 LPC：最不愿与之共事的同事（在工作中最难与之交往而把任务完成的人） 分高表现了重关系的风格（对人宽容、体谅、提倡人与人之间友好关系），分低则侧重任务（惯于命令和控制、更多的是关心任务的领导） 影响领导形态有效性的环境因素：上下级关系（最重要）、任务结构（工作任务的程序化程度）、职位权力（权力变量、最不重要） 每个领导者只限于采用某一种特定的领导风格，只有通过改变环境来迎合对应的风格 路径–目标理论（伊万斯。后由豪斯、米切尔发展）：以期望激励理论和领导行为理论为基础，以帮助下属建立明确的工作目标，并努力达成目标而展开的。(领导风格) 下级特点 任务性质 职权的大小 工作群体特点 组织环境 领导生命周期理论（情境领导理论）【赫西、布兰查德】： 观点：领导者的风格应适应其下属的成熟程度（成熟度：个体完成某一具体任务的能力和意愿） 不同管理方式：指示（高任务–低关系）、推销（高任务—高关系）、参与（低任务–高关系）、授权（低任务–低关系） 下属成熟度的四个阶段：M1、M2、M3、M4 超Y理论（人性：道格拉斯·麦格雷戈）：要想对下级实施正确的领导，必先正确地认识和对待下级 1. X理论 Y理论 超Y理论（权变理论）【约翰·莫尔斯、杰伊·洛希】：根据组织内外环境自变量和管理思想及管理技术等因变量之间的函数关系，灵活地采取相应的管理措施。主张组织和工作的适合性，个人的胜任感和工作的效率要相铺相成，互为补充。 超Y理论的内容 最主要的需要是实现胜任感 因人而异，不同的人有不同的满足方法 确知任务、了解目标、决定分配 各种管理理论均有可用之处 第十四章：沟通 P39沟通过程 （1）信息发送者：发出信息的人（信息源）（2）信息：信息发送者希望传达的思想、感情、意见和观点等（3）通道：信息传递的方式（4）信息接收者：接收信息的人（信息传递的对象）（5）背景：沟通发生的环境（心理、物理、社会、文化背景）（6）反馈：信息接收者对信息发出者的反应（有效指示沟通的效果） P393 沟通分类 按组织成员沟通途径： 正式沟通（成员按照组织中规章制度的明文规定进行的沟通 非正式沟通（成员通过正式沟通途径之外的信息交流和传达方式） 按是否进行反馈： 单向沟通（发送者和接受者两者之间的地位不变，即单向传递） 双向沟通（发送者和接收者位置不断交换，双方互为信息的发送者和接收者） 按组织内部沟通参与者的相互位置及信息的流向： 下行沟通（组织内部从较高职位向较低职位方向进行的自上而下的沟通） 上行沟通（组织内部从较低职位向较高职位方向进行的自下而上的沟通） 平行沟通（横向沟通，组织中相同级别的管理者之间的沟通） 按功能： 工具式沟通（发送者将信息传达给接收者，为影响和改变接收者的行为，以达到目的） 感情式沟通（沟通情感，获得对方精神上的同情和谅解，最终改善相互关系） 按沟通的表达方式 语言沟通 非语言沟通 P395 沟通网络 沟通网络：群体组织人际沟通过程中信息传递方向形成的线路形态（1）正式沟通网络：①链型沟通（中间的人更有利）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②轮型沟通（星型沟通，集中化程度最高） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③圆型沟通（集中化程度最低、自由度最高） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④Y型沟通（集中化程度较高） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤全通道型沟通（同圆型沟通，成员之间地位平等）（2）非正式沟通网络（信息传递线路不规则）：&nbsp;&nbsp;&nbsp;①单线式（单串式）&nbsp;&nbsp;&nbsp;②偶然式（概率式）：事先没有传播对象&nbsp;&nbsp;&nbsp;③流言式（饶言式）：一个传播者主动把消息传播给其他人（传播来源及传播的中心）&nbsp;&nbsp;&nbsp;④集束式：有选择性地传递给有关的人 轮型最快，圆型其次，链型最慢（将任务和沟通网络合理匹配是提高工作成效的关键） P398-402 沟通工具 语言沟通（在语言基础上，运用语音、文字来进行的沟通）： 口头沟通（借助口头语言） 书面沟通（书面语言） 非语言沟通（不使用语言或超出严格意义的语言含义本身，运用人的动作、行为等进行沟通的形式）： 辅助语言（伴随着口头语言的有声暗示组成的）：语速、音调、音量、暂停和沉默 身体语言：面部表情和目光、动体态（人通过动作表现出来的躯体状态，有自身动作和身体接触两种）和静体态（人相对稳定不动的躯体状态） 空间距离： 位置 距离 亲密距离（人际交往中保持的最近的距离） 人际距离（非正式的个人交谈） 社会距离（不太熟悉的人们之间保持的距离） 公共距离（被用于公共演讲，相互距离比较远） 朝向（沟通主体相对于对方的角度） 面对面（专注，沟通双方面部、肩膀相对） 背对背（极端的否定意味 肩对肩（不利于目光交流 v形朝向（既无疏远之感，又文明卫生 P412 沟通障碍 沟通障碍： 发送者对信息进行编码并选择传递渠道过程中的障碍： 信息、意图与思想在酝酿中的障碍：信息可靠性障碍、思维障碍、信息超载障碍、信息过滤障碍 编码过程中的障碍（编码：发送者将信息转变为接收者可以理解的形式的过程）：语言障碍、编码冲突障碍 选择渠道中的障碍 发送者传递信息过程中的障碍：噪声干扰障碍（噪声：干扰信息传递的任何事物） 接收者接收信息并解码过程中的障碍（解码：接收者解释信息、赋予其意义的过程）： 信任障碍 倾听障碍 知觉选择性障碍 接收者反馈过程中的障碍：缺乏反馈 克服沟通障碍与提高沟通效率： 沟通意图明确、准备充分： 沟通意图明确 了解对方、赢得信任：不要说谎、主动提供信息、不要遗漏重要的细节、保守别人的秘密、真情流露 传递必要的、正确的、真实的、清晰的信息 正确使用沟通工具： 正确使用语言工具 注意非语言的提示 选择适当的沟通渠道：选择合适的沟通场合、安排合适的沟通时间、排除外界干扰 运用反馈： 信息发送者：愿意接收反馈、注意非语言的信息、善于利用提问、利用复述 信息接收者：强调具体行为、使反馈不针对个人而是针对工作、使反馈指向目标、把握反馈的良机、使消极的反馈指向接收者要控制的行为。 积极倾听： 利于了解和掌握更多的信息 有助于发现问题 有助于以后的工作中有针对性地进行接触 有助于防止主观误差 调控情绪：适当表达自我情绪（真情流露） 第十六章：控制的基本理论和方法 P446 控制定义 最基本含义：维持达到目标的正确行动路线 现代管理活动的定义：按照计划标准衡量计划完成情况和纠正计划执行过程中的偏差，以确保计划目标的实现，或适当修改计划，使计划更加适合实际情况。 P450 控制类型 按逻辑发展分类： 试探控制（“碰运气”，对解决问题所必需的条件不了解，对控制对象的性质不清楚的情况下出于无奈所能采取的唯一方法，完全建立在偶然机遇的基础上，有较大的风险） 经验控制（把由试探控制得出的结果用于指导下一次控制） 推理控制（根据事物之间的相似性，用类比的方法，将一件事物的控制） 最佳控制（符合最优标准。在给定约束条件下，寻求一个控制是给定的系统性能指标最大或最小） 按控制的信息有无回路分类： 开环控制：受控客体不对控制主体产生反作用的控制过程，即不存在反馈回路的控制 存在反馈闭合回路的控制 按控制发生在受控系统运行的不同阶段分类： 预先控制（前馈控制、事前控制） 同步控制：在活动进行过程中实行的控制 反馈控制（事后控制） 按控制的方式不同分类： 程序控制：受控系统按计划运行，以保证系统状态不偏离计划轨道 目标控制（跟踪控制）：用受控系统运行时的目标状态，相对于输入目标的偏差，来指导或纠正系统未来的行为 P457 控制程序 确定控制标准（控制过程的起点）：标准的分类： 定性标准 定量标准：时间标准、数量标准、质量标准、成本标准制定标准的方法： 用统计分析法来确定预期结果（根据过去同类业务的统计资料，在分析当前及今后组织技术条件变化的基础上来确定标准的方法） 根据经验和判断来估计与预期的后果（经验估计法：由经验丰富的管理人员结合实际情况，直接估计来制定标准的方法 在客观的技术分析基础上建立工程标准（技术分析法：在分析研究生产技术、组织条件，挖掘潜力和操作合理化的基础上，通过分析计算或技术测定来制定标准的方法） 测定实际工作（把实际情况与标准进行比较，对工作做出客观评价）： 直接观察（直接接触受控对象，了解情况，收集第一手资料做出判断） 统计分析（根据统计报表和其他统计资料分析受控对象的实际工作情况） 例会报告（通过定期或不定期的会议或下属的书面或口头报告调查受控对象的情况） 信息质量： 真实性 完整性 及时性 实用性 注意情况： 通过衡量成绩，检验标准的客观性和有效性 确定适宜的衡量额度（额度指数量） 建立信息反馈系统 纠正已有偏差（控制的关键）： 找出偏差产生的主要原因 确定纠偏措施的实施对象 纠偏工作采取的主要方法（立即执行的临时应急措施、永久性的根治措施） 加强管理、监督，确保工作与目标的接近或吻合； 按实际情况修改计划成目标； 启动备用计划或重新制定新的计划]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
</search>
